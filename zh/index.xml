<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CloudWeGo – CloudWeGo</title><link>https://www.cloudwego.io/zh/</link><description>Recent content on CloudWeGo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://www.cloudwego.io/zh/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Volo 0.4.1 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/03/20/volo-0.4.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 20 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/03/20/volo-0.4.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Volo 0.4.1 版本中，除了常规 bugfix 之外，还有一些新的 feature 引入。&lt;/p>
&lt;h2 id="更为详细的-thrift-decode-错误信息">更为详细的 Thrift Decode 错误信息&lt;/h2>
&lt;p>之前版本的 Thrift Decode 错误信息只会报告出最基本的错误，而不带有任何上下文。
比如含有如下结构关系&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-thrift" data-lang="thrift">&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">A&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">required&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">B&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">b&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">B&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">required&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">C&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">c&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">C&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">required&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">a&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在对结构&lt;code>C&lt;/code>的字段&lt;code>a&lt;/code>进行 Decode 如果发生错误。在之前的版本中错误信息只会报告针对出&lt;code>a&lt;/code>字段的错误，而在现在的版本中会报告出 Decode 的错误信息链路是在 &lt;code>A&lt;/code> -&amp;gt; &lt;code>B&lt;/code> -&amp;gt; &lt;code>C&lt;/code> 这个过程中发生的，会更方便信息的排查&lt;/p>
&lt;h2 id="框架-stats-信息">框架 stats 信息&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/volo/pull/149">#149&lt;/a> 为框架增加了更多的 stats 信息。用户可以在中间件自行处理这些数据，比如进行日志记录或者上报到监控系统。&lt;/p>
&lt;h2 id="在服务发现的-discover-中支持部分-key-的监听">在服务发现的 Discover 中支持部分 key 的监听&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/volo/pull/155">#155&lt;/a> 在服务发现的 Discover 中支持部分 key 的监听，这样可以减少不必要的监听，提升性能。&lt;/p>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：&lt;a href="https://github.com/cloudwego/volo/compare/volo-thrift-0.3.2...volo-0.4.1">Volo Changelog&lt;/a>&lt;/p></description></item><item><title>Blog: Kitex v0.5.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/03/08/kitex-v0.5.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Wed, 08 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/03/08/kitex-v0.5.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="重要变更介绍">重要变更介绍&lt;/h2>
&lt;h3 id="功能">功能&lt;/h3>
&lt;p>&lt;strong>1. Fallback 功能: 支持 Client 侧的 Fallback 功能&lt;/strong>&lt;/p>
&lt;p>业务在 RPC 请求失败后通常会有一些降级措施保证有效返回（比如在请求超时、熔断后，构造默认返回），Kitex 的 Fallback 支持对所有异常请求进行处理。
同时，因为业务异常通常会通过 BaseResp 字段返回，所以也支持对 Resp 进行处理。详见 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/basic-feature/fallback/">Fallback&lt;/a>。&lt;/p>
&lt;p>&lt;strong>2. Kitex - gRPC：Client 增加 TLS 的配置&lt;/strong>&lt;/p>
&lt;p>通过 client.WithGRPCTLSConfig option 配置。&lt;/p>
&lt;p>&lt;strong>3. Kitex - 工具&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>支持自定义脚手架模板&lt;/strong>，详见： &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/code-gen/custom_tpl/">自定义脚手架模板&lt;/a>&lt;/li>
&lt;li>&lt;strong>支持指定生成代码的目录&lt;/strong>，详见： &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/code-gen/code_generation/#-gen-path">代码生成工具 -gen-path&lt;/a>&lt;/li>
&lt;li>&lt;strong>支持 protoc 插件选项&lt;/strong>，详见： &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/code-gen/code_generation/#-protobuf-plugin">代码生成工具 -protobuf-plugin&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="优化">优化&lt;/h3>
&lt;p>&lt;strong>1. 负载均衡：使用权重轮询作为默认 Loadbalance 策略&lt;/strong>&lt;/p>
&lt;p>旧版本默认使用权重随机做 Loadbalance，Random 可以做到全局的均衡，但在服务端实例较少的情况下，随机有较大概率连续访问一个实例，导致下游节点最大并发请求数增加，所以新版本将默认策略调整为轮询。
详见：&lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/basic-feature/loadbalance/">负载均衡&lt;/a>。&lt;/p>
&lt;p>&lt;strong>2. 连接池协程问题&lt;/strong>&lt;/p>
&lt;p>旧版本在使用长连接时，每个 client 对应一个协程资源清理连接，在 client 较多时会导致协程过多，新版本改为共享协程避免 goroutine 数量随着 client 数量增长。&lt;/p>
&lt;h3 id="其他">其他&lt;/h3>
&lt;p>升级 frugal, pid 库依赖以支持 go 1.20。&lt;/p>
&lt;hr>
&lt;h2 id="详细变更">详细变更&lt;/h2>
&lt;h3 id="feature">Feature&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/840">#840&lt;/a>] feat(fallback): support fallback ability for kitex client-side, usage guide refer to &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/basic-feature/fallback">Fallback&lt;/a>&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/841">#841&lt;/a>] feat(tool): add GetResult() and GetFirstArgument() methods for service params of protobuf&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/791">#791&lt;/a>] feat(tool): merge two ways of passing extensions, to support two ways at sametime&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/797">#797&lt;/a>] feat(loadbalance): use smooth weighted round robin algo as default Loadbalance policy&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/760">#760&lt;/a>] feat(grpc): support TLS config in kitex grpc client&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/781">#781&lt;/a>] feat(tool): supports custom templates&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/783">#783&lt;/a>] feat(ttheader): add encode logic for gdpr token in TransInfo&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/775">#775&lt;/a>] feat(tool): support custom generate path&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/687">#687&lt;/a>] feat(tool): add protoc plugin flag&lt;/li>
&lt;/ul>
&lt;h3 id="optimize">Optimize&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/750">#750&lt;/a>] optimize(generic): generic call write zero value for required and default fields to meet the specification of apache thrift and keep consistent with normal thrift encode of Kitex.&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/739">#739&lt;/a>] optimize(generic): modify the url routing to align with Hertz for HTTP generic call&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/752">#752&lt;/a>] optimize(ttheader): attach part of ttheader binary into error when readKVInfo failed, which is useful for troubleshooting&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/821">#821&lt;/a>] optimize(config): add DeepCopy() &amp;amp; Equals() to circuitbreaker.CBConfig and retry.Policy&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/827">#827&lt;/a>] optimize: revise the remoteInfo of retry call, using the remoteInfo of the RPCCall that returns&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/762">#762&lt;/a>] optimize(tool): add go mod auto replace to thrift 0.13 in thrift mode&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/755">#755&lt;/a>] optimize: improve client error msg when ctx cancel or timeout&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/756">#756&lt;/a>] optimize: use sync.Cond as the profiler event trigger&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/753">#753&lt;/a>] optimize: add recover for client&amp;rsquo;s Close&lt;/li>
&lt;/ul>
&lt;h3 id="fix">Fix&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/734">#734&lt;/a>] fix(retry): fix the panic problem caused by concurrent read and write of rpcinfo under backup retry&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/837">#837&lt;/a> &lt;a href="https://github.com/cloudwego/kitex/pull/842">#842&lt;/a>] fix(metahandler): adjust MetainfoHandler to the top of the MetaHandlers array to ensure that the logic of custom MetaHandlers that depends on MetainfoHandler works&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/812">#812&lt;/a>] fix: use detectionHandler to perform protocol detection in windows environment to support gRPC&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/851">#851&lt;/a>] fix: upgrade frugal to v0.1.6 for missing stop field&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/845">#845&lt;/a>] fix: fix the problem that RPCStat report status as success when biz handler return err&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/822">#822&lt;/a>] fix(loadbalance): don&amp;rsquo;t share balancer factory when loadbalance is defined by user&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/732">#732&lt;/a>] fix(mux): mux server waits for shardqueue close before shutdown&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/795">#795&lt;/a>] fix(grpc): zero first byte of grpc data frame, which could be random data from mcache&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/668">#668&lt;/a>] fix: fix race problem in queue.go/queue @dugenkui03&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/743">#743&lt;/a>] fix: use sharedTicker for long conn pool to prevent goroutine numbers increase as the number of client increases&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/799">#799&lt;/a>] fix(util): should return when get at least one GOPATH @StellarisW&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/807">#807&lt;/a>] fix(codec): fix fastpb nil ptr when struct fields are all default values&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/794">#794&lt;/a>] fix(tool): fix fastpb codegen by updating dependency&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/787">#787&lt;/a>] fix(tool): the import did not use the new method to render when template append content&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/785">#785&lt;/a>] fix(tool): remove useless combine service files&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/754">#754&lt;/a>] fix: fix the usage of metainfo in grpc scene&lt;/li>
&lt;/ul>
&lt;h3 id="refactor">Refactor&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/814">#814&lt;/a> &lt;a href="https://github.com/cloudwego/kitex/pull/843">#843&lt;/a>] refactor(trans): return error in onRead of defaultServerHandler and close conn in outer method&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/816">#816&lt;/a>] refactor(utils): add utils.GetEnvLogDir and deprecate utils.GetLogDir&lt;/li>
&lt;/ul>
&lt;h3 id="test--docs--chore">Test &amp;amp; Docs &amp;amp; Chore&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/839">#839&lt;/a> &lt;a href="https://github.com/cloudwego/kitex/pull/693">#693&lt;/a>] test: import mockey repo and add usage demo of mockey unit test&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/806">#806&lt;/a>] test(transmeta):add some test cases for tansmeta package&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/761">#761&lt;/a>] docs: update README.md @fuergaosi233&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/817">#817&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/832">#832&lt;/a>] chore: upgrade dependency lib to adapt go 1.20&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/772">#772&lt;/a>] chore: modify kitex gen code meta file name from kitex.yaml to kitex_info.yaml&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.6.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/03/02/hertz-v0.6.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/03/02/hertz-v0.6.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz 0.6.0 版本中，除了常规迭代优化之外，我们还带来了多个重要 feature。&lt;/p>
&lt;h2 id="支持-http-trailer">支持 HTTP Trailer&lt;/h2>
&lt;p>在 Hertz v0.6.0 版本中，我们支持了 HTTP Trailer 的编码和解析。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz-examples/tree/main/trailer">https://github.com/cloudwego/hertz-examples/tree/main/trailer&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>写 Trailer&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8f5902;font-style:italic">// server 端
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">handler&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Good&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// client 端
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">req&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Good&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>读 Trailer&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8f5902;font-style:italic">// server 端
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">handler&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">){&lt;/span>
&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// client 端
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000">resp&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Header&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Trailer&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">Get&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Hertz&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="http11-支持-response-writer-劫持">HTTP/1.1 支持 Response Writer 劫持&lt;/h2>
&lt;p>在 Hertz v0.6.0 版本中，我们扩展了 HTTP/1.1 写请求的方式，在原来写请求流程的基础之上，支持用户在业务 handler/中间件中劫持 Response Writer，实现更加灵活的写请求方式。
简单来说，原来所有的“底层写”逻辑统一放到 handler/中间件返回之后，这个带来两个比较明显的局限性：&lt;/p>
&lt;ol>
&lt;li>用户无法控制请求真正 flush 到对端的时机&lt;/li>
&lt;li>针对 chunk 方式增量产生数据 &amp;amp; 实时写到对端的场景，在老的架构之上用法相对复杂，限制相对较多&lt;/li>
&lt;/ol>
&lt;p>基于此我们扩展出一套能够提供自行 flush 请求头和请求体的能力，同时提供了一个支持用户按需发送 chunk 数据的 Writer。详细实现参考：https://github.com/cloudwego/hertz/pull/610&lt;/p>
&lt;h3 id="主要变更">主要变更&lt;/h3>
&lt;ol>
&lt;li>增加了一个扩展 Writer 的接口定义，实现了这个接口的 Writer 都可以用作劫持 Response Writer：
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">ExtWriter&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">io&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Writer&lt;/span>
&lt;span style="color:#000">Flush&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// Finalize will be called by framework before the writer is released.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// Implementations must guarantee that Finalize is safe for multiple calls.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">Finalize&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>提供了一个实现了上述接口的 Chunk Writer（有类似需求都可以参考这个来实现）：&lt;code>chunkedBodyWrite&lt;/code>&lt;/li>
&lt;li>HTTP/1.1 具体写请求的地方针对被劫持了 Writer 的 Response 写操作做了对应的处理（跳过默认写请求逻辑），最后调用&lt;code>ExtWriter&lt;/code>接口的&lt;code>Finalize()&lt;/code>方法完成一次请求写回&lt;/li>
&lt;/ol>
&lt;h3 id="使用方法">使用方法&lt;/h3>
&lt;p>如上，Hertz 提供了一个默认的&lt;code>ExtWriter&lt;/code>实现满足用户在 handler/中间件中的主动 flush 需求，使用方式也非常简单：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#000">h&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GET&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/flush/chunk&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">func&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">app&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">RequestContext&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// Hijack the writer of response
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">HijackWriter&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">resp&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewChunkedBodyWriter&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">GetWriter&lt;/span>&lt;span style="color:#000;font-weight:bold">()))&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">10&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">++&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Write&lt;/span>&lt;span style="color:#000;font-weight:bold">([]&lt;/span>&lt;span style="color:#204a87">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Sprintf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;chunk %d: %s&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">strings&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Repeat&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;hi~&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">i&lt;/span>&lt;span style="color:#000;font-weight:bold">))))&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// nolint: errcheck
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">ctx&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Flush&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// nolint: errcheck
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Sleep&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">200&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span> &lt;span style="color:#000">time&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Millisecond&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000;font-weight:bold">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="脚手架使用优化--最佳实践">脚手架使用优化 &amp;amp; 最佳实践&lt;/h2>
&lt;p>在 hz v0.6.0 版本中，我们对生成代码的组织结构进行一系列的优化，从而可生成更加灵活的代码组织结构&lt;/p>
&lt;h3 id="主要优化">主要优化&lt;/h3>
&lt;ul>
&lt;li>&lt;code>new&lt;/code> 命令支持 &amp;ldquo;router_dir&amp;rdquo; 选项，并配合已有的 &amp;ldquo;handler_dir&amp;rdquo;、&amp;ldquo;model_dir&amp;rdquo;，可完全自定义 IDL 生成产物的路径；并且会将这些自定义选项持久化到 &amp;ldquo;.hz&amp;rdquo; 文件中，可在 &lt;code>update&lt;/code> 时自动读取，减少命令的复杂度&lt;/li>
&lt;li>增加向上搜索 &amp;ldquo;go.mod&amp;rdquo; 文件的能力，从而使得 hertz 在作为一个子项目时可以和其他项目共享同一个 &amp;ldquo;go module&amp;rdquo;&lt;/li>
&lt;li>增加 &amp;ldquo;handler&amp;rdquo; 中引用第三方 IDL 产物的能力，可将 IDL 产物放到第三方仓库单独维护，使其不在项目目录中存放，进一步增强 IDL 管理能力&lt;/li>
&lt;/ul>
&lt;h3 id="最佳实践">最佳实践&lt;/h3>
&lt;p>我们利用 &amp;ldquo;hz v0.6.0&amp;rdquo; 重写了 &amp;ldquo;&lt;a href="https://github.com/cloudwego/biz-demo/pull/26">biz-demo/easy-note&lt;/a>&amp;quot;，主要利用了如下 hz 的特性&lt;/p>
&lt;ul>
&lt;li>利用 &amp;ldquo;hz client&amp;rdquo; 的能力，基于 IDL 生成访问 &amp;ldquo;api server&amp;rdquo; 的 hertz client 调用代码&lt;/li>
&lt;li>利用自定义 &amp;ldquo;router_dir&amp;rdquo;、 &amp;ldquo;handler_dir&amp;rdquo;、&amp;ldquo;model_dir&amp;rdquo; 选项，重新调整 &amp;ldquo;api server&amp;rdquo; 代码的组织结构，去掉 &amp;ldquo;biz&amp;rdquo; 目录的限制&lt;/li>
&lt;li>利用 &amp;ldquo;向上搜索 go.mod&amp;rdquo; 的能力，使得 &amp;ldquo;api server&amp;rdquo; 可以作为 &amp;ldquo;easy-note&amp;rdquo; 的子项目共享同一个 &amp;ldquo;go module&amp;rdquo;&lt;/li>
&lt;li>利用 &amp;ldquo;handler 引用第三方 IDL 产物&amp;rdquo; 的能力并配合 &amp;ldquo;hz model&amp;rdquo; 的能力，使得 IDL 产物单独存到到 &amp;ldquo;easy-note&amp;rdquo; 项目里，而并不存放到 &amp;ldquo;api server&amp;rdquo; 子项目里&lt;/li>
&lt;/ul>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：&lt;/p>
&lt;ul>
&lt;li>Hertz: &lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.6.0">https://github.com/cloudwego/hertz/releases/tag/v0.6.0&lt;/a>&lt;/li>
&lt;li>Hz(脚手架): &lt;a href="https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.6.0">https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.6.0&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blog: HTTP 框架 Hertz 实践入门：性能测试指南</title><link>https://www.cloudwego.io/zh/blog/2023/02/24/http-%E6%A1%86%E6%9E%B6-hertz-%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</link><pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/02/24/http-%E6%A1%86%E6%9E%B6-hertz-%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</guid><description>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2021 年 9 月 8 日，字节跳动宣布正式开源 &lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a>。CloudWeGo 是一套字节跳动内部微服务中间件集合，具备&lt;strong>高性能、强扩展性和稳定性&lt;/strong>的特点，专注于解决微服务通信与治理的难题，满足不同业务在不同场景的诉求。
2022 年 6 月 21 日，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 正式开源。日前，CloudWeGo 团队正式开源字节跳动最大的 HTTP 框架 Hertz。Hertz 自发布以来，得到了大量用户的关注，累计收获了 3K+ star。有很多用户自己进行了测试，感谢大家对我们的关注和支持。
本文旨在分享开发者在压测 Hertz 时需要了解的场景和技术问题。这些建议有助于用户更好地结合真实 HTTP 场景对 Hertz 进行调优，使之更贴合业务需要、发挥最佳性能。用户也可以参考官方提供的压测项目 &lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 了解更多细节。&lt;/p>
&lt;h2 id="微服务-http-场景的特点">微服务 HTTP 场景的特点&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 诞生于字节跳动大规模微服务架构实践，面向的场景自然是微服务场景，因此下面会先介绍微服务 HTTP 场景的特点，方便开发者深入理解 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的设计思考。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>HTTP 通信模型&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>微服务间的通信通常以 Ping-Pong 模型为主，除了常规的吞吐性能指标外，每次 HTTP 的&lt;strong>平均时延&lt;/strong>也是开发者需要考虑的点。吞吐达到瓶颈时可以通过增加机器快速解决，但对用户使用体验有显著影响的时延却没有那么容易降低。
在微服务场景下，一次调用往往需要多个微服务协作完成，即使每个节点延迟很低，最终汇聚到链路上的时延也会被放大，因此微服务场景下时延指标是开发者更应该关注的点。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在保证吞吐的前提下，也针对时延做了一定优化。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>长短连接使用&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>由于 TCP 连接首次建立时需要三次握手，如果每个请求都建立新连接，这部分的开销是非常大的。因此对于时延敏感型服务，尽量使用长连接完成请求。在 HTTP 1.1 中，长连接也是默认的选项。
但是没有银弹，维持连接也需要消耗资源，长连接的水平扩展能力也不如短连接。因此，在某些场景下并不适合使用长连接，比如定时拉取配置的场景，
在这个场景下，建连时延对配置影响并不大，且当配置中心负载过高时，希望能够方便的进行水平扩容，这时短连接可能是一个更好的选择。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>包体积大小&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>一个服务的包大小取决于实际的业务场景。HTTP 场景的数据可以放在 query、path、header、body 等地方，不同位置对解析造成的影响也不一样。
HTTP 的 header 是标识符协议，在没有找到特定的标识符之前，框架并不知道 header 还有多少，因此框架需要收到全部的 header 后才能够解析完成，对框架的内存模型不很友好。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也针对 header 解析做了特殊的优化，分配足够的 buffer 空间给 header，减少 header 处理时跨包拷贝的开销。&lt;/p>
&lt;p>同时在字节跳动内部线上服务的统计中，发现大部分包在 1K 以内（但是太小的包没有实际意义，比如固定返回 &amp;ldquo;hello world&amp;rdquo;），同时大包场景上不封顶，各个包大小均有涉及，所以 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在最常用的 128k 以内的包的性能（吞吐和时延）进行了重点优化。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>并发数量&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>每个实例的上游可能会有很多个，不会只接受某个实例的请求；而且，HTTP 1 的连接不能够多路复用，每条连接上只能同时处理一个请求。因此 Server 需要接受多个连接同时处理。
不同服务的连接使用率也不同，比如压测服务的连接使用率很高，一个请求完成后马上就会进行下一个请求；有的服务连接使用率很低，虽然是长连接，但是只使用一次。这两者使用的连接模型并不相同，
前者应使用 goroutine per connection 的模型减少上下文的切换，后者应使用协程池减少过多 goroutine 的调度开销。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也同时支持这两种场景，用户可以根据自己的业务场景选择合适的配置。&lt;/p>
&lt;h2 id="针对-http-场景进行压测">针对 HTTP 场景进行压测&lt;/h2>
&lt;h3 id="使用贴近自己的场景">使用贴近自己的场景&lt;/h3>
&lt;p>Github 上的压测项目有很多，网络上也有很多性能测试报告，但是这些项目和测试不一定贴合自己。举个极端一点的例子，在真实场景中你会写一个项目无论 Client 发什么 Server 都只回 &lt;strong>&lt;code>hello world&lt;/code>&lt;/strong> 吗？很遗憾，很多的压测项目就是这么做的。&lt;/p>
&lt;p>在进行压测前，应考虑自己真正的使用场景，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>长短连接的使用&lt;/strong> ：使用长连接还是短连接更符合自己的场景。&lt;/li>
&lt;li>&lt;strong>连接使用率的估算&lt;/strong> ：如果使用长连接，且连接使用率很高（大部分场景），则使用默认配置即可；如果连接使用率很低，可以添加配置：&lt;strong>&lt;code>server.WithIdleTimeout(0)&lt;/code>&lt;/strong>，将 goroutine per connection 的模型修改为协程池模型，并进行对比测试。&lt;/li>
&lt;li>&lt;strong>数据位置及大小的确定&lt;/strong> ：上面提到不同位置（如 query、header、body 等）及大小的数据对框架可能造成影响，如果所有框架的性能都比较一般，可以考虑换一个数据传输位置。&lt;/li>
&lt;li>&lt;strong>并发数的确定&lt;/strong> ：有的服务属于轻业务重框架，这个时候框架的并发可能会很高；有的服务属于重业务轻框架，这个时候框架的并发可能会很低。&lt;/li>
&lt;/ul>
&lt;p>如果只是想看一下框架的性能，可以使用常规的场景：&lt;strong>长连接、较高连接使用率、1k body、100 并发&lt;/strong>等。&lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 仓库默认的压测配置也是如此。
同时 &lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 仓库也开发给用户 header、body、并发数的配置，用户可以方便的修改这些配置完成贴合自己的压测。&lt;/p>
&lt;h3 id="确定压测对象">确定压测对象&lt;/h3>
&lt;p>衡量一个 RPC 框架的性能需要从两个视角分别去思考：Client 视角与 Server 视角。在大规模的业务架构中，上游 Client 不见得使用的也是下游的框架，而开发者调用的下游服务也同样如此，如果再考虑到 Service Mesh 的情况就更复杂了。&lt;/p>
&lt;p>一些压测项目通常会把 Client 和 Server 进程混部进行压测，然后得出&lt;strong>整个框架&lt;/strong>的性能数据，这其实和线上实际运行情况很可能是不符的。&lt;/p>
&lt;p>如果要压测 Server，应该给 Client 尽可能多的资源，把 Server 压到极限，反之亦然。如果 Client 和 Server 都只给了 4 核 CPU 进行压测，会导致开发者无法判断最终得出来的性能数据是哪个视角下的，更无法给线上服务做实际的参考。&lt;/p>
&lt;h3 id="使用独占-cpu">使用独占 CPU&lt;/h3>
&lt;p>虽然线上应用通常是多个进程共享 CPU，但在压测场景下，Client 与 Server 进程都处于极端繁忙的状况，此时共享 CPU 会导致大量上下文切换，从而使得数据缺乏可参考性，且容易产生前后很大波动。&lt;/p>
&lt;p>所以我们建议是将 Client 与 Server 进程隔离在不同 CPU 或者不同独占机器上进行。如果还想要进一步避免其他进程产生影响，可以再加上 nice -n -20 命令调高压测进程的调度优先级。&lt;/p>
&lt;p>另外如果条件允许，相比云平台虚拟机，使用真实物理机会使得测试结果更加严谨与具备可复现性。&lt;/p>
&lt;h2 id="性能数据参考">性能数据参考&lt;/h2>
&lt;p>在满足上述要求的前提下，我们基于当前最新版本对多个框架进行了压测对比，压测代码在 &lt;a href="https://github.com/cloudwego/hertz-benchmark">hertz-benchmark&lt;/a> 仓库。
在充分压满 Server 的目标下，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的 P99 延迟在所有压测框架中最低，吞吐也是属于第一梯队，且在持续优化中。&lt;/p>
&lt;ul>
&lt;li>CPU: AMD EPYC 7Y83 64-Core Processor 2.7GHz
&lt;ul>
&lt;li>运行限定 server 4-CPUs，client 16-CPUS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>OS：Debian GNU/Linux 10 (buster)&lt;/li>
&lt;li>Go 1.19&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.3.2">hertz v0.3.2&lt;/a>，&lt;a href="https://github.com/valyala/fasthttp/releases/tag/v1.40.0">fasthttp v1.40.0&lt;/a>，
&lt;a href="https://github.com/gin-gonic/gin/releases/tag/v1.8.1">gin v1.8.1&lt;/a>，&lt;a href="https://github.com/gofiber/fiber/releases/tag/v2.38.1">fiber v2.38.1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Hertz-benchmark/1.png" alt="image">&lt;/p>
&lt;p align="center">四个框架的吞吐和时延比较&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Hertz-benchmark/2.png" alt="image">&lt;/p>
&lt;p align="center">三个框架的吞吐和时延比较&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>作为一个超大规模企业级的微服务 HTTP 框架，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在设计之初就更倾向于解决大规模微服务场景下的各种问题。在推广过程中也遇到了各种各样的服务，踩了各种各样的坑，也是基于以上经验写了本文。
欢迎广大开发者基于本文提供的测试指南，针对自己的实际场景选择合适的工具。更多问题，请在 GitHub 上提 &lt;a href="https://github.com/cloudwego/hertz/issues">Issue&lt;/a> 交流。&lt;/p></description></item><item><title>Blog: Volo 0.3.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/02/07/volo-0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/02/07/volo-0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Volo 0.3.2 版本中，除了常规 bugfix 之外，还有多处改进。尤其是，有社区贡献者为我们带来了重要的 feature，非常感谢他们。&lt;/p>
&lt;h2 id="thrift-异步编解码-trait-支持">Thrift 异步编解码 Trait 支持&lt;/h2>
&lt;p>&lt;a href="https://github.com/ii64">@ii64&lt;/a> 在 &lt;a href="https://github.com/cloudwego/volo/pull/123">#123&lt;/a> 中为我们带来了 Thrift 异步编解码 Trait 的定义和 Binary、Apache Compact Protocol 的实现，在此之前他还为 Pilota 贡献了编解码的底层实现！&lt;/p>
&lt;h2 id="grpc-graceful-shutdown-支持">gRPC graceful shutdown 支持&lt;/h2>
&lt;p>&lt;a href="https://github.com/iGxnon">@iGxnon&lt;/a> 在 &lt;a href="https://github.com/cloudwego/volo/pull/127">#127&lt;/a> 中为我们带来了 gRPC graceful shutdown 的支持！&lt;/p>
&lt;h2 id="metainfo-与-faststr-版本更新">metainfo 与 faststr 版本更新&lt;/h2>
&lt;p>在这个版本中，我们更新了 metainfo 和 faststr 的版本，使得 metainfo 也支持了 faststr，以在尽可能多的场景下减少内存分配和拷贝，以优化性能。&lt;/p>
&lt;p>faststr 是我们参考 smol_str 改进的一个 string 库，实现了 immutable string 的零开销 clone。&lt;/p>
&lt;p>同时 FastStr 有一个不兼容变更：之前是为所有&lt;code>AsRef&amp;lt;str&amp;gt;&lt;/code>实现了&lt;code>From&lt;/code>，但是这样做会导致直接使用&lt;code>into&lt;/code>会带来额外的内存分配和拷贝开销。
在新的 0.2 版本中，我们只为 &lt;code>'static str&lt;/code>、&lt;code>String&lt;/code>、&lt;code>Arc&amp;lt;str&amp;gt;&lt;/code>、&lt;code>Arc&amp;lt;String&amp;gt;&lt;/code>四种类型实现了&lt;code>From&lt;/code>，这四种类型调用 &lt;code>into&lt;/code> 到 FastStr 是零开销的，通过这种形式避免用户不经意间带来的内存分配和拷贝问题。&lt;/p>
&lt;p>旧版本的&lt;code>From&lt;/code>本质上就是调用了&lt;code>FastStr::new(s)&lt;/code>，因此出现不兼容问题的话，直接改为显式调用&lt;code>FastStr::new&lt;/code>即可。&lt;/p>
&lt;h2 id="pilota-中-protobuf-编解码支持生成-faststr">Pilota 中 Protobuf 编解码支持生成 FastStr&lt;/h2>
&lt;p>通过在 Pilota 中支持为 Protobuf 编解码生成 FastStr，我们可以将我们的性能优化能力带到 PB 和 gRPC 中。&lt;/p>
&lt;p>升级后，需要把原先引入的&lt;code>use prost::Message;&lt;/code>改为&lt;code>use pilota::prost::message::Message;&lt;/code>即可。&lt;/p>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：&lt;a href="https://github.com/cloudwego/volo/compare/volo-0.3.0...volo-0.3.2">Volo Changelog&lt;/a>&lt;/p></description></item><item><title>Blog: Hertz v0.5.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2023/01/12/hertz-v0.5.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2023/01/12/hertz-v0.5.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Hertz 0.5.0 版本中，除了常规迭代优化之外，我们还带来了多个重要 feature。&lt;/p>
&lt;h2 id="网络层和协议层支持基于流的接口">网络层和协议层支持基于流的接口&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz/pull/467">https://github.com/cloudwego/hertz/pull/467&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在 Hertz v0.5.0 版本中，我们进一步加强了 Hertz 传输层 &amp;amp; 协议层可扩展能力，支持无缝对接基于流的传输层协议 QUIC，以及在此之上构建的 &lt;a href="https://github.com/cloudwego/hertz/issues/458">HTTP3 协议。&lt;/a>
此外，我们在此基础上还增加和完善了 &amp;ldquo;ALPN&amp;rdquo;(应用层协议协商)、&amp;ldquo;QUIC/TLS parallel monitoring&amp;rdquo;(QUIC/TLS并行监听)、&amp;ldquo;Alt-Svc&amp;rdquo;(备选服务) 等功能。&lt;/p>
&lt;h3 id="主要变更">主要变更&lt;/h3>
&lt;h4 id="传输层">传输层&lt;/h4>
&lt;p>我们在保证兼容性能的基础之上增加了一个针对基于流（stream-based）的网络连接接口抽象&lt;code>StreamConn&lt;/code>，同时调整传输层和协议层的交互逻辑，实现针对连接类型的分发正确的协议层处理（protocol server）。
针对需要同时监听监听 TCP（TLS）以及 UDP(QUIC)的场景我们提供了一个&lt;code>WithAltTransporter&lt;/code>选项，方便将备用 transporter 传递到主 transporter 中，便于实现 QUIC/TLS 并行监听的能力。&lt;/p>
&lt;h4 id="协议层">协议层&lt;/h4>
&lt;p>支持添加基于流的协议层实现（protocol server）&lt;code>StreamServer&lt;/code>，以便于在新增的基于流的传输层扩展之上构建对应处理协议（HTTP/3）。
为了便捷的实现为某个主协议（HTTP/3）配置备选服务元信息，&lt;code>ProtocolSuite&lt;/code>对外暴露&lt;code>SetAltHeader&lt;/code>接口。
同时，我们也为&lt;code>StreamConn&lt;/code>设计了 ALPN 能力，以便于在 QUIC 内提供协议协商的能力。&lt;/p>
&lt;h4 id="通用层">通用层&lt;/h4>
&lt;p>同时我们在通用层中新增了能够与 Golang 标准 Handler 进行转换的辅助函数，以便于快速的将基于 Golang 标准 Handler 实现移植到 Hertz 中来。在之后提供的基于 &lt;a href="https://github.com/lucas-clemente/quic-go">quic-go&lt;/a> 的 &lt;a href="https://github.com/hertz-contrib/http3/pull/1">QUIC &amp;amp; HTTP/3 扩展&lt;/a>中，就用到了这个函数提供的能力。&lt;/p>
&lt;h4 id="feature-状态">Feature 状态&lt;/h4>
&lt;p>Hertz 核心库能力已经发布，具体实现后续将以&lt;a href="https://github.com/hertz-contrib/http3/pull/1">扩展包&lt;/a>的形式发布，欢迎试用~&lt;/p>
&lt;p>更多详细的设计说明可以参考：&lt;a href="https://www.cloudwego.io/zh/docs/hertz/reference/stream_based_design/">Hertz 支持 QUIC &amp;amp; HTTP/3&lt;/a>&lt;/p>
&lt;h2 id="脚手架工具支持生成-hertz-client-代码">脚手架工具支持生成 hertz client 代码&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz/pull/471">https://github.com/cloudwego/hertz/pull/471&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在脚手架工具(Hz)的 v0.5.0 的版本，我们支持了基于 IDL 自动生成 hertz client 代码的功能，并实现了类 RPC 调用形式的 HTTP 请求一键调用。
使用方法：&lt;/p>
&lt;blockquote>
&lt;p>具体详见：https://github.com/cloudwego/hertz-examples/tree/main/hz_client&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>定义 IDL&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#000">namespace&lt;/span> &lt;span style="color:#204a87;font-weight:bold">go&lt;/span> &lt;span style="color:#000">toutiao&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">middleware&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">hzClient&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">QueryReq&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span> &lt;span style="color:#000">QueryValue&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">query&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;query1&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">Resp&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span> &lt;span style="color:#000">Resp&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">service&lt;/span> &lt;span style="color:#000">Hertz121&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">Resp&lt;/span> &lt;span style="color:#000">QueryMethod&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">QueryReq&lt;/span> &lt;span style="color:#000">request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">get&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;/query&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">handler_path&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;get&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;span style="color:#000;font-weight:bold">}(&lt;/span>
&lt;span style="color:#000">api&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">base_domain&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;http://127.0.0.1:8888&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>生成代码&lt;/li>
&lt;/ol>
&lt;p>可基于上述 IDL，分别生成 server 和 client 端代码：&lt;/p>
&lt;p>server：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#000">hz&lt;/span> &lt;span style="color:#000">new&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">idl&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">psm&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">thrift&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">handler_by_method&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#000">t&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">template&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">slim&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>client：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#000">hz&lt;/span> &lt;span style="color:#000">client&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">idl&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">psm&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">thrift&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">model_dir&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">hertz_gen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#000">t&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">template&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">slim&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">--&lt;/span>&lt;span style="color:#000">client_dir&lt;/span>&lt;span style="color:#000;font-weight:bold">=&lt;/span>&lt;span style="color:#000">hz_client&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>调用 client 代码发起 HTTP 请求，实现 client 端和 server 端的互通&lt;/li>
&lt;/ol>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：&lt;/p>
&lt;ul>
&lt;li>Hertz: &lt;a href="https://github.com/cloudwego/hertz/releases/tag/v0.5.0">https://github.com/cloudwego/hertz/releases/tag/v0.5.0&lt;/a>&lt;/li>
&lt;li>Hz(脚手架): &lt;a href="https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.5.0">https://github.com/cloudwego/hertz/releases/tag/cmd%2Fhz%2Fv0.5.0&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blog: Volo 0.3.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/12/22/volo-0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/12/22/volo-0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;p>Volo 0.3.0 版本中，除了常规 bugfix 之外，我们还带来了多个重要 feature。&lt;/p>
&lt;h2 id="service-trait-重构">Service Trait 重构&lt;/h2>
&lt;p>Volo 0.3.0 版本中，我们对 Service Trait 进行了重构，使得 Service Trait 的实现更加简单，同时也提供了更多的灵活性。&lt;/p>
&lt;p>具体来看，我们将 Service Trait 的定义从：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#204a87;font-weight:bold">pub&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">trait&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Service&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// Responses given by the service.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// Errors produced by the service.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// The future response value.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Future&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>: &lt;span style="color:#000">Future&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Output&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87">Result&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Self&lt;/span>::&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Self&lt;/span>::&lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87">Send&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">where&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Cx&lt;/span>: &lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Self&lt;/span>: &lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// Process the request and return the response asynchronously.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fn&lt;/span> &lt;span style="color:#000">call&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#c4a000">&amp;#39;s&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;s&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">mut&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#3465a4">self&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">cx&lt;/span>: &lt;span style="color:#204a87;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">mut&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">req&lt;/span>: &lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>-&amp;gt; &lt;span style="color:#000">Self&lt;/span>::&lt;span style="color:#000">Future&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">where&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#c4a000">&amp;#39;s&lt;/span>: &lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改为了：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#204a87;font-weight:bold">pub&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">trait&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Service&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// Responses given by the service.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// Errors produced by the service.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// The future response value.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">Future&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>: &lt;span style="color:#000">Future&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Output&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87">Result&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">Self&lt;/span>::&lt;span style="color:#000">Response&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Self&lt;/span>::&lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87">Send&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">where&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Cx&lt;/span>: &lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Self&lt;/span>: &lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">/// Process the request and return the response asynchronously.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fn&lt;/span> &lt;span style="color:#000">call&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#c4a000">&amp;#39;s&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;s&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#3465a4">self&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">cx&lt;/span>: &lt;span style="color:#204a87;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">mut&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Cx&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">req&lt;/span>: &lt;span style="color:#000">Request&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>-&amp;gt; &lt;span style="color:#000">Self&lt;/span>::&lt;span style="color:#000">Future&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">where&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#c4a000">&amp;#39;s&lt;/span>: &lt;span style="color:#c4a000">&amp;#39;cx&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最明显的改动是，Service Trait 的方法 call() 的 self 参数由 &lt;code>&amp;amp;mut self&lt;/code> 改为了 &lt;code>&amp;amp;self&lt;/code>。这样做的目的是，之前依赖 &lt;code>&amp;amp;mut self&lt;/code> 的话，在调用之前就得 clone 拿所有权才行，需要 Service 用户自己保证 Clone 的开销低；实际上，这个 clone 是完全没必要的，这个决策应该交给用户自己决定，如果真的有需求改变内部状态的话，自己内部加锁或者用 atomic 即可，这样可以节省 clone 的开销。&lt;/p>
&lt;h2 id="grpc-多-service-支持">gRPC 多 Service 支持&lt;/h2>
&lt;p>在这个版本中，我们还支持了 gRPC 服务端同时支持多个 Service 的场景，并且每个 Service 都可以有自己的 layer；当然，Server 也可以有全局有效的 layer。&lt;/p>
&lt;p>如果某个中间件需要感知到 Request / Response 的具体类型并且做处理的，或者只针对单个 Service 的，那么可以添加为 Service 自己的 layer 即可。&lt;/p>
&lt;p>这是一个 breaking change，使用之前版本的用户可能需要修改一下代码，具体来说需要从这样：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#8f5902;font-style:italic">#[volo::main]&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">async&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fn&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">addr&lt;/span>: &lt;span style="color:#000">SocketAddr&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;[::]:8080&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">parse&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">unwrap&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">addr&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">volo&lt;/span>::&lt;span style="color:#000">net&lt;/span>::&lt;span style="color:#000">Address&lt;/span>::&lt;span style="color:#000">from&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">addr&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">volo_gen&lt;/span>::&lt;span style="color:#000">proto_gen&lt;/span>::&lt;span style="color:#000">hello&lt;/span>::&lt;span style="color:#000">HelloServiceServer&lt;/span>::&lt;span style="color:#000">new&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">S&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">run&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">addr&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">await&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">unwrap&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改成这样：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#204a87;font-weight:bold">use&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">std&lt;/span>::&lt;span style="color:#000">net&lt;/span>::&lt;span style="color:#000">SocketAddr&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">use&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">volo_grpc&lt;/span>::&lt;span style="color:#000">server&lt;/span>::&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#000">Server&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">ServiceBuilder&lt;/span>&lt;span style="color:#000;font-weight:bold">};&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#8f5902;font-style:italic">#[volo::main]&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">async&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">fn&lt;/span> &lt;span style="color:#000">main&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">addr&lt;/span>: &lt;span style="color:#000">SocketAddr&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#4e9a06">&amp;#34;[::]:8080&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">parse&lt;/span>&lt;span style="color:#000;font-weight:bold">().&lt;/span>&lt;span style="color:#000">unwrap&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">let&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">addr&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">volo&lt;/span>::&lt;span style="color:#000">net&lt;/span>::&lt;span style="color:#000">Address&lt;/span>::&lt;span style="color:#000">from&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">addr&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Server&lt;/span>::&lt;span style="color:#000">new&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">add_service&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ServiceBuilder&lt;/span>::&lt;span style="color:#000">new&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">volo_gen&lt;/span>::&lt;span style="color:#000">proto_gen&lt;/span>::&lt;span style="color:#000">hello&lt;/span>::&lt;span style="color:#000">GreeterServer&lt;/span>::&lt;span style="color:#000">new&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">S&lt;/span>&lt;span style="color:#000;font-weight:bold">)).&lt;/span>&lt;span style="color:#000">build&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">run&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">addr&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#204a87;font-weight:bold">await&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">unwrap&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="grpc-compression">gRPC Compression&lt;/h2>
&lt;p>感谢&lt;a href="https://github.com/tuchg">@tuchg&lt;/a>在&lt;a href="https://github.com/cloudwego/volo/pull/91">#91&lt;/a>中为我们带来了 gRPC 的压缩和解压缩支持，如果对于传输大小有要求的场景，可以使用这个功能。&lt;/p>
&lt;h2 id="thrift-codec-重构">Thrift Codec 重构&lt;/h2>
&lt;p>在之前的 Codec 设计中，Thrift 的编解码指定的方式是通过&lt;code>CodecType&lt;/code>来指定，这样带来了两个问题：&lt;/p>
&lt;ol>
&lt;li>无法很轻松地扩展新的协议支持，所有的支持的协议都需要在框架中实现并硬编码到 CodecType 中；&lt;/li>
&lt;li>无法将 Transport 和 Serialize 协议进行解耦和排列组合，举个例子，如果我们想要支持 TCompact 协议，那么我们就需要增加多个变体：TTHeaderFramedCompact、TTheaderCompact、FramedCompact、Compact……&lt;/li>
&lt;/ol>
&lt;p>同时，之前的编解码没有做到 Zero Copy，性能上也有可以提升的空间。&lt;/p>
&lt;p>这次的重构，一次性的解决了以上所有问题，我们不再依赖&lt;code>CodecType&lt;/code>来指定编解码方式，而是通过&lt;code>make_codec&lt;/code>这个接口来指定 Codec 的生成方式，这样我们就可以很轻松地扩展新的协议支持，同时也可以将 Transport 和 Serialize 协议进行解耦和排列组合。&lt;/p>
&lt;p>具体可以参考一下 &lt;a href="https://docs.rs/volo-thrift/latest/volo_thrift/codec/index.html">codec 的文档&lt;/a>。&lt;/p>
&lt;h2 id="thrift-生成代码默认字段变更">Thrift 生成代码默认字段变更&lt;/h2>
&lt;p>之前的生成代码中，binary 类型会生成 Vec&lt;u8>，string 类型会生成 String，这会导致在解码和编码的时候都需要进行一次 clone，性能损耗较大；在这个版本中，我们将这两个类型默认生成的 Rust 类型改为了 Bytes 和 &lt;a href="https://docs.rs/faststr/latest/faststr/">FastStr&lt;/a>，以此来实现全链路的 Zero Copy，因为在实践中我们观察到绝大多数 Request / Response 中的 binary 和 string 都是不会被修改的，而即使用户需要修改，也就是多一次 Clone 的代价，并不会比之前性能更差。&lt;/p>
&lt;p>这是一个 breaking change，使用之前版本的用户在升级后可能会需要修改一下代码，一般来说只需要根据报错信息修改一下类型即可。&lt;/p>
&lt;p>如果仍旧有需求要针对 string 生成 String 的话，可以在 thrift idl 文件中的对应字段加一个&lt;code>pilota.rust_type=&amp;quot;string&amp;quot;&lt;/code>的 annotation，如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-thrift" data-lang="thrift">&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Item&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">required&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">name&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>&lt;span style="color:#000">pilota.rust_type&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;string&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外，Pilota 还支持了其它的 Annotation，详情可以参考：https://www.cloudwego.io/zh/docs/pilota/guide/annotation/&lt;/p>
&lt;h2 id="完整-release-note">完整 Release Note&lt;/h2>
&lt;p>完整的 Release Note 可以参考：https://github.com/cloudwego/volo/releases/tag/volo-0.3.0&lt;/p></description></item><item><title>Blog: Netpoll v0.3.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/11/09/netpoll-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Wed, 09 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/11/09/netpoll-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feat">Feat&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/netpoll/pull/206">#206&lt;/a>] feat: 连接 Flush 接口支持写超时设置。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/netpoll/pull/182">#182&lt;/a>] feat: 支持在 ipv6 only 环境下创建连接。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/netpoll/pull/200">#200&lt;/a>] fix: 修复 #166 中的代码错误：close fd 没有正确的被 detach。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/netpoll/pull/196">#196&lt;/a>] fix: 系统 io 调用使用 int32 存储 size, 超限调用会导致 EINVAL。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/netpoll/pull/179">#179&lt;/a>] fix: 修复 buffer 长度 int32 溢出的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/netpoll/pull/183">#183&lt;/a>] fix: 当 EPOLLERR 发生时，跳过检查 EPOLLOUT。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex Proxyless 之流量路由：配合 Istio 与 OpenTelemetry 实现全链路泳道</title><link>https://www.cloudwego.io/zh/blog/2022/11/08/kitex-proxyless-%E4%B9%8B%E6%B5%81%E9%87%8F%E8%B7%AF%E7%94%B1%E9%85%8D%E5%90%88-istio-%E4%B8%8E-opentelemetry-%E5%AE%9E%E7%8E%B0%E5%85%A8%E9%93%BE%E8%B7%AF%E6%B3%B3%E9%81%93/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/11/08/kitex-proxyless-%E4%B9%8B%E6%B5%81%E9%87%8F%E8%B7%AF%E7%94%B1%E9%85%8D%E5%90%88-istio-%E4%B8%8E-opentelemetry-%E5%AE%9E%E7%8E%B0%E5%85%A8%E9%93%BE%E8%B7%AF%E6%B3%B3%E9%81%93/</guid><description>
&lt;blockquote>
&lt;p>导语：Kitex Proxyless 是 Kitex 服务能够不借助 envoy sidecar 直接与 istiod 交互，基于 xDS 协议动态获取控制面下发的服务治理规则，并转换为 Kitex 对应规则来实现一些服务治理功能，如流量路由。基于 Kitex Proxyless，能够实现 Kitex 无需代理就可以被 ServiceMesh 统一管理，进而实现多种部署模式下的治理规则 Spec、治理控制面、治理下发协议、异构数据治理能力的统一。本文在 biz-demo 中使用 Kitex 和 Hertz 重写 bookinfo 项目，以实战的方式演示了如何使用 xDS 实现全链路的流量泳道。&lt;/p>
&lt;/blockquote>
&lt;h2 id="01-引言">01 引言&lt;/h2>
&lt;h3 id="kitex-proxyless">&lt;strong>Kitex Proxyless&lt;/strong>&lt;/h3>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 是字节开源的 Golang RPC 框架，已经原生支持了 xDS 标准协议，支持以 Proxyless 的方式被 ServiceMesh 统一纳管。&lt;/p>
&lt;ul>
&lt;li>详细设计见：
&lt;a href="https://github.com/cloudwego/kitex/issues/461">Proposal: Kitex support xDS Protocol · Issue #461 · cloudwego/kitex&lt;/a>&lt;/li>
&lt;li>具体使用方式见&lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/advanced-feature/xds/">官方文档&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Proxyless&lt;/strong> 简单来说就是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 服务能够不借助 envoy sidecar 直接与 istiod 交互，基于 xDS 协议动态获取控制面下发的服务治理规则，并转换为 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对应规则来实现一些服务治理功能（例如本文的重点：&lt;strong>流量路由&lt;/strong>）。&lt;/p>
&lt;p>基于 &lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Proxyless&lt;/strong>，让我们实现 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 能够无需代理就可以被 ServiceMesh 统一管理，进而实现多种部署模式下的&lt;strong>治理规则 Spec、治理控制面、治理下发协议、异构数据治理能力&lt;/strong>的统一。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/1.png" alt="image">&lt;/p>
&lt;h3 id="流量路由">流量路由&lt;/h3>
&lt;blockquote>
&lt;p>流量路由是指，能够将流量&lt;strong>根据其自身特定的元数据标识路由&lt;/strong>到指定目的地。&lt;/p>
&lt;/blockquote>
&lt;p>流量路由属于服务治理中比较核心的能力之一，也是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Proxyless 优先支持的场景之一。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 基于 xDS 实现&lt;strong>流量路由&lt;/strong>的方案大致如下：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/2.png" alt="image">&lt;/p>
&lt;p>具体流程：&lt;/p>
&lt;ol>
&lt;li>增加一个 &lt;strong>xDS Router MW&lt;/strong> 来负责 Pick Cluster（路由），并 watch 目标服务的 LDS 及 RDS。&lt;/li>
&lt;li>感知 LDS 变化，并提取目标服务的 LDS 中的 Filter Chain 及其 inline RDS。&lt;/li>
&lt;li>感知 RDS 变化，根据 &lt;strong>&lt;code>VirtualHost&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>ServiceName&lt;/code>&lt;/strong> 来匹配（支持前缀、后缀、精确、通配），获取目标服务的路由配置。&lt;/li>
&lt;li>遍历处理匹配到的 RDS 中的路由规则，路由规则主要分为两部分（参考：&lt;a href="https://github.com/envoyproxy/envoy/blob/v1.13.1/api/envoy/api/v2/route/route_components.proto#L349">路由规范定义&lt;/a>）：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Match&lt;/strong> （支持前缀、后缀、精确、通配等），目前版本我们支持以下两种即可：&lt;/p>
&lt;ul>
&lt;li>Path（必须项）：从 &lt;code>rpcinfo&lt;/code> 提取 &lt;code>Method&lt;/code> 进行匹配；&lt;/li>
&lt;li>HeaderMatcher（可选项）：从 metainfo 中提取对应元数据 KeyValue，并进行匹配。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Route：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Cluster&lt;/strong> ：标准 Cluster。&lt;/li>
&lt;li>&lt;strong>WeightedClusters（权重路由）&lt;/strong> ：MW 内根据权重来选择 cluster。&lt;/li>
&lt;li>将选择到的 Cluster 写入 &lt;code>EndpointInfo.Tag&lt;/code>，用于之后的服务发现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可以看到，流量路由其实是一个根据一定规则选择对应 SubCluster 的流程。&lt;/p>
&lt;h2 id="02-全链路泳道">02 全链路泳道&lt;/h2>
&lt;p>基于流量路由能力，我们可以延伸出很多使用场景，如：A/B 测试、金丝雀发布、蓝绿发布等等，以及本文重点：&lt;strong>全链路泳道&lt;/strong>。&lt;/p>
&lt;p>全链路泳道可以理解成是对一组服务实例按照一定方式进行拆分（例如部署环境），并基于全链路灰度路由能力，让流量能够精准按照规则在指定服务实例泳道中流动（逻辑上如同游泳场中的泳道）。&lt;/p>
&lt;p>在 Istio 中我们一般会通过 DestinationRule 的 subset 对实例进行分组，将一个服务拆分成不同子集（例如：按照版本、区域等属性拆分），然后配合 VirtualService 来定义对应的路由规则，将流量路由到对应子集中，从而完成泳道中的单跳路由能力。&lt;/p>
&lt;p>不过单单只有流量路由能力，还不足以实现&lt;strong>全链路泳道&lt;/strong>，因为当一个请求跨越多个服务的时候，我们需要有一个比较好的机制能够准确识别出该流量，并基于这个特征来为每一跳流量配置路由规则。&lt;/p>
&lt;p>如下图所示：假设我们要实现一个用户的请求能够精确灰度到 service-b 的 v1 版本。最先想到的做法可能是所有请求都带上 &lt;code>uid = 100&lt;/code> 的请求头，然后配置对应 VirtualService 来根据 header 里的 &lt;code>uid = 100&lt;/code> 匹配。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/3.png" alt="image">&lt;/p>
&lt;p>但这样的做法有几个明显的缺点：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>不够通用&lt;/strong>：以具体某个业务属性标识（如：uid）作为流量路由匹配规则，我们需要将这个业务属性手动在全链路里透传，这本身对业务侵入性较大，需要业务配合改造。并且当我们要使用其他业务属性的时候，又需要全链路业务都改造一遍，可想而知，是非常不通用的做法。&lt;/li>
&lt;li>&lt;strong>路由规则容易频繁变动，容易造成规则臃肿&lt;/strong>：以具体某个业务属性标识（如：uid）作为流量路由匹配规则，假设我们要换一个业务属性，或者给其他用户设置路由规则的时候，得去改造原有的路由规则，或者针对不同业务属性重复定义多套路由规则，很容易就会造成路由臃肿，以至于难以维护。&lt;/li>
&lt;/ol>
&lt;p>因此，要实现全链路的流量路由统一，我们还需要额外借助一个更通用的&lt;strong>流量染色&lt;/strong>与&lt;strong>染色标识全链路透传&lt;/strong>能力。&lt;/p>
&lt;h3 id="流量染色">流量染色&lt;/h3>
&lt;blockquote>
&lt;p>流量染色是指对请求流量打上特殊标识，并在整个请求链路中携带这个标识，而所谓的全链路泳道，就是整个链路基于统一的灰度流量染色标识来设置流量路由规则，使得流量能够精准控制在不同泳道中。&lt;/p>
&lt;/blockquote>
&lt;p>通常我们会在网关层进行流量染色，通常会根据原始请求中的元数据，来进行一定规则（条件、比例）转换成对应的染色标识。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>按条件染色&lt;/strong>：当请求元数据满足一定条件之后，就给当前请求打上染色标识，如：请求头中 &lt;code>uid = 100&lt;/code>、cookie 匹配等等。&lt;/li>
&lt;li>&lt;strong>按比例染色&lt;/strong>：按照一定比例，给请求打上染色标识。&lt;/li>
&lt;/ul>
&lt;p>有了一套统一的流量染色机制之后，我们配置路由规则的时候，就不需要关心具体的业务属性标识了，只需要根据&lt;strong>染色标识&lt;/strong>来配置即可。&lt;/p>
&lt;p>将具体的业务属性抽象成条件染色规则，使其更通用，即使业务属性发生了变化，路由规则也无需再频繁变动了。&lt;/p>
&lt;h3 id="染色标识全链路透传">染色标识全链路透传&lt;/h3>
&lt;blockquote>
&lt;p>染色标识通常会依靠 Tracing Baggage 来透传，Baggage 是用于在整个链路中传递业务自定义 KV 属性，例如传递流量染色标识、传递 AccountID 等业务标识等等。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/4.png" alt="image">&lt;/p>
&lt;p>要实现流量染色标识在全链路透传，我们通常会借助 Tracing Baggage 机制，在全链路中传递对应染色标识，大部分 Tracing 框架都支持 Baggage 概念机能力，如：OpenTelemetry、Skywalking、Jaeger 等等。&lt;/p>
&lt;p>有了一套通用的全链路透传机制，业务方就只需要接入一遍 tracing 即可，无需每次业务属性标识发生变化就配合改造一次。&lt;/p>
&lt;p>下面会借助一个&lt;strong>具体的工程案例&lt;/strong>介绍，来介绍并演示如何基于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Proxyless 和 OpenTelemetry Baggage 实现全链路泳道功能。&lt;/p>
&lt;h2 id="03-案例介绍bookinfo">03 案例介绍：Bookinfo&lt;/h2>
&lt;blockquote>
&lt;p>该案例是使用 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>、&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 重写经典的 &lt;a href="https://istio.io/latest/zh/docs/examples/bookinfo/">Istio Bookinfo&lt;/a> 项目：&lt;/p>
&lt;ul>
&lt;li>使用 istiod 来作为 &lt;strong>xDS server&lt;/strong>，作为 CRD 配置和下发的入口；&lt;/li>
&lt;li>使用 wire 来实现&lt;strong>依赖注入&lt;/strong>；&lt;/li>
&lt;li>使用 opentelemetry 来实现&lt;strong>全链路追踪&lt;/strong>；&lt;/li>
&lt;li>使用 &lt;a href="https://github.com/kitex-contrib/xds">Kitex-xds&lt;/a> 和 opentelemetry baggage 来实现 &lt;strong>proxyless&lt;/strong> 模式下的全链路泳道;&lt;/li>
&lt;li>使用 arco-design 和 react 实现一个 &lt;strong>&lt;a href="https://github.com/cloudwego/biz-demo/blob/main/bookinfo/README_CN.md">Bookinfo&lt;/a> UI&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="架构">架构&lt;/h3>
&lt;p>整体架构与 &lt;a href="https://github.com/cloudwego/biz-demo/blob/main/bookinfo/README_CN.md">Bookinfo&lt;/a> 保持一致，分为四个单独的微服务：&lt;/p>
&lt;ul>
&lt;li>&lt;code>productpage.&lt;/code> 这个微服务会调 &lt;code>details&lt;/code> 和 &lt;code>reviews&lt;/code> 两个微服务；&lt;/li>
&lt;li>&lt;code>details.&lt;/code> 这个微服务中包含了书籍的信息；&lt;/li>
&lt;li>&lt;code>reviews.&lt;/code> 这个微服务中包含了书籍相关的评论。它还会调用 &lt;code>ratings&lt;/code> 微服务；&lt;/li>
&lt;li>&lt;code>ratings.&lt;/code> 这个微服务中包含了由书籍评价组成的评级信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>reviews&lt;/code> 微服务有 3 个版本：&lt;/p>
&lt;ul>
&lt;li>v1 版本会调用 &lt;code>ratings&lt;/code> 服务，并使用 1 颗 ⭐️ 显示评分；&lt;/li>
&lt;li>v2 版本会调用 &lt;code>ratings&lt;/code> 服务，并使用 5 颗 ⭐️⭐️⭐️⭐️⭐️⭐️ 显示评分；&lt;/li>
&lt;li>v3 版本不会调用 &lt;code>ratings&lt;/code> 服务。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/5.png" alt="image">&lt;/p>
&lt;h3 id="泳道示意图">泳道示意图&lt;/h3>
&lt;p>整体区分成 2 个泳道：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>基准泳道&lt;/strong>：未被染色的流量会被路由到基准泳道中。&lt;/li>
&lt;li>&lt;strong>分支泳道&lt;/strong>：被染色的流量会被路由到 reviews-v2 -&amp;gt;ratings-v2 的分支泳道中。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/6.png" alt="image">&lt;/p>
&lt;h3 id="流量染色-1">流量染色&lt;/h3>
&lt;p>网关统一负责对流量进行染色，例如请求 header 中 uid=100 的流量都统一进行染色，为请求携带上 &lt;code>env=dev&lt;/code> 的 &lt;strong>baggage&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/7.png" alt="image">&lt;/p>
&lt;p>染色方式可以根据不同的网关实现具体选择，例如当我们选择 istio ingress 作为网关的时候，我们可以借助 &lt;code>EnvoyFilter&lt;/code> + &lt;code>Lua&lt;/code> 的方式来编写网关染色规则。&lt;/p>
&lt;h3 id="为服务实例打标">为服务实例打标&lt;/h3>
&lt;ol>
&lt;li>为对应 &lt;strong>workload&lt;/strong> 打上对应 version 标识。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>以 reviews 为例，只需要给对应 pod 打上 version: v1 的 label 即可。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/8.png" alt="image">&lt;/p>
&lt;ol start="2">
&lt;li>基于 &lt;strong>DestinationRule&lt;/strong> 为服务设置一系列的 subsets：&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;ul>
&lt;li>Productpage: v1&lt;/li>
&lt;li>Reviews: v1、v2、v3&lt;/li>
&lt;li>Ratings: v1、v2&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/9.png" alt="image">&lt;/p>
&lt;h3 id="流量路由规则">流量路由规则&lt;/h3>
&lt;p>网关已经将请求头中携带了 &lt;code>uid=100&lt;/code> 的流量进行了染色，自动带上了 &lt;code>env=dev&lt;/code> 的 baggage，因此我们只需要根据 header 进行路由匹配即可，下面是具体的路由规则配置示例：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/10.png" alt="image">&lt;/p>
&lt;h3 id="查看效果">查看效果&lt;/h3>
&lt;h4 id="基准泳道">基准泳道&lt;/h4>
&lt;p>入口流量请求头中不带 &lt;code>uid=100&lt;/code> 的请求，会自动路由到基准泳道服务，reviews v1 和 v3 服务间轮询，展示的效果是评分为 0 或 1 随机。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/11.png" alt="image">&lt;/p>
&lt;h4 id="分支泳道">分支泳道&lt;/h4>
&lt;ol>
&lt;li>我们这边通过浏览器 mod-header 插件，来模拟入口流量请求头中携带了 &lt;code>uid=100&lt;/code> 的场景。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/12.png" alt="image">&lt;/p>
&lt;ol start="2">
&lt;li>再点击刷新按钮，可以发现请求打到了分支泳道，流量泳道功能成功生效。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Kitex_Proxyless/13.png" alt="image">&lt;/p>
&lt;h2 id="04-总结与展望">04 总结与展望&lt;/h2>
&lt;p>至此我们已经基于 &lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Proxyless&lt;/strong> 与 &lt;strong>OpenTelemetry&lt;/strong> 实现了一个完整的全链路泳道，并且无需借助 Envoy sidecar，就能基于 Isito 标准治理规则 Spec，来为 Kitex 设置对应的路由规则了。&lt;/p>
&lt;p>当然，除了满足&lt;strong>流量路由&lt;/strong>能力之外，&lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Proxyless&lt;/strong> 也在持续迭代优化，满足更多数据面治理能力需求。Proxyless 作为一种 ServiceMesh 数据面探索和实践，除了能够丰富网格数据面部署形态之外，也希望可以不断打磨 &lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>&lt;/strong>，增强其在开源生态兼容方面的能力，打造一个开放包容的微服务生态体系。&lt;/p>
&lt;h2 id="05-相关项目链接">05 相关项目链接&lt;/h2>
&lt;p>下面是该案例涉及的项目清单：&lt;/p>
&lt;ul>
&lt;li>biz-demo: &lt;a href="https://github.com/cloudwego/biz-demo">https://github.com/cloudwego/biz-demo&lt;/a>&lt;/li>
&lt;li>kitex: &lt;a href="https://github.com/cloudwego/kitex">https://github.com/cloudwego/kitex&lt;/a>&lt;/li>
&lt;li>hertz: &lt;a href="https://github.com/cloudwego/hertz">https://github.com/cloudwego/hertz&lt;/a>&lt;/li>
&lt;li>kitex-xds: &lt;a href="https://github.com/kitex-contrib/xds">https://github.com/kitex-contrib/xds&lt;/a>&lt;/li>
&lt;li>kitex-opentelemetry: &lt;a href="https://github.com/kitex-contrib/obs-opentelemetry">https://github.com/kitex-contrib/obs-opentelemetry&lt;/a>&lt;/li>
&lt;li>hertz-opentelemetry: &lt;a href="https://github.com/hertz-contrib/obs-opentelemetry">https://github.com/hertz-contrib/obs-opentelemetry&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>该完整案例已提交在 &lt;a href="https://github.com/cloudwego/biz-demo">biz-demo&lt;/a> 仓库中，感兴趣的同学可以前往查阅。&lt;a href="https://github.com/cloudwego/biz-demo">biz-demo&lt;/a> 会包含一些基于 &lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a> 技术栈且具备一定业务场景的完整 Demo，初衷是能够为企业用户在生产中使用提供有价值的参考，非常欢迎更多同学能够参与到 &lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a> 相关场景与案例的贡献中来，一起来做一些有意思的尝试。&lt;/p></description></item><item><title>Blog: Kitex v0.4.3 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/11/02/kitex-v0.4.3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Wed, 02 Nov 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/11/02/kitex-v0.4.3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="重要变更介绍">重要变更介绍&lt;/h2>
&lt;h3 id="功能">功能&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>扩展 client/server 生成模板&lt;/strong> ：新增 client/server 模板扩展功能，可以通过配置定制，适用于统一定制 suite 场景，详见&lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/code-gen/template_extension/">扩展 Service 代码生成模板&lt;/a>。&lt;/li>
&lt;li>&lt;strong>业务异常&lt;/strong> ：新增业务自定义异常支持，可区分于 RPC 异常返回 error，使用详见&lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/basic-feature/bizstatuserr/">业务异常&lt;/a>，背景详见&lt;a href="https://github.com/cloudwego/kitex/issues/511">Proposal&lt;/a>。&lt;/li>
&lt;li>&lt;strong>请求 Profiler&lt;/strong> ：新增功能可用于为不同的 RPC 请求提供成本分析统计的能力。&lt;/li>
&lt;li>&lt;strong>Context Middleware&lt;/strong> : 新增 Context Middleware，用于请求粒度添加 Middleware。&lt;/li>
&lt;/ol>
&lt;h3 id="优化">优化&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>Frugal 性能优化&lt;/strong> ：支持在创建 Client/Server 阶段进行 Frugal “预编译”，减少动态编译对延迟的影响。&lt;/li>
&lt;li>&lt;strong>连接池优化&lt;/strong> ：重构连接池，完善空闲连接清理能力。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="详细变更">详细变更&lt;/h2>
&lt;h3 id="feature">Feature&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/691">#691&lt;/a>] feat(client): 为 Client 添加上下文中间件，用于请求粒度添加中间件。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/649">#649&lt;/a>] feat(connpool): 长连接池的新实现，支持最小空闲连接数及空闲连接清理。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/672">#672&lt;/a>] feat(grpc): 为 kitex grpc 添加了元信息传递相关 api，包括 header，tailer，以及 peer 远端地址的获取接口。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/613">#613&lt;/a>] feat(exception): 支持用户自定义异常用以区分 RPC 异常。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/670">#670&lt;/a>] feat(exception): 支持 DetailError 格式化。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/678">#678&lt;/a>] feat(tool): 为 kitex cmd 添加 git 和 record 参数。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/662">#662&lt;/a>] feat(tool): 支持在创建 client 或者 server 的时候进行 frugal “预编译” (pretouch)。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/657">#657&lt;/a>] feat(tool): 支持模板拓展。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/527">#527&lt;/a>] feat(profiler): 为不同的 RPC 请求提供成本分析统计的能力。&lt;/li>
&lt;/ul>
&lt;h3 id="optimize">Optimize&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/690">#690&lt;/a>] optimize(meta): 移除 #503 添加 default metahandler 的错误逻辑。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/638">#638&lt;/a>] optimize(generic): httppb 泛化支持 map/list 元素类型为 struct。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/641">#641&lt;/a>] optimize(tool): 给 oneway 方法增加警告注释。&lt;/li>
&lt;/ul>
&lt;h3 id="fix">Fix&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/611">#611&lt;/a>] fix(client): 在频繁重复创建 Client 场景下，修复由于 finalizer 未触发执行导致的资源泄漏。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/698">#698&lt;/a>] fix(connpool): 根据 Get 返回的连接数减少值来调整 globalIdle。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/636">#636&lt;/a>] fix(connpool): 修复当连接池在 &lt;code>ForwardProxy&lt;/code> 实现中被重置后，连接池的 CloseCallback、统计上报失效的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/647">#647&lt;/a>] fix(grpc): 修复 grpc 连接级别窗口初始化时没有通知对端的问题，并同步了 grpc pr #5459。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/639">#639&lt;/a>] fix(generic): 泛化调用支持 list&lt;byte> 类型，map 读泛化增加 forJSON 选项。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/655">#655&lt;/a>] fix(generic): 数值型常量作为泛化默认值时无法被正确解析。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/654">#654&lt;/a>] fix(frugal): 修复较低版本 go 编译失败的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/682">#682&lt;/a>] fix(profiler): 修复 profiler 停止 pprof profile 采集的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/637">#637&lt;/a>] fix(tool): 修复 handler.go 模板里的 imports。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/630">#630&lt;/a>] fix(tool): 对于没有声明 “service” 的 pb 文件，去掉生成文件末尾冗余的 kitex 声明。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/627">#627&lt;/a>] fix(tool): 修复当一个 import 拥有不同的别名时 import 会丢失的问题。&lt;/li>
&lt;/ul>
&lt;h3 id="refactor">Refactor&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/651">#651&lt;/a>] refactor(server): 重构 server trans handler 的 read/write 接口，返回新的 context。&lt;/li>
&lt;/ul>
&lt;h3 id="docs">Docs&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/656">#656&lt;/a>] docs: 删除 CONTRIBUTING 文档中的错误信息。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/683">#683&lt;/a>] docs(kerrors): 修改了 kerrors WithCauseAndExtraMsg 方法注释。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/625">#625&lt;/a>] chore: 修正 pull request 模板的语法问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/623">#623&lt;/a>] chore: 修改 pull request 模板。&lt;/li>
&lt;/ul>
&lt;h3 id="test--ci">Test &amp;amp; CI&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/646">#646&lt;/a>] test: 修复 InitRPCInfoFunc 未设置 rpcinfo 导致的单测失败。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/680">#680&lt;/a>] test: 修复重试单测的 race 问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/661">#661&lt;/a>] test: 增强 wpool 测试稳定性。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/643">#643&lt;/a>] test: 为 detection server handler 添加测试。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/632">#632&lt;/a>] test: 用 gomock 自动生成类替换手动编写的 mock 类。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/697">#697&lt;/a>] chore(ci): 固定 skywalking-eyes 版本号。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/652">#652&lt;/a>] chore(ci): 删除重复的测试，以减少单测所花费的时间。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/588">#588&lt;/a>] chore(ci): 支持 codecov。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.4.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/10/28/hertz-v0.4.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/10/28/hertz-v0.4.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/289">#289&lt;/a>] feat: render 支持 IndentedJSON。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/304">#304&lt;/a>] feat: recovery 中间件支持用户自定义错误输出格式。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/278">#278&lt;/a>] feat: 增加编译 tag 控制实际使用的 json 库。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/239">#239&lt;/a>] feat: 给 client 扩展复杂重试能力。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/265">#265&lt;/a>] feat: 在标准网络库扩展上添加 CloseNoResetBuffer 方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/258">#258&lt;/a>] feat: 支持 &lt;code>errors&lt;/code> 的格式化。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/295">#295&lt;/a>] optimize: 服务端忽略客户端主动断连的写错误。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/322">#322&lt;/a>] optimize: 修改 recovery 中间件的默认日志。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/266">#266&lt;/a>] optimize(hlog): 区分系统日志和默认日志，提供更自由的 logger 定制化能力。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/280">#280&lt;/a>] optimize: 使用标准库时 listen 前添加日志。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/318">#318&lt;/a>] refactor: 添加 SetRetryIf 保持兼容。&lt;/li>
&lt;/ul>
&lt;h2 id="test">Test&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/299">#299&lt;/a>] test: 提高对 &lt;code>hertz/pkg/protocol/header&lt;/code> 的单测覆盖率。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/290">#290&lt;/a>] test: 为 &lt;code>pkg/app/server/option.go&lt;/code> 补充单元测试。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/274">#274&lt;/a>] test: 增加 internal/bytesconv 包测试覆盖率，覆盖率从 1.68% 提高到了 82.35%。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/285">#285&lt;/a>] test: 给 &lt;code>pkg/protocol/request.go&lt;/code> 文件单测覆盖率 51.31% 提高到 85.3%。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/271">#271&lt;/a>] test: 为 &lt;code>pkg/network&lt;/code> 补充单元测试。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/264">#264&lt;/a>] test: 增加对 &lt;code>hertz/pkg/common/adaptor&lt;/code> 的单测，覆盖率从 76.6% 提高到了 92.3%。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/267">#267&lt;/a>] test(pkg/common/config): 增加 pkg/common/config 包测试覆盖率。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/328">#328&lt;/a>] docs: 添加 lark 扩展到 readme.md。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/325">#325&lt;/a>] docs: 更新 README 和 README_cn 的性能数据。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/307">#307&lt;/a>] docs(README): 将 Hertz 扩展添加到 readme 列表中。&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/316">#316&lt;/a>] style: 去掉 license 顶层的空注释。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/272">#272&lt;/a>] chore: 更新 sonic 版本。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/310">#310&lt;/a>] chore: 修改注释信息为行注释避免 buildtag 格式问题的导致 ci 报错。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Volo v0.2.1 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/10/26/volo-v0.2.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/10/26/volo-v0.2.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/61">#61&lt;/a>] 优化了 Volo-Thrift 的代码，移除了一些不必要的泛型参数，简化代码。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/63">#63&lt;/a>] 跟进了 2022-10-20 后 nightly 编译器不再允许 TAIT elition lifetime 的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/73">#73&lt;/a>] 绕过了 Rust 编译器的 #100013 issue: non-defining opaque type use in defining scope。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/65">#65&lt;/a>] feat: 升级 Volo-cli 的 clap 版本到 4.x。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/72">#72&lt;/a>] feat: 为 volo::net::Conn 支持了 writev 操作。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Volo v0.2.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/10/18/volo-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 18 Oct 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/10/18/volo-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/31">#31&lt;/a>] 支持 Windows。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/26">#26&lt;/a>] volo-grpc 增加对 service discovery 和 load balance 的支持。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/45">#45&lt;/a>] volo-grpc 支持 uds。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/32">#32&lt;/a>] volo-grpc 支持 metainfo 进行元信息传递。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/30">#30&lt;/a>] volo-grpc Server 增加 &lt;code>layer_front&lt;/code> 方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/42">#42&lt;/a>] volo-thrift 支持 multiplex。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/53">#53&lt;/a>] 优化 &lt;code>write_field_begin&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/34">#34&lt;/a>] 修复连接超时设置。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/46">#46&lt;/a>] 增加对可重试错误的判断。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/volo/pull/33">#33&lt;/a>] volo-grpc 修复对 Error 类型的约束。&lt;/li>
&lt;/ul></description></item><item><title>Blog: 助力字节降本增效，大规模企业级 HTTP 框架 Hertz 设计实践</title><link>https://www.cloudwego.io/zh/blog/2022/09/27/%E5%8A%A9%E5%8A%9B%E5%AD%97%E8%8A%82%E9%99%8D%E6%9C%AC%E5%A2%9E%E6%95%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BC%81%E4%B8%9A%E7%BA%A7-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 27 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/27/%E5%8A%A9%E5%8A%9B%E5%AD%97%E8%8A%82%E9%99%8D%E6%9C%AC%E5%A2%9E%E6%95%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E4%BC%81%E4%B8%9A%E7%BA%A7-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="字节跳动内部-go-http-框架的变迁">字节跳动内部 Go HTTP 框架的变迁&lt;/h2>
&lt;p>在正式开始介绍第一部分的内容之前，先展示一组关键词。2020 年初 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 立项，2020 年 10 月，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 发布&lt;strong>第一个可用版本&lt;/strong> 。
&lt;strong>2022 年 6 月，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 正式开源。&lt;/strong> 截至目前，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在字节内部已经支撑&lt;strong>超过 1.4 万个业务服务&lt;/strong> ， &lt;strong>日峰值 QPS 超过 5000 万&lt;/strong> 。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 不仅支持业务服务，同时还会横向支持字节内部的各种基础组件，包括但不限于字节跳动服务网格控制面、公司级别压测平台以及 FaaS，还包括各种业务网关等等。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的高性能和极强的稳定性可以支撑业务复杂多变的场景。在公司内部 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 接替了大量基于 Gin 框架开发的存量服务，大幅度降低了业务资源使用成本以及服务延时，助力公司层面的降本增效。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/1.png" alt="image">&lt;/p>
&lt;p>下面我们可以从 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 出现的背景以及 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的设计目标和思路体会到，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的出现绝不是偶然。&lt;/p>
&lt;h3 id="基于-gin-封装">基于 Gin 封装&lt;/h3>
&lt;p>众所周知，字节内部使用 Golang 比较早，在大约 2014 年左右，公司就已经开始尝试做一些 Golang 业务的转型。2016 年，我们基于已开源的 Golang HTTP 框架 Gin 框架，封装了 Ginex，这是 Ginex 刚开始出现的时期。&lt;/p>
&lt;p>同时，2016 年还是一个开荒的时代，这个时期框架伴随着业务快速野蛮地生长，我们的口号是“大力出奇迹”，把优先解决业务需求作为第一要务。Ginex 的迭代方式是业务侧和框架侧在同一个仓库里面共同维护和迭代。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/2.png" alt="image">&lt;/p>
&lt;h3 id="问题显现">问题显现&lt;/h3>
&lt;p>2017 - 2019 年期间，也就是 Ginex 发布之后，问题逐渐显现。主要有以下几点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>迭代受开源项目限制&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Ginex 是一个基于 Gin 的开源封装，所以它本身在迭代方面是受到一些限制的。一旦有针对公司级的需求开发，以及 Bugfix 等等，我们都需要和开源框架 Gin 做联合开发和维护，这个周期不能完全由我们自己控制。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代码混乱膨胀、维护困难&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>由于我们和业务同学共同开发和维护 Ginex 框架，因此我们对于控制整个框架的走向没有完全的自主权，从而导致了整体代码混乱膨胀，到后期我们发现越来越难维护。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无法满足性能敏感业务需求&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>另外，我们能用 Gin 做的性能优化非常少，因为 Gin 的底层是基于 Golang 的一个原生库，所以如果我们要做优化，需要在原生库的基础上做很多改造，这个其实是非常困难的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>无法满足不同场景的功能需求&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们内部逐渐出现了一些新的场景，因此会有对 HTTP Client 的需求，支持 Websocket、支持 HTTP/2 以及支持 HTTP/3 等等需求，而在原生的 Ginex 上还是很难扩展的这些功能需求。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/3.png" alt="image">&lt;/p>
&lt;h3 id="魔改开源框架">魔改开源框架&lt;/h3>
&lt;p>逐渐地，某些业务线开始做初步的尝试，他们会对另外的一些开源框架进行魔改。比较典型的例子是有一些业务线尝试基于 Fasthttp 进行魔改，Fasthttp 是一款主打高性能的开源框架，基于它进行魔改可以短期内帮助业务解决问题。
这种魔改现象带来的问题是，框架魔改是一些业务线自发的行为，各个业务线可能会基于自身业务特性进行各自维护，从而导致维护成本上升非常严重。&lt;/p>
&lt;p>到这里我们仿佛陷入了 Ginex 的怪圈。如前段时间爆火的电视剧《开端》一样，我们仿佛是从一辆开往学院南路的 45 路公交车上醒来，发现自己要前往公司进行下一代 Ginex 框架的维护工作。&lt;/p>
&lt;p>大家也可以思考一下，如果是你来应对这样的场景，你会怎么做呢？&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/4.png" alt="image">&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>第一章节的内容总结如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>早期基于开源框架封装&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>基于早期开源的 Golang HTTP 框架，实现了 Ginex 的封装。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>随着实践发展，问题逐渐出现&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>框架混乱膨胀，框架的维护越来越困难，业务的新需求无法得到很好地满足。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>为了解决问题出现基于另外的开源框架魔改的萌芽&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们需要思考如何跳出魔改的怪圈，把字节内部的企业级框架做得更好。&lt;/p>
&lt;p>另外，还有一个遗留问题，就是应该如何跳出这个魔改的怪圈呢？这个问题第二章节会为大家进行解答。&lt;/p>
&lt;h2 id="企业级-http-框架的设计考量和落地思路">企业级 HTTP 框架的设计考量和落地思路&lt;/h2>
&lt;h3 id="跳出怪圈">跳出怪圈&lt;/h3>
&lt;p>为了跳出魔改的怪圈，我们决定从以下三个方面开始着手。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自主研发&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>既然 Ginex 是因为基于开源框架 Gin，没法做一些灵活的控制，那我们就改为完全自主研发框架。自主研发框架的代码全链路自主可控，也可以避免引入任何三方不可控因素，这样我们能够对自己的框架有一个比较完备的掌控力。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>质量控制&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>下图列举了一些常规的质量控制手段。我要着重强调的是模糊测试，模糊测试在字节内部是广泛应用于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架的稳定性测试中。它的核心点在于 &lt;strong>通过一系列的模拟服务，尝试模拟出线上用户在使用我们的框架时，
实际遇到的一些场景和使用方式&lt;/strong> 。然后通过一些随机的算法，生成尽可能复杂、覆盖各种 Case 的场景，这可以让我们 &lt;strong>检测出一些潜在的问题&lt;/strong> 。这套测试也在 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 早期的质量建设中，帮助我们将一些问题防患于未然。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>严格准入&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>既然 Ginex 的问题是大家都在向里面写入内容，那么我们可以控制入口，建立一套完备的需求开发以及 Review 的闭环，控制迭代的整体流程，从而控制代码准入。同时我们配备统一的需求管理以及严格的发版准入规范，做一个标准的公司级别的框架。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/5.png" alt="image">&lt;/p>
&lt;p>举一个比较形象的例子，如果我们把下一代框架比作一个人——“框架人”，自主研发表示这个“框架人”首先会拥有对自己身体的主导权，他不会受到来自于环境或者他人的影响；
质量控制表示“框架人”能够定期体检，提早发现一些潜在的疾病，将其扼杀于摇篮；严格准入表示“框架人”有科学的饮食摄入和自律的生活习惯。可想而知，如果我们能够做到以上三点，我们的“框架人”就能够拥有一个健康的体魄。&lt;/p>
&lt;h3 id="痛点梳理">痛点梳理&lt;/h3>
&lt;p>明确了应该如何跳出怪圈之后，我们还应该明确知道这个框架要具备哪些功能和特性，也就是首先应该聚焦到框架的核心痛点上。“框架人”不能只有健康的体魄，还应该拥有有趣的思想和灵魂。
一个成熟的框架不仅仅要&lt;strong>应对来自业务侧的需求&lt;/strong> ，如功能需求、性能需求和易用稳定等，还要考虑&lt;strong>框架自身的发展&lt;/strong> ，而这一点恰恰是我们在 Ginex 的迭代过程中忽略的。&lt;/p>
&lt;p>如下图右侧金字塔所示，最上层是&lt;strong>高效支撑&lt;/strong> ，毋庸置疑框架的存在肯定是为了支撑我们的业务需求。中间层是一个&lt;strong>质量保证&lt;/strong>的红线框架，框架需要保证它自身的质量，
只有以高质量完成的框架才能有自信承担字节内部的 5000 万 QPS，以及各种各样的使用场景。金字塔的最底层是&lt;strong>长期、可持续性发展&lt;/strong> ，这也是作为未来想要保持持续迭代的框架最重要的一点。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/6.png" alt="image">&lt;/p>
&lt;h3 id="框架科学发展观">框架科学发展观&lt;/h3>
&lt;p>基于上一部分，我们可以进一步梳理出框架的需求痛点。&lt;strong>痛点&lt;/strong>主要有两个方面：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>多样的需求&lt;/strong>：支撑支撑各个业务线及基础设施 （横向扩展性）。&lt;/li>
&lt;li>&lt;strong>灵活的结构&lt;/strong>：贯穿 HTTP 生命周期的掌控力 （纵向模块化）。&lt;/li>
&lt;/ul>
&lt;p>在此基础上进一步抽象出框架的 &lt;strong>科学发展观&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>聚类需求&lt;/strong>：面向通用能力展开设计。&lt;/li>
&lt;li>&lt;strong>跳出局部&lt;/strong>：针对一些复杂问题，在更大范围内寻求最优解。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/7.png" alt="image">&lt;/p>
&lt;p>后续我会针对这个科学发展观进一步阐述 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 究竟是如何实现的。&lt;/p>
&lt;h3 id="小结-1">小结&lt;/h3>
&lt;p>第二章节的内容总结如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>跳出怪圈&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>引入“框架人”的概念，帮助大家理解框架的自研、质量控制和严格准入。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>痛点梳理&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>为“框架人”注入有趣的灵魂，框架需要应对来自业务侧的多样化需求，还要保证自己的可持续性发展。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>框架科学发展观&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>需求聚类，跳出局部。&lt;/p>
&lt;h2 id="hertz-的核心特点">Hertz 的核心特点&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架是如何实现第二章节中提到的框架痛点和科学发展观的呢？本章节将具体进行介绍。&lt;/p>
&lt;h3 id="分层抽象">分层抽象&lt;/h3>
&lt;p>首先介绍 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架的架构设计。下图是一个请求从建立、连接到完成的全过程。&lt;strong>左侧是客户端，右侧是服务端&lt;/strong> ，在我们发起链接建立请求之后，链接建立完成；
之后客户端发起请求到服务端，服务端进行路由处理，然后将路由导向业务逻辑处理；业务逻辑处理完毕后，服务端返回这个请求，完成一次 HTTP 请求的调用。&lt;/p>
&lt;p>那么在这个过程中我们的框架到底做了哪些事情呢？从图中不难发现，首先框架进行了&lt;strong>链接处理&lt;/strong> ，其次是&lt;strong>协议处理&lt;/strong> ，之后基于路由做了逻辑分发，
即&lt;strong>路由处理&lt;/strong> ，最后做了&lt;strong>业务逻辑处理&lt;/strong> 。我们把框架做成一个结构之后会发现，这个结构包含的就是这四部分。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/8.png" alt="image">&lt;/p>
&lt;p>基于这个逻辑，我们可以看一下 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的整体架构图。如下图所示，从下往上看红线框圈住的部分，可以发现这就是上文提到的请求建立的全过程。各层的能力及作用如下：&lt;/p>
&lt;ul>
&lt;li>传输层 Transport：抽象网络接口；&lt;/li>
&lt;li>协议层 Protocol：解析请求，渲染响应编码；&lt;/li>
&lt;li>路由层 Route：基于URL进行逻辑分发；&lt;/li>
&lt;li>应用层 Application：业务直接交互，出现大量 API。&lt;/li>
&lt;/ul>
&lt;p>我们可以看到图中除了中间部分包含的四层，左右两侧各有两列。&lt;strong>右侧是通用层 Common&lt;/strong> ，主要负责&lt;strong>提供通用能力、常用的日志接口、链路追踪以及一些配置处理相关的能力&lt;/strong>等。
&lt;strong>左侧是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的代码生成工具 Hz，又称脚手架工具&lt;/strong> ，它可以帮助我们在内部 &lt;strong>基于 IDL 快速地生成项目骨架&lt;/strong> ，以加速业务迭代。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/9.png" alt="image">&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的分层设计是能够和代码组织结构一一映射的。下图是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 仓库里面的代码组织结构，可以看到根目录下的 cmd 包里面存放着 Hz 工具，
在 pkg 包下存放着上述主要四层以及通用层 Common。因此同学们看到架构设计图之后，可以直接在 Github 学习 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的代码。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/10.png" alt="image">&lt;/p>
&lt;p>总体来说，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的架构设计理念就是 &lt;strong>“简洁有序，保证让所有开发者轻松理解，在开发的过程中持续贯彻”&lt;/strong> 。&lt;/p>
&lt;h3 id="易用可扩展">易用可扩展&lt;/h3>
&lt;p>那么基于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的架构设计，应该如何展开易用性和可扩展性呢？下图是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 架构主要四个层级的抽象。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>应用层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>应用层提供了一些通用能力，包括&lt;strong>绑定请求、响应渲染、服务发现/注册/负载均衡以及服务治理&lt;/strong>等等。其中，&lt;strong>洋葱模型中间件&lt;/strong>的核心目的是让业务开发同学&lt;strong>基于这个中间件快速地给业务逻辑进行扩展&lt;/strong>，
扩展方式是可以在业务逻辑处理前和处理后分别插桩埋点做相应处理。一些比较有代表性的应用，包括日志打点、前置的安全检测，都是通过洋葱模型中间件进行处理的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>路由层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>路由层也是非常通用的，主要提供&lt;strong>静态路由、参数路由、为路由配置优先级以及路由修复&lt;/strong>的能力，如果我们的路由层没办法满足用户需求，
它还能支撑用户做&lt;strong>自定义路由&lt;/strong>的扩展。但实际应用中这些路由能力完全能够满足绝大多数用户的需求。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>协议层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 同时提供 &lt;strong>HTTP/1.1&lt;/strong> 和 &lt;strong>HTTP/2&lt;/strong>，&lt;strong>HTTP/3&lt;/strong> 也是我们在建设中的能力，我们还会提供 &lt;strong>Websocket 等 HTTP 相关的多协议支持&lt;/strong> ，以及支持完全由业务决定的&lt;strong>自定义协议层扩展&lt;/strong> 。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>传输层&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>目前我们已经内置了两个高性能的传输层实现。一个是&lt;strong>基于 CloudWeGo 开源的高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>&lt;/strong> 的传输层扩展，另一个是支持&lt;strong>基于标准库&lt;/strong>的传输层扩展。此外，我们也同样能支持在传输层上进行&lt;strong>自定义传输层协议扩展&lt;/strong> 。&lt;/p>
&lt;p>下图每一层中标红的能力都能够体现出，我们能够在框架的任何一个分层上支撑用户做最大程度的自由定制，这样可以最大程度地满足企业级内部用户和潜在用户的业务需求。
如果同学们想要深入了解 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，可以参考 CloudWeGo 官网的 &lt;a href="https://www.cloudwego.io/zh/docs/hertz/">Hertz&lt;/a> 部分，上述所有内容均有具体描述。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/11.png" alt="image">&lt;/p>
&lt;h3 id="性能探索">性能探索&lt;/h3>
&lt;p>在性能方面，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 又是如何在自主可控的范围内做高性能探索的呢？&lt;/p>
&lt;h4 id="场景描述">场景描述&lt;/h4>
&lt;p>熟悉 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 代码的同学会发现，我们的 &lt;strong>HTTP/1.1&lt;/strong> 协议借鉴了一些 Fasthttp 的优化思路和手段。HTTP/1.1 协议中的 Header 为不定长数据段，往往需要解析到最后一行，才能够确定是否完成解析。
同时，为了减少系统调用次数，提升整体解析效率，涉及 IO 操作时，我们通常引入带 buffer 的 IO 数据结构。如下图所示，它的核心点是最下层的 buffer，buffer 是一个类似于一块完整的内存空间，我们可以将 IO 读到的数据放进这个空间做暂存。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/12.png" alt="image">&lt;/p>
&lt;h4 id="bufioreader-的问题">bufio.Reader 的问题&lt;/h4>
&lt;p>这样做出现的问题是，原生的 bufio.Reader 长度是固定的，请求的 Header 大小超出 buffer 长度后，&lt;code>.Peek()&lt;/code> 方法直接报错 &lt;code>(ErrBufferFul)&lt;/code>，无法完成既定语义功能。&lt;/p>
&lt;h4 id="一些可能的解">一些可能的解&lt;/h4>
&lt;p>对于上述问题，其实有一些可能的解决方法：&lt;/p>
&lt;ul>
&lt;li>直接利用 bufio.Reader 的局限当做 Feature，通过 buffer 大小作为 Header 大小的限制。如果超出这个大小，Header 直接解析报错，这也是 Fasthttp 的做法。
但实际上超出 buffer 长度后报错会导致我们没办法处理这部分请求，从而导致框架 &lt;strong>功能受限&lt;/strong> 。&lt;/li>
&lt;li>header 解析带状态，暂存中间数据，通过在上层堆叠额外复杂度的方式突破 bufio 本身的限制。但是暂存中间态会涉及到一些内存的拷贝，必然会导致 &lt;strong>性能受限&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;h4 id="真实使用环境复杂多变">真实使用环境复杂多变&lt;/h4>
&lt;p>字节内部的使用场景非常多，我们不仅要支持各种业务线的开发，还要支持一些横向的基础组件。不同的业务，不同的场景，数据规模各异。
如何成为通用且高效的地解决 bufio.Reader 的问题成为 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 面临的内部重要挑战。我们既然已经站在 Fasthttp 这个“巨人”的肩膀上了，能否往前再走一步呢？&lt;/p>
&lt;p>答案是肯定的。基于内部的使用场景，同时结合 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 的优势，我们设计出了 &lt;strong>自适应 linked buffer&lt;/strong> ，并且用它替代掉了原生的 bufio.Reader。
从下图可以看到，我们的 buffer 不再是一个固定长度的 buffer，而是一条链，这条链上的每一个 buffer 大小能够&lt;strong>根据线上真实请求进行动态扩缩容调整&lt;/strong> ，同时搭配 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 中&lt;strong>基于 LT 触发的模型做数据预拷贝&lt;/strong> 。
从实施效果上来看，这个自适应调整能够让我们的业务方完全无感地支撑任何他们的业务特性。也是因为我们能够将 buffer 进行动态扩缩容调整，从而能够保证在&lt;strong>协议层最大程度做到零拷贝协议解析&lt;/strong> ，这能够带来整体解析上的性能提升，时延也会更低。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/13.png" alt="image">&lt;/p>
&lt;h4 id="针对-http11-进行中的优化">针对 HTTP/1.1 进行中的优化&lt;/h4>
&lt;p>因为目前在字节内部 HTTP/1.1 还是一个比较主流的协议，所以我们基于 HTTP/1.1 做了很多尝试。&lt;/p>
&lt;p>首先是&lt;strong>协议层探索&lt;/strong> 。我们正在尝试基于 &lt;strong>Header Passer 的重构&lt;/strong> ，把解析 Header 的流程做得更高效。我们还尝试了做一些&lt;strong>传输层预解析&lt;/strong> ，将一些比较固化的逻辑下沉到传输层做加速。&lt;/p>
&lt;p>其次是&lt;strong>传输层探索&lt;/strong> 。这包括&lt;strong>使用 writev 整合发送 Header &amp;amp; Body&lt;/strong> 达到减少系统调用次数的目的，以及通过&lt;strong>新增接口整合 &lt;code>.Peek() + .Skip()&lt;/code>&lt;/strong> 语义，在内部提供一个更高效的实现。&lt;/p>
&lt;h4 id="hertz-benchmark">Hertz Benchmark&lt;/h4>
&lt;p>下图是 Benchmark 的开源数据。左侧第一张图是在同等的机器环境上，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 和横向的框架 Gin、Fasthttp 极限 QPS 比较情况，蓝线是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 处于较高极限 QPS 的状态。
第二张图是 TP99 时延状态，第三张图是 TP999 时延状态，可以看到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的整体时延是处于一个更低的水平上。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/14.png" alt="image">&lt;/p>
&lt;h4 id="字节跳动服务网格控制面从-gin-迁移至-hertz">字节跳动服务网格控制面从 Gin 迁移至 Hertz&lt;/h4>
&lt;p>CloudWeGo 公众号曾发布关于字节跳动服务网格控制面的文章，讲述字节跳动服务网格从 Gin 框架迁移到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的落地实践。下图是他们代码展示的真实收益，从 Gin 框架替换成为 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架后，
&lt;strong>CPU 流量从大概快到 4K 降到大约只有 2.5K，Goroutine 数量从 6w 降到不足 100 个&lt;/strong> ，Goroutine 稳定性得到极大地提升。
同时替换成 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后，&lt;strong>框架相关的开销已经基本消失，服务网格在线上稳定承载了超过 13M QPS 的流量&lt;/strong> 。&lt;/p>
&lt;p>字节跳动服务网格基于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架的实践：https://mp.weixin.qq.com/s/koi9q_57Vk59YYtO9cyAFA&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_HTTP_Hertz/15.png" alt="image">&lt;/p>
&lt;h3 id="小结-2">小结&lt;/h3>
&lt;p>第三章节的内容总结如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分层抽象&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>解构 HTTP 框架，分层解耦。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易用可扩展&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>提供了更丰富 API 和足够灵活的拓展能力，在每一层抽象中都提供了一个足够灵活的扩展能力应对可能的需求。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自主可控的高性能探索&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>自适应 buffer，零拷贝解析，未来将会进行更多的高性能探索。&lt;/p>
&lt;h2 id="未来规划和挑战">未来规划和挑战&lt;/h2>
&lt;p>我认为 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 未来的发展规划主要围绕以下几个方面：首先，&lt;strong>打造泛 HTTP 框架&lt;/strong> 。我们的最终目标是希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能够解决在 HTTP 领域内的所有问题；其次，&lt;strong>助力 CloudWeGo&lt;/strong> ，希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能够助力 CloudWeGo 打造一个企业级云原生微服务矩阵；最后希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能够&lt;strong>持续服务更多的用户&lt;/strong> 。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>本次分享的主要内容总结如下：&lt;/p>
&lt;ul>
&lt;li>字节跳动内部 Go HTTP 框架的变迁：从基于开源封装，到开启自研之路；&lt;/li>
&lt;li>企业级 HTTP 框架的设计考量和落地思路：破圈、需求提炼、框架科学发展观；&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 核心特点：分层抽象、易用可扩展、自主可控的性能探索；&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 未来的规划和挑战：框架持续打磨、助力 CloudWeGo、服务更多用户。&lt;/li>
&lt;/ul>
&lt;p>最后欢迎对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 感兴趣的同学积极参与到 CloudWeGo 社区中，我们一起完善 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，共同建设 CloudWeGo！&lt;/p></description></item><item><title>Blog: Hertz v0.3.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/09/20/hertz-v0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/20/hertz-v0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/198">#198&lt;/a>] feat: 添加获取 Hertz client dialer 名称的方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/251">#251&lt;/a>] feat: Hertz server 启动日志添加网络库的名称。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/238">#238&lt;/a>] refactor: 重构 Hertz client 初始化 HostClient 和 TLSHostClient 的逻辑。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/226">#226&lt;/a>] optimize: 使用 &amp;ldquo;warning&amp;rdquo; 日志提示非法的 http 状态码。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/249">#249&lt;/a>] fix: 修复 Hertz server 优雅退出时无法执行完全部 hook 函数的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/232">#232&lt;/a>] fix: 修复路由尾斜线重定向在边缘情况失效的问题。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/217">#217&lt;/a>] chore: 更新提交 PR 时的填写模板。&lt;/li>
&lt;/ul></description></item><item><title>Blog: 高性能 RPC 框架 CloudWeGo-Kitex 内外统一的开源实践</title><link>https://www.cloudwego.io/zh/blog/2022/09/20/%E9%AB%98%E6%80%A7%E8%83%BD-rpc-%E6%A1%86%E6%9E%B6-cloudwego-kitex-%E5%86%85%E5%A4%96%E7%BB%9F%E4%B8%80%E7%9A%84%E5%BC%80%E6%BA%90%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/20/%E9%AB%98%E6%80%A7%E8%83%BD-rpc-%E6%A1%86%E6%9E%B6-cloudwego-kitex-%E5%86%85%E5%A4%96%E7%BB%9F%E4%B8%80%E7%9A%84%E5%BC%80%E6%BA%90%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="由内至外---开源过渡">由内至外 - 开源过渡&lt;/h2>
&lt;p>很多同学可能刚刚了解 CloudWeGo，先介绍一下 CloudWeGo 和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的关系。&lt;/p>
&lt;h3 id="cloudwego-和-kitex">CloudWeGo 和 Kitex&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 是 CloudWeGo 开源的第一个微服务框架，它是一个 &lt;strong>支持多协议的 Golang RPC 框架&lt;/strong> ，从网络库、序列化库到框架的实现&lt;strong>基本完全自研&lt;/strong>的。
特别地，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 gRPC 协议的支持使用了 gRPC 官方的源码，但是我们对 gRPC 的实现做了 &lt;strong>深度且定制的优化&lt;/strong> ，所以 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持的 gRPC 协议性能优于 gRPC 官方框架。
同时这也是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 与目前已经开源的、支持 gRPC 协议的其他 Golang 框架的主要差异。如果用户想使用 gRPC 又对性能有很高的要求，那么 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 框架将会是一个很不错的选择。&lt;/p>
&lt;p>继 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 开源后，今年 CloudWeGo 又陆续开源了 Golang HTTP 框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，Rust RPC 框架 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>，同时围绕这些微服务框架和微服务的一些通用能力，
我们还开源了一些高性能的基础库。关于更多 CloudWeGo 开源的子项目，可以进入 CloudWeGo &lt;a href="https://www.cloudwego.io/zh/">官网&lt;/a>详细了解。&lt;/p>
&lt;p>CloudWeGo 官网：https://www.cloudwego.io/&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/1.png" alt="image">&lt;/p>
&lt;p>根据社区同学反馈，在一些开源群里大家会讨论 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 会不会是一个字节跳动的开源 KPI 项目呢？它的稳定性、持续性能够得到保障吗？我可以负责任地讲，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 不是一个 KPI 项目，它是来自字节跳动内部大规模实践的真实项目。
在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 开源后始终保持内外统一，基于内外代码的统一我们保证了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的持续迭代。为了进一步消除大家的顾虑，下面具体介绍一下 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的诞生和开源历程。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/2.png" alt="image">&lt;/p>
&lt;h3 id="kitex-发展历史">Kitex 发展历史&lt;/h3>
&lt;p>2014 年，字节跳动开始引入 Golang。2015 年，字节跳动内部的服务化开启。在 RPC 调用的场景选择了 Thrift 协议，在内部开始支持 RPC 框架。2016 年，第一个 Golang RPC 框架 Kite 正式发布。
通常在一个公司高速发展的初期，基础能力都是为了快速支持需求落地，面对的需求场景也较单一，设计上不会有较多考量，其实这也是合理的，因为探索阶段并不完全清楚还需要支持哪些场景，过多的考虑反而会出现过度设计的问题。&lt;/p>
&lt;p>但是，随着业务场景复杂化，需求也会多样化，而且接入服务及调用量逐年增长，Kite 已经不足以支持后续的迭代，在线上服役三年多后，2019 年我们开启了新的项目 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>，2020 年初发布了正式版本，在 2020 年底字节内部已经有 1w+ 服务接入 Kitex。&lt;/p>
&lt;p>从 2014 年到 2020 年，Golang 已经是字节跳动内部主要的业务开发语言，应该是业界 Golang 应用最多的公司。我们的服务框架支持着数万个 Golang 微服务的可靠通信，
经过数量众多的微服务和海量流量的验证，我们已经有了较为成熟的微服务最佳实践，于是考虑将内部的实践开源出去丰富云原生社区的 Golang 产品体系。
在 2021年，我们以 CloudWeGo 品牌正式开源了第一个服务框架 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。截至今年 8 月，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 已经为字节跳动内部 &lt;strong>6w+&lt;/strong> 的服务提供支持， &lt;strong>峰值 QPS 达到上亿级别&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/3.png" alt="image">&lt;/p>
&lt;p>大家或许还有疑问，完整的微服务体系离不开基础的云生态，无论在公有云、私有云，都需要搭建额外的服务以很好地支持微服务的治理，比如治理平台、注册中心、配置中心、监控、链路跟踪、服务网格等，而且还存在一些定制的规范。
字节跳动自然也有完善的内部服务支持微服务体系，但这些服务短期还无法开源，那 CloudWeGo 如何内外维护一套代码，统一迭代呢？&lt;/p>
&lt;p>关于这个问题，我们看一下 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的模块划分。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的模块分为三个部分：中间是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 主干部分 &lt;strong>Kitex Core&lt;/strong> ，它定义了框架的层次结构、接口核心逻辑的实现以及接口的默认实现；
左边的 &lt;strong>Kitex Tool&lt;/strong> 则是与生成代码相关的实现，我们的生成代码工具就是编译这个包得到的，其中包括 IDL 的解析、校验、代码生成、插件支持等。
不过为了便于用户使用同时提供更友好的扩展，主要能力也做了拆分作为基础库独立开源，如 Thriftgo、Thrift-validator 插件、Fastpb；
右边的 &lt;strong>Kitex Byted&lt;/strong> 是对字节内部基础能力集成的扩展实现，我们在开始就将内部的能力作为扩展收敛到一个 package 下。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/4.png" alt="image">&lt;/p>
&lt;p>如此，我们就可以将 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Core 和 Tool 部分开源出去。我们将代码做了拆分，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的核心代码和工具部分迁移到开源库，集成内部扩展的模块作为 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的扩展保留在内部库，同时内部库封装一层壳保证内部用户可以无感知地升级。&lt;/p>
&lt;p>那么 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的开源就只是代码拆分这么简单吗？显然不是。2021 年 2 月，我们开始筹备 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的开源，虽然基于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的扩展性，我们可以与内部基础设施集成的能力解耦，但是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 仍然依赖内部的一些基础库，如果要开源必须先开源基础库的能力。
所以我们首先做了依赖库的梳理，与相关的同学合作首先开源了 &lt;strong>bytedance/gopkg&lt;/strong> 库。这个库由 CloudWeGo 与字节跳动的语言团队合作维护，里面包含也了对 Golang 标准库能力的增强，感兴趣的同学可以关注使用。&lt;/p>
&lt;p>bytedance/gopkg: &lt;a href="https://github.com/bytedance/gopkg">https://github.com/bytedance/gopkg&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/5.png" alt="image">&lt;/p>
&lt;p>在 gopkg 库开源后，我们调整代码进行开源适配。2021 年 7 月，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 正式开源，在内部发布中版本使用开源库。
但 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 毕竟支持了内部几万的微服务，我们必须要确保内部服务在这个变更后可以平滑过渡，所以在开源初我们没有对外官宣，在确认稳定性后，&lt;strong>2021 年 9 月，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 正式对外官宣开源&lt;/strong> 。&lt;/p>
&lt;p>介绍了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 诞生、开源的历程，希望能够解除外部同学关于“Kitex 会不会是一个 KPI 项目？”的顾虑。&lt;/p>
&lt;h3 id="开源的价值">开源的价值&lt;/h3>
&lt;p>第一部分的最后，简单讲一下开源能为我们带来的价值。 &lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 不是为了开源而实现的，但它的实现是面向开源的。&lt;/strong> &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 本身是一个经过内部大规模实现的项目，
我们希望 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 开源后能帮助更多用户在内部快速搭建微服务，同时开源能让我们收集更多社区和企业的反馈，也能吸引外部开发者共建，
促进 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 面向多元场景支持的演进，丰富产品能力，然后能在更多场景和企业得到落地，这是一个正向循环，互利共赢的过程。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/6.png" alt="image">&lt;/p>
&lt;h2 id="开源一年变更回顾">开源一年变更回顾&lt;/h2>
&lt;h3 id="框架的衡量指标">框架的衡量指标&lt;/h3>
&lt;p>在介绍 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 开源一年变更前，先分享一下框架的衡量指标，这是大家在选择一个框架时要考虑的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>扩展性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>如果一个框架与内部能力强耦合，就无法移植到其他平台，或框架的支持场景单一也无法进行扩展，这样的框架很难得到外部的使用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易用性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>框架的易用性体现在两个方面。第一是面向&lt;strong>业务开发者&lt;/strong> ，如果一个框架在使用过程中需要让用户关注很多框架的细节，那么对研发效率要求很高的团队可能无法接受。
第二是面向&lt;strong>框架的二次开发者&lt;/strong> ，他们需要对框架做一些定制支持，如果框架提供的扩展能力过于宽泛，扩展成本很高，或者可扩展的能力不够多，那么这个框架也是存在局限性的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能的丰富度&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>虽然基于扩展性可以对框架进行定制，但不是所有开发者都有足够的精力做定制开发，如果框架本身对各种扩展能力提供了不同选择的支持，对于开发者来说只需要根据自己的基础设施进行组合就能在自己的环境中运行。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高性能&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>前面三点是初期选择框架需要重点关注的指标，但随着服务规模和资源消耗变大，性能就成了不容忽视的问题。从长期的角度来说，选择框架的时候一定要关注性能，否则后续只能面临框架替换的问题，或者被迫对这个框架做定制维护。&lt;/p>
&lt;p>关于以上四点框架的衡量指标，虽然 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 目前还没做到最好，但是这四个要素都是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 设计和实现中一直在兼顾的，我们不会顾此失彼。&lt;/p>
&lt;h3 id="功能特性">功能特性&lt;/h3>
&lt;p>下面就几个开源一年来重要的功能特性进行介绍。&lt;/p>
&lt;h4 id="proxyless">Proxyless&lt;/h4>
&lt;p>Proxyless 是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 面向开源场景提供的支持。在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 开源初期，我们内部讨论过是否要支持 xDS 对接 &lt;a href="https://github.com/istio/istio">Istio&lt;/a>，对于外部用户来说，使用 &lt;a href="https://github.com/istio/istio">Istio&lt;/a> 可以快速搭建一套基本的微服务架构，
解决服务发现、流量路由、配置下发等问题，但是如果使用完整的 &lt;a href="https://github.com/istio/istio">Istio&lt;/a> 的解决方案，就要引入 Envoy，这会增加运维成本，而且直接使用官方的 Envoy 方案对性能有损，会引入额外的 CPU 开销且增加延迟。
&lt;strong>如果 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 能直接对接 &lt;a href="https://github.com/istio/istio">Istio&lt;/a>，既能让用户享受到部分 &lt;a href="https://github.com/istio/istio">Istio&lt;/a> 的能力，又可以避免 Envoy 带来的性能损失和部署运维成本。&lt;/strong> 但是在开源初期，我们没有看到很明确的用户诉求，因此没有对此做高优的支持。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/7.png" alt="image">&lt;/p>
&lt;p>后来 gRPC 官方也发布了 Proxyless 的支持，同时 &lt;a href="https://github.com/istio/istio">Istio&lt;/a> 的官方也将 Proxyless 作为使用 &lt;a href="https://github.com/istio/istio">Istio&lt;/a> 的一种方式。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 现在也已完成支持，目前主要是对接服务发现，
xDS 支持的扩展单独开源到了 &lt;a href="https://github.com/kitex-contrib/xds">kitex-contrib/xds&lt;/a> 库中，后续还会完善。大家可以根据 README 了解如何使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对接 &lt;a href="https://github.com/istio/istio">Istio&lt;/a>。&lt;/p>
&lt;h4 id="json-和-protobuf-泛化调用支持">JSON 和 Protobuf 泛化调用支持&lt;/h4>
&lt;p>之前，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持了应用在网关场景的 HTTP 泛化，以及支持了应用在一些通用服务场景的 Map 和二进制泛化。开源后，根据用户的需求反馈又新增了 JSON 和 Protobuf 的泛化。&lt;/p>
&lt;p>Protobuf 的泛化也是应用在 API 网关的场景。原来的 HTTP 泛化传输的数据格式是 JSON，但是 JSON 的序列化体积大、效率低，对性能有影响，所以很多移动端的接口选择使用 Protobuf 传输数据，因此增加了 Protobuf 泛化的支持。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/8.png" alt="image">&lt;/p>
&lt;p>&lt;strong>目前 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的泛化主要针对后端的 Thrift 服务，无论是 Protobuf、Map 还是 JSON，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 都会在调用端结合 IDL 解析，将这些数据映射编码为 Thrift 包发给后端服务。&lt;/strong>&lt;/p>
&lt;p>那么为什么把泛化放在调用端而不是服务端呢？大家广泛了解的泛化都是服务端对泛化请求做了解析处理，当然调用端也要相应地提供泛化的 Client。
但是泛化面向的是通用服务，泛化使用成本其实是比较高的，它并不适用于普通的 RPC 场景，而通用服务面向的是所有后端的服务，有 Golang/Java/C++/Python/Rust，如果每一种语言框架都支持泛化，成本是非常高的。
就算各个语言都对泛化做了支持，框架版本收敛又是一个漫长的过程，对于通用服务来说，对接所有的服务就显得不太现实。综合以上原因，泛化放在调用端支持。&lt;/p>
&lt;h4 id="重试能力增强">重试能力增强&lt;/h4>
&lt;p>去年开源时，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 已经支持了重试功能。之前支持的重试有两类，一个是超时重试，一个是 Backup Request。&lt;/p>
&lt;p>对于超时来重试来说，我们只会对超时这一种异常进行重试，但为了进一步提高请求成功率，用户希望对其他的异常也进行重试，或者用户可能会定义一些用户请求的状态码，结合用户状态码进行重试，
在这种情况下，显然我们只支持超时重试是不满足用户需求的。基于这个背景， &lt;strong>Kitex 新增了指定结果重试&lt;/strong> ，用户可以指定其他异常或指定某一类 Response，框架会结合用户指定的结果进行重试。&lt;/p>
&lt;p>其次，用户在配置重试时，如果通过代码配置的方式设置重试，它会对整个 Client 的所有 RPC 方法生效，但是用户希望针对不同的 RPC 方法应用不同的重试策略，甚至同一个方法也希望可以采用不同的重试策略，
因为不同链路上发起的同一个方法的请求对指标要求也会不同。比如有些想使用 Backup Request 减少延迟，有些想做异常重试提高成功率，对于这种情况， &lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 新的版本支持了请求粒度配置重试&lt;/strong> 。&lt;/p>
&lt;p>下图是使用示例。以请求粒度重试配置为例，比如 RPC 方法是 &lt;code>Mock&lt;/code>，那么我们在发起 RPC 调用的时候，在后面可以配置一个 &lt;code>callopt&lt;/code> 指定重试策略，此次请求就会使用这个重试策略。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/9.png" alt="image">&lt;/p>
&lt;h4 id="thrift-validator">Thrift Validator&lt;/h4>
&lt;p>Thrift-gen-validator 是 Thriftgo 的一个工具插件，它可以根据 Thrift IDL 中定义的注解描述约束给对应的 &lt;code>struct&lt;/code> 生成 &lt;code>IsValid() error&lt;/code> 方法，校验值的合法性。
通常做 RPC 调用的时候，用户可能会对一些字段校验合法性，用户如果直接写这些校验代码，投入的成本会很高。所以我们就提供了注解支持， &lt;strong>只要用户在 IDL 中根据规范定义注解，Kitex 就可以帮助用户生成校验代码&lt;/strong> 。&lt;/p>
&lt;p>下图是代码生成的命令和一个 IDL 注解定义示例，在生成代码的时候指定 Thrift Validator 的插件，我们的插件工具就会解析注解，为用户生成这一套合法性校验的代码。
目前我们也将 Thrift Validator 的功能贡献给了 Apache Thrift。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/10.png" alt="image">&lt;/p>
&lt;h3 id="性能优化">性能优化&lt;/h3>
&lt;p>介绍完几个重要的功能特性，再介绍几个在性能上的优化特性。&lt;/p>
&lt;h4 id="thrift-高性能编解码">Thrift 高性能编解码&lt;/h4>
&lt;p>&lt;strong>&lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a> 是一个无需生成编解码代码、基于 JIT 的高性能动态 Thrift 编解码器。&lt;/strong> 虽然我们针对官方 Thrift 编解码已经做了优化，支持了 FastThrift，这个在我们开源前发布的优化实践里也有介绍，
但我们希望能有进一步的性能提升，参考我们开源的高性能 JSON 库 Sonic 的设计，实现了 Thrift JIT 编解码器。下图中的表格是 &lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a> 结合 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 与 FastThrift 的性能对比。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/11.png" alt="image">&lt;/p>
&lt;p>可以看到在大部分场景 RPC 性能表现都较优。除了性能上的优势，&lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a> 还有另一个优势是无需生成编解码生成代码。Thrift 的生成代码比 Protobuf 繁重，一个复杂的 IDL 代码生成文件可以达到几万行，
而这些代码本来对用户来说无需关注，却需要由用户来维护。&lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a> 只需要生成结构体代码，不需生成编解码代码，就大大解决了这个问题。&lt;/p>
&lt;p>关于如何在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 中使用 &lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a>，可以参考仓库的 &lt;a href="https://github.com/cloudwego/frugal#readme">Readme&lt;/a>。当然用户也可以单独使用 &lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a> 作为 Thrift 高性能编解码器，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 后续也会考虑默认使用 &lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a>。&lt;/p>
&lt;h4 id="protobuf-高性能编解码">Protobuf 高性能编解码&lt;/h4>
&lt;p>虽然我们内部主要支持 Thrift，但开源之后我们发现外部用户对于 Protobuf 或 gRPC 的关注会更多，所以参考 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> FastThrift 的优化思路，重新实现了 Protobuf 的生成代码。
在 v0.4.0 版本，如果用户使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的工具生成 Protobuf 的代码，就会默认生成 &lt;a href="https://github.com/cloudwego/fastpb">Fastpb&lt;/a> 的编解码代码，在发起 RPC 调用的时候，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 也会默认使用 &lt;a href="https://github.com/cloudwego/fastpb">Fastpb&lt;/a>。&lt;/p>
&lt;p>下图是 &lt;a href="https://github.com/cloudwego/fastpb">Fastpb&lt;/a> 与官方 Protobuf 序列化的性能对比，可以看到无论是编码还是解码，在效率和内存分配上，&lt;a href="https://github.com/cloudwego/fastpb">Fastpb&lt;/a> 都远远优于官方 Protobuf 序列化库。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/12.png" alt="image">&lt;/p>
&lt;h4 id="grpc-性能优化">gRPC 性能优化&lt;/h4>
&lt;p>开源初期，我们对 gRPC 整体稳定性和性能的关注是比较少的。因为内部使用的场景不是很多。开源后收到了很多外部同学的反馈，
所以我们针对 gRPC 做了一个专项的问题治理以及性能优化。今年中旬我们已经把相关的优化正式提交到开源库，在 v0.4.0 版本发布。&lt;/p>
&lt;p>Kitex v0.4.0: &lt;a href="https://mp.weixin.qq.com/s/ezifbQkHcZQP6MygmJABYA">https://mp.weixin.qq.com/s/ezifbQkHcZQP6MygmJABYA&lt;/a>&lt;/p>
&lt;p>下图中左侧是优化前 Kitex-gRPC 和官方 gRPC 框架对 &lt;strong>Unary 请求&lt;/strong>的压测吞吐对比，在并发比较低的情况下，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的吞吐并不具有优势，
使用 &lt;a href="https://github.com/cloudwego/fastpb">Fastpb&lt;/a> 的时候，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的吞吐表现会好一些，但低并发的吞吐依然低于官方 gRPC。在优化之后，吞吐对比如右图所示。&lt;strong>相比优化前吞吐提升 46% - 70%，相比官方 gRPC 框架，吞吐高 51% - 70%。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/13.png" alt="image">&lt;/p>
&lt;p>下图中右侧是优化后 &lt;strong>Unary 请求&lt;/strong>的延迟对比，在吞吐比官方 gRPC 高出很多的情况下，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的延迟也显著低于官方的 gRPC。同时就 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 自身而言，在优化后延迟表现也好了很多。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/14.png" alt="image">&lt;/p>
&lt;p>我们再看下 &lt;strong>Streaming 请求&lt;/strong>的压测性能对比，优化前 Streaming 请求的表现同样在低并发的情况下，相对 gRPC 框架没有优势。
经过优化后，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 吞吐显著高于官方 gRPC，如下图，同时低并发下吞吐高但延迟持平，增加并发后能看到延迟出现分叉。所以在性能上， &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持的 gRPC 协议相对官方有明显的优势。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/15.png" alt="image">&lt;/p>
&lt;p>虽然在部分功能上，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 还没有完全对齐，但是目前已经可以满足大部分的场景需求，我们后续也会继续进行功能对齐。&lt;/p>
&lt;h2 id="社区共建完善生态及企业落地">社区共建完善生态及企业落地&lt;/h2>
&lt;h3 id="社区共建的-kitex-扩展生态">社区共建的 Kitex 扩展生态&lt;/h3>
&lt;p>开源后，我们很欣慰得到了很多开发者的关注，坦白说内部团队精力有限，无法快速建立起面向外部用户的 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 扩展生态。但是一年以来借助社区的力量，
&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在 &lt;strong>服务注册/发现&lt;/strong>、 &lt;strong>可观测性&lt;/strong>、&lt;strong>服务治理&lt;/strong>几部分的扩展得到了很多补充，尤其是服务注册/发现相关的扩展，目前开源的主流注册中心都已完成对接，
虽然在功能丰富度上我们还有待加强，但结合已有的支持，对于外部用户已经具备了搭建微服务架构的能力。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/16.png" alt="image">&lt;/p>
&lt;p>衷心感谢积极参与 CloudWeGo 社区建设的同学们！关于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 相关的生态支持，大家可以进入 &lt;a href="https://github.com/kitex-contrib">kitex-contrib&lt;/a> 了解更多的开源仓库。&lt;/p>
&lt;h3 id="对接外部企业协助落地">对接外部企业，协助落地&lt;/h3>
&lt;p>我们开源的初衷是为了助力其他外部企业快速地搭建企业级的云原生架构。开源后，森马、华兴证券、贪玩游戏、禾多科技先后主动与我们联系，反馈使用问题、提出需求，
的确让我们发现了一些和内部场景不一样的问题，需要我们去关注、支持和优化，我们很开心 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 能在这些企业内部得到应用。
在今年 6 月 25 日的 CloudWeGo Meetup 中，森马和华兴证券的研发同学也分享了他们使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的内部实践。&lt;/p>
&lt;p>森马：https://mp.weixin.qq.com/s/JAurW4P2E3NIduFaVY6jew&lt;/p>
&lt;p>华兴证券：https://mp.weixin.qq.com/s/QqGdzp-7rTdlxedy6bsXiw&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/17.png" alt="image">&lt;/p>
&lt;p>除了以上企业，还有一些公司也私下向我们咨询过使用问题，我们非常感谢这些企业用户的支持，以及向我们提出的反馈信息。
如第一部分所讲，收集社区和企业的反馈可以促进 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 面向多元场景支持的演进，企业用户如果有相关需求，欢迎联系我们。&lt;/p>
&lt;h3 id="如何使用-kitex-与内部基础设施集成">如何使用 Kitex 与内部基础设施集成&lt;/h3>
&lt;p>这里再简单介绍下如何使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 与大家的内部基础设施集成。以字节内部为例，内部仓库里有开源库中的扩展实现，集成内部的能力，
在 bytedSuite 中，我们针对不同场景对 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 进行初始化。如下面的代码示例，用户只需要在构造 Client 和 Server 时增加一个 option 配置就可以完成集成，
不过为了让用户完全不需关注内部能力的集成，我们将该配置放在了生成的脚手架代码中，关于配置如何内嵌在生成代码中，后续我们也会开放出来，方便外部的框架二次开发者能以同样的方式为业务开发同学提供集成能力。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/1st_RPC_Kitex/18.png" alt="image">&lt;/p>
&lt;h2 id="总结和展望">总结和展望&lt;/h2>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>本次分享主要介绍了以下内容：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 如何保持内外统一地从内部应用较广的框架转为开源框架；&lt;/li>
&lt;li>开源一年以来发布了哪些重要的功能特性，做了哪些性能优化；&lt;/li>
&lt;li>借助社区的力量现在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的周边生态如何、企业落地情况以及如何使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 优雅地集成内部能力。&lt;/li>
&lt;/ul>
&lt;h3 id="展望">展望&lt;/h3>
&lt;ul>
&lt;li>与社区同学共建，持续丰富社区生态；&lt;/li>
&lt;li>结合工程实践，为微服务开发者提供更多便利；&lt;/li>
&lt;li>完善好 BDThrift 生态，持续优化 Protobuf/gRPC；&lt;/li>
&lt;li>更多特性支持或开源，ShmIPC、QUIC、Protobuf 泛化…&lt;/li>
&lt;/ul></description></item><item><title>Blog: 开源社区的长期主义与新变化 — CloudWeGo 开源社区实践</title><link>https://www.cloudwego.io/zh/blog/2022/09/13/%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E7%9A%84%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E4%B8%8E%E6%96%B0%E5%8F%98%E5%8C%96-cloudwego-%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 13 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/13/%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E7%9A%84%E9%95%BF%E6%9C%9F%E4%B8%BB%E4%B9%89%E4%B8%8E%E6%96%B0%E5%8F%98%E5%8C%96-cloudwego-%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="概述">概述&lt;/h2>
&lt;p>CloudWeGo 开源一周年以来收获了超过 &lt;strong>1w&lt;/strong> 的 star 数，这一年 CloudWeGo 从项目的数量、性能的提升、社区的活跃、生态的拓展等各个方面都有一些整体的变化。
同时，通过一周年的开源，我们收获了非常多的开源社区用户，这些用户在社区里也提供了很多项目的使用反馈。基于这些反馈，我们发现随着技术发展和用户业务的不停迭代，用户需求也在发生着变化。
因此我们梳理了新一代关于云原生微服务用户的画像，作为指导我们社区持续演进的重要参考。&lt;/p>
&lt;h2 id="cloudwego-开源一周年的变化">CloudWeGo 开源一周年的变化&lt;/h2>
&lt;h3 id="全景图">全景图&lt;/h3>
&lt;p>CloudWeGo 是一套由字节跳动开源的云原生微服务架构中间件集合。在 2021 年 9 月正式推出的时候，只开源了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 高性能 RPC 框架、高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，还有相关的辅助工具和基础库。&lt;/p>
&lt;p>经过一年的建设，CloudWeGo 社区目前有 &lt;strong>11&lt;/strong> 个重点项目齐头并进。我们不仅有 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 框架，还有基于 HTTP 相关的高性能框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，同时开源了高性能的 Rust RPC 框架 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>，这也是国内首个开源 Rust RPC 框架。&lt;/p>
&lt;p>从 CloudWeGo 开源的项目也能感受到我们对性能的极致追求，我们不仅开源了框架相关的项目，同时也把深度优化的一些编解码库、网络库都进行了开源。
在 CloudWeGo 整体的项目中，始终都保持着三高的特性，即 &lt;strong>高性能&lt;/strong> 、&lt;strong>高可靠性&lt;/strong>和 &lt;strong>高扩展性&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/1.png" alt="image">&lt;/p>
&lt;p>与此同时，这一年我们也在致力于开源社区的建设：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易用性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>CloudWeGo 非常重视整个项目的易用性建设。我们有非常完整的官方文档体系，包括整体的扩展和 Example 的建设，以及各大云厂商生态的对接等。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>落地支持&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>为了帮助更多对高性能微服务架构有需求的用户，能够让他们真实地把高性能的技术解决方案落地，我们提供了 Benchmark 的性能测试和选型参考，同时提供免费的企业支持，帮助用户解决自己业务特异性上的一些问题。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>活动 &amp;amp; 布道&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>为了让更多有需求的用户能够在社区找到高性能技术解决方案，我们开设了相关的活动和布道体系的建设。在 CloudWeGo 开源一周年之际，项目整体收获了很多用户支持，也收获了很多企业用户的使用反馈。&lt;/p>
&lt;h3 id="cloudwego-开源社区的长期主义">CloudWeGo 开源社区的长期主义&lt;/h3>
&lt;h4 id="高性能技术解决方案的持续探索">高性能技术解决方案的持续探索&lt;/h4>
&lt;p>CloudWeGo 开源一周年的历程，其实就是对高性能技术解决方案持续探索的历程。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/2.png" alt="image">&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>CloudWeGo 从 2021 年 9 月 8 日正式开源。推出高性能的 RPC 框架 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>、配合 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 使用的高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>、基于 Thrift 代码生成工具 Thriftgo 和基础库 Sonic。&lt;/li>
&lt;li>2022 年 5 月，开源了基于 JIT 的编解码工具 Frugal。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 配合 Frugal 的使用，能够带来 5 倍的性能提升。&lt;/li>
&lt;li>2022 年 6 月，开源高性能 HTTP 框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 不仅仅是一个 高性能的HTTP 的开源框架，同时也是一个超大规模的企业落地实践。在我们内部的网关场景下，替换 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架之后的 CPU 使用节省了超过 40%。&lt;/li>
&lt;li>2022 年 7 月，我们响应社区呼声最高的关于 Protobuf 的性能优化，带来了高性能的 Protobuf 序列化反序列化库 FastPB，再次对相关的性能进行提升。&lt;/li>
&lt;li>开源一周年之际，我们又进行了更深度的高性能框架能力探索，开源了国内首个 Rust RPC 框架 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>CloudWeGo 开源一周年的时间线，隐藏着 CloudWeGo 社区运营的第一个长期主义关键词：&lt;strong>高性能技术解决方案的持续探索&lt;/strong> 。&lt;/p>
&lt;h4 id="活跃--高可靠性的长期承诺">活跃 &amp;amp; 高可靠性的长期承诺&lt;/h4>
&lt;p>CloudWeGo 开源一年来，收获了超过 1w 的 star 数，整个社区的活跃度也有了飞速提升。&lt;/p>
&lt;p>社区保持着 2-3 个月发布一次中版本的发版频率，PR 和 Issue 数量在开源一年的时间内实现稳步提升，从每月 47 条 PR 合入增加到每月超过 160 条 PR 合入。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/3.png" alt="image">&lt;/p>
&lt;p>其实高活跃的社区并不少见，但是我们社区还有一个关键词：&lt;strong>坚持活跃 &amp;amp; 高可靠性的长期承诺&lt;/strong>。CloudWeGo 社区对可靠性的坚持，要求我们不仅要维持活跃，还要保持活跃且可靠。&lt;/p>
&lt;p>CloudWeGo 开源社区一直保持着我们所有的开源项目内外一致的承诺，同时我们开源到外部的所有能力和项目都是在内部经过可靠性验证的。这也正是 CloudWeGo 开源社区坚持的另一个长期主义。&lt;/p>
&lt;h4 id="高易用性设计">高易用性设计&lt;/h4>
&lt;p>我们非常希望 CloudWeGo 开源出来的高性能技术解决方案，能够更好地帮助更多用户搭建自己的微服务架构体系。因此，CloudWeGo 在社区建设上围绕着易用性建设做了非常多的拓展：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CloudWeGo 文档建设&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>首先，在文档建设方面，CloudWeGo 官网上线了近 3 万字较为完善的文档体系。内容覆盖从 1 分钟快速上手，到各个相关模块的基本特性介绍，再到一些拓展能力的建设。&lt;/p>
&lt;p>其次，我们为了达到真正的开箱即用，节省用户对接各个扩展项目的使用成本，上线了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 相关的 Example，帮忙建设了相关从注册发现，到各个中间件使用的一些开箱即用的 Demo。&lt;/p>
&lt;p>另外，为了提升更多开发者的使用体验，官网也上线了静态文档的搜索能力。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/4.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CloudWeGo 生态建设&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>想在内部构建一套完整的云原生微服务架构体系，仅仅使用 CloudWeGo 的一个框架项目，是远远不够的。因此，CloudWeGo 在易用性方面大力拓展相关的生态建设。&lt;/p>
&lt;ol>
&lt;li>CloudWeGo 在 2021 年加入 CNCF Landscape，希望给用户一个更加明确的产品定位。同时，支持对接各大云厂商，为 CloudWeGo 项目的用户提供更多公有云的使用选择。&lt;/li>
&lt;li>为帮助大家减少相关的使用成本，我们非常积极地和上下游的开源项目进行深度合作，建设了一整套微服务开源供应链的合作体系，搭建了 CloudWeGo 框架对接各个项目的相关 Demo 和开箱即用的 Example。&lt;/li>
&lt;li>从考虑未来发展的角度而言，当企业落地了一整套微服务架构之后，可能会存在易用性或性能方面的问题。当出现更好的技术解决和性能提升方案，基于原有架构的耦合和复杂度，很难推进新的架构进行整体的迭代。
因此，我们也非常积极地在推进建设云原生微服务治理的整体标准。希望更多的项目，能够形成统一的接入和对接的标准，从而在未来的一些新的、更高性能的技术解决方案的迁移和过渡上，能够让迁移和使用成本降到最低。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/5.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CloudWeGo 的开发者活动&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>CloudWeGo 项目包括整个社区都对高性能有非常热烈的追求。因此，我们也在不停地迭代。&lt;/p>
&lt;p>CloudWeGo 一直在不断追求高性能框架以及高性能技术解决最新方案。每次上线新的技术解决方案和一些相关能力之后，我们都期望让更多的用户知道这些方案是怎样的，让用户能够更便捷地学习到一些相关的技术指南。&lt;/p>
&lt;p>因此，我们针对性地设计了 CloudWeGo Study Group 学习计划，这是为了将一些全新的性能解决方案进行体系化的学习分享，即通过一些类似于从框架入门到核心能力的解读、再到一些学习路径的分享以及扩展知识的相关介绍对外开放给社区。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/6.png" alt="image">&lt;/p>
&lt;p>我们会提供一份完整的学习资料，降低用户学习新的技术解决方案的成本，也能够让用户了解到自己的学习是否适合其业务场景。在整个学习和使用的过程中，降低最终学习的时长，通过体系化的学习更快地理解技术方案的性能亮点和需要学习的相关点。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/7.png" alt="image">&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;p>CloudWeGo 开源社区坚持的长期主义：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/8.png" alt="image">&lt;/p>
&lt;h3 id="cloudwego-的用户">CloudWeGo 的用户&lt;/h3>
&lt;p>基于开源社区长期主义的坚持，CloudWeGo 自 2021 年 9 月开源，至今开源 1 年，获得超过 1w star，支持完成了证券、电商、中台、社交、游戏、AI 等行业企业客户的落地使用。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/9.png" alt="image">&lt;/p>
&lt;h3 id="cloudwego-的贡献者">CloudWeGo 的贡献者&lt;/h3>
&lt;p>在活跃的社区氛围下，我们收获了从最初刚开源只有 20 个内部贡献者，到现在已经有了超过 200 个代码贡献者。这些贡献者在深度使用了 CloudWeGo 开源项目之后，也为 CloudWeGo 开源项目贡献了大量生态方面相关对接能力。&lt;/p>
&lt;h4 id="贡献者体系更新">贡献者体系更新&lt;/h4>
&lt;p>基于越来越多的贡献者在我们的开源社区里做了大量深度贡献，CloudWeGo 开源社区在一周年的周年庆之际，推出 &lt;strong>全新的贡献者激励体系&lt;/strong> 。&lt;/p>
&lt;p>我们新增开放了三个角色体系，希望通过这种完善的角色机制，赋予社区开发者更多的社区治理权限。同时我们也鼓励更多的贡献者能够成为项目的维护者，希望长期的维护者能够真正带领我们的项目持续进行高性能的优化和相关的演进。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/10.png" alt="image">&lt;/p>
&lt;h4 id="贡献者多样化">贡献者多样化&lt;/h4>
&lt;p>在开源项目的运营和维护中，包括开源社区的建设，不仅仅是依赖代码贡献者的参与，还有很多其他方面的贡献，其中包括企业支持场景的贡献、布道活动的贡献、整体活动组织的贡献等多元参与。
这些贡献者在 CloudWeGo 社区也是被大力支持的，因此我们专门针对多元贡献上线了 CloudWeGo 年度激励计划。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/11.png" alt="image">&lt;/p>
&lt;p>社区在 8 月份刚刚完成了 2021 - 2022 年度 CloudWeGo Awesome Contributor 的评选，我们非常荣幸地收获了 84 位年度优秀贡献者。
在完成了社区的提名与公示后，这些同学已经顺利成为了 CloudWeGo 年度优秀贡献者，之后我们会为这些优秀贡献者送上 CloudWeGo 一周年的荣誉纪念徽章。&lt;/p>
&lt;h3 id="cloudwego-社区遇到的问题">CloudWeGo 社区遇到的问题&lt;/h3>
&lt;p>正是因为社区较高的活跃度以及众多贡献者的参与，大量用户加入了 CloudWeGo 社区。我们逐渐发现用户的使用场景开始慢慢发生了拓展。
从最初可能只是想了解一下微服务的框架、单独一个项目如何去落地和使用，到后来慢慢变成探索一整套微服务架构的设计，以及多个项目之间的实践配合和相关生态能力的建设。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/12.png" alt="image">&lt;/p>
&lt;p>这些其实是非常体系化、大规模的需求，因此我们联合一些企业用户进行了相关场景的实践贡献。CloudWeGo 之前支持了包括证券、电商、AI 和各个行业用户场景落地，我们也和这些企业用户进行了相关场景的梳理。&lt;/p>
&lt;h3 id="cloudwego-的企业用户贡献">CloudWeGo 的企业用户贡献&lt;/h3>
&lt;h4 id="华兴证券">华兴证券&lt;/h4>
&lt;p>案例链接：https://www.cloudwego.io/zh/cooperation/huaxingsec/&lt;/p>
&lt;p>华兴证券的张天老师团队向社区贡献了来自证券行业使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 完成混合云部署下跨机房使用场景的案例。&lt;/p>
&lt;p>我们在跟张天老师团队合作的时候发现，他们遇到的最大的问题是有的业务部署在金融云机房上，有的业务部署在私有机房上，所以存在跨机房调用的问题。
因为他们使用 K8s 集群，还会出现同集群调用和跨集群调用的问题。整个调用的链路非常长，这中间就会出现很多不可观测的问题，当出现问题的时候，排查难度就极其大。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/13.png" alt="image">&lt;/p>
&lt;p>于是张天老师团队在和 CloudWeGo 合作之后，整体搭建了一个 &lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> + K8s&lt;/strong> 的可观测性系统，也将相关的搭建实践贡献到了开源社区。感兴趣的同学可以通过 CloudWeGo 公众号查看相关的企业案例和最终的实践场景。&lt;/p>
&lt;h4 id="森马">森马&lt;/h4>
&lt;p>案例链接：https://www.cloudwego.io/zh/cooperation/semir/&lt;/p>
&lt;p>CloudWeGo 和森马共同梳理了与电商行业相关的一个整体使用场景。非常感谢森马团队，贡献了电商行业使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 接入 Istio，以提高对高并发订单处理能力的使用场景。&lt;/p>
&lt;p>森马团队还贡献了基于微服务架构的两种模式，为有相关高性能业务需求的用户提供了&lt;strong>服务网格 + &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>&lt;/strong> 治理模式相关的选型依据，并且给出了相关的压测报告，也给社区有相同需求的小伙伴提供重要参考。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/14.png" alt="image">&lt;/p>
&lt;h4 id="飞书">飞书&lt;/h4>
&lt;p>案例链接：https://www.cloudwego.io/zh/cooperation/feishu/&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开源后，很多用户会问到内部网关平台架构的设计思路，包括内部网关平台如何配合 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 整体使用？&lt;/p>
&lt;p>飞书之前是一个 all-in-one 的套件开发模式，各个业务团队会将业务代码提交到飞书网关平台的代码仓里面，由飞书网关相关的同学来做 web 逻辑的开发。
这就导致他们所有的服务都是融在一起的，没有办法做到发布隔离，极大地阻碍了网关平台架构的演进和迭代速度。&lt;/p>
&lt;p>因此，飞书团队将前端 Node 单体服务做了微前端架构拆分，配合 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 泛化调用各个业务的微服务，实现了各个业务发布完全隔离，这使得他们不再依赖网关平台的业务开发，进而加快了整个网关业务迭代的速度。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/15.png" alt="image">&lt;/p>
&lt;h3 id="来自社区的用户具体问题">来自社区的用户具体问题&lt;/h3>
&lt;p>我们非常感谢企业用户贡献的相关问题，CloudWeGo 配合企业用户的场景案例也获得了社区用户的众多好评。与此同时，有更多的用户也提出了新的问题，这些问题非常具体。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/16.png" alt="image">&lt;/p>
&lt;p>通过总结发现，这些问题具有显著的业务特异性。我们也很好奇这些用户在内部到底是如何搭建其微服务体系的？&lt;/p>
&lt;p>因此我们开始梳理 CloudWeGo 开源社区的云原生微服务用户画像。&lt;/p>
&lt;h2 id="新一代云原生微服务用户画像">新一代云原生微服务用户画像&lt;/h2>
&lt;p>我们将社区的用户大概分成了三种类型：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/17.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>字节跳动&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>字节跳动是我们目前最大的用户。字节跳动的线上微服务数量已经超过了 10 万，服务端峰值 QPS 已经达到了数亿的级别，业务复杂性非常大，存在跨语言、跨平台、跨终端、跨集群、跨机房等多种复杂的问题。&lt;/p>
&lt;p>同时字节跳动内部有非常完善的微服务架构体系，整体的微服务治理已经全面迈入了 2.0 的时代，用微服务框架配合服务网格携手并进。&lt;/p>
&lt;p>在这个场景之下，字节跳动最大的需求就是高性能和可扩展性，这也是 CloudWeGo 作为字节跳动内部孵化的一个优秀的高性能技术解决方案最初开源时所具有的特性。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>处于转型期的用户&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>社区里数量最大的群体，这些用户可能是电商的、证券的、后台的以及一些创业公司，他们的节点数量不是特别多，可能在 5-1000 以内，
线上微服务数量处于 5000 以内的水平，但这些用户可能本身就是云原生架构，或者已经在往这方面做一些相关的迁移。&lt;/p>
&lt;p>这类用户在 CloudWeGo 开源社区的诉求，主要是针对业务的特异性方面存在高性能相关的需求。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>非云原生架构企业用户&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>这一类用户属于非云原生架构的企业，他们的服务可能还没有完全云化，具有一定的历史迁移负担。这类用户着重会优先考虑如何将自己的服务迁移上云。&lt;/p>
&lt;p>因此可以看到，第二类用户是目前社区数量最大，且最需求最迫切的一类用户。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/18.png" alt="image">&lt;/p>
&lt;p>我们认为理想状态下用户整个云原生架构体系的搭建过程：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一个阶段：服务上云&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>类似第三类用户，当前面临的问题就是怎么把自己的业务迁移上云。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第二个阶段：云原生部署&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>类似第二类社区大量的用户，其实已经是云原生部署的企业，用到了相关容器化和编排调度的技术。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第三个阶段：微服务架构&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>继续往前演进，开始搭建相关的微服务架构，以及会做服务的拆分和通信的治理。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第四个阶段：微服务治理&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>当用户在线上有了一定数量的微服务之后，会开始出现依赖管理和一致性保障的问题。&lt;/p>
&lt;p>但是我们在跟用户沟通过程中发现，这其实不是一种绝对意义上的区分。&lt;/p>
&lt;p>因为很多公司其实并不是完全属于其中一种状态，而是一种长久的中间态，公司的业务会处于不同的状态。同时，我们在和相关用户进行深度的沟通时，发现这些业务场景其实并不是完全不可复制的，而是具有一定的行业聚合性和相似性。&lt;/p>
&lt;p>于是，我们开始探索如何通过社区更好地帮助这些开发者解决痛点问题，这也正是 CloudWeGo 开源社区接下来整体的演进方向。&lt;/p>
&lt;h2 id="持续演进的-cloudwego-开源社区">持续演进的 CloudWeGo 开源社区&lt;/h2>
&lt;p>CloudWeGo 1.0 社区搭建的主要方向，是将字节跳动内部孵化的高性能框架解决方案触达给更多的用户，让更多对高性能解决方案有需求的用户能够真正地在内部落地和使用这些方案。&lt;/p>
&lt;p>当我们发现用户出现特异性的行业需求后，ClouWeGo 2.0 希望社区建设以开发者服务为主，能真正地帮助到社区的开发者，解决其在微服务治理过程中遇到的一些真实存在的问题。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/19.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>行业解决方案&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>通过用户问题、场景和解决方案的行业共建，形成社区的 Go 云原生微服务最佳实践，希望能够针对有特异性需求的用户给到一定的参考。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易用性建设&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们会持续和开源链条的上下游深入合作，建设云原生微服务相关的标准治理。致力于后续易用性的建设，希望能够给到成本更低的迁移，以及建立后期维护的治理标准。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>持续投资高性能方案&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>继续维持 CloudWeGo 开源社区的长期主义。我们会深入投入对高性能解决方案的持续探索，也会在 Rust 领域持续开展相关生态和开源的建设，共建 Rust 中国的开源生态。&lt;/p>
&lt;p>基于此，引出 CloudWeGo 开源社区 2.0：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_community/20.png" alt="image">&lt;/p>
&lt;p>CloudWeGo 2.0 的阶段，我们希望社区能够跨越项目边界，真正能够帮助社区用户搭建一套高性能的微服务治理架构和整体的微服务治理体系：&lt;/p>
&lt;ul>
&lt;li>通过 Go 领域相关微服务治理的标准和最佳实践的建设，为一些通用性技术和行业最佳实践提供参考；&lt;/li>
&lt;li>对接开源项目上下游进行深度合作，极大地提升整个项目的易用性；&lt;/li>
&lt;li>推进高性能 Rust 解决方案的落地，持续探索 Rust 高性能技术解决方案，构建 Rust 相关生态。&lt;/li>
&lt;/ul>
&lt;p>如果大家对 CloudWeGo 开源社区，以及刚才提到的一些技术解决方案、企业的落地支持有任何的疑问，可以关注 CloudWeGo 公众号，
我们会在公众号上发布一些新闻动态以及各个相关场景的案例报道，同时我们也会在公众号上提供相关的技术支持。感谢大家的关注！&lt;/p></description></item><item><title>Blog: 选择 Go 还是 Rust？CloudWeGo-Volo 基于 Rust 语言的探索实践</title><link>https://www.cloudwego.io/zh/blog/2022/09/06/%E9%80%89%E6%8B%A9-go-%E8%BF%98%E6%98%AF-rustcloudwego-volo-%E5%9F%BA%E4%BA%8E-rust-%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8E%A2%E7%B4%A2%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/09/06/%E9%80%89%E6%8B%A9-go-%E8%BF%98%E6%98%AF-rustcloudwego-volo-%E5%9F%BA%E4%BA%8E-rust-%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8E%A2%E7%B4%A2%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="cloudwego-选择-rust-语言进行探索的原因">CloudWeGo 选择 Rust 语言进行探索的原因&lt;/h2>
&lt;p>CloudWeGo 正式官宣新一代 Rust RPC 框架 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 开源！CloudWeGo 为什么会选择 Rust 这门语言进行探索呢？本文首先介绍一下其中的原因。&lt;/p>
&lt;h3 id="go-的代价">Go 的代价&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>深度优化困难&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 早期的团队成员来自于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 项目（CloudWeGo 开源的 Golang 微服务 RPC 框架）。当时我们投入了大量的时间和精力优化 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 以及其他相关基础库的性能，最终却发现实现 Go 的深度优化有些困难。
我们仅仅可以做一些算法层面和实现层面的优化，如果想往下继续做其他层面的优化，比如指令层面的优化，是很难以低成本的方式实现的。而且在大多数情况下很多优化是要和 runtime 以及编译器作斗争的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>工具链和包管理不够成熟&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>例如，使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 框架时需要先使用对应的 kitex 工具生成代码，才能正常编译使用。虽然这种情况可能在 &lt;a href="https://github.com/cloudwego/frugal">Frugal&lt;/a> 工具成熟之后有所改善，但是在 IDL 有更新的情况下，还是需要使用 kitex 重新生成对应的结构体。
这个问题并不是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的问题，而是 Go 语言本身的问题，Go 语言在编译时没有提供类似的能力。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>抽象能力较弱&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Go 语言的抽象能力是比较弱的，而且 Go 语言里面的抽象并不是零成本抽象，而是有代价的抽象。&lt;/p>
&lt;p>那么使用 Go 语言需要付出的三个代价具体应该如何理解呢？下面进行具体分析。&lt;/p>
&lt;h3 id="深度优化困难">深度优化困难&lt;/h3>
&lt;p>如图所示，这是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 项目生成代码的简单示例。这两段代码的目的是在解析出错的时候，把一些信息返回给上层。在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 新版本代码公开之后，
业务团队同学反映他们线上序列化和反序列化这部分的性能相差了 20%，经排查之后，我们发现了这个改动。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/2.png" alt="image">&lt;/p>
&lt;p align="center">
Kitex 新版本的代码
&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/3.png" alt="image">&lt;/p>
&lt;p align="center">
Kitex 旧版本的代码
&lt;/p>
&lt;p>这个改动的本意是希望能给客户提供更多错误上下文的信息。但是它带来了什么问题呢？如下图，它把汇编代码直接一对一地生成到主流程之中，也就是说 Go 语言的编译器会逐行逐句地进行翻译，并且不会做重排。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/4.png" alt="image">&lt;/p>
&lt;p>那么这会带来什么问题呢？由于我们主流程中的代码与正常流程相比变多了，所以我们重点关注一下 &lt;code>L1-icache-load-misses&lt;/code> 这一行，
新版本的代码比旧版本的代码在 L1 指令 &lt;code>cache&lt;/code> 层面 &lt;code>cache-misses&lt;/code> 高出 20%，这也就是我们的代码效率降低 20% 的原因。那么我们是如何解决这个问题的呢？&lt;/p>
&lt;p>我们的解决方案如下图所示。在 &lt;code>err != nil&lt;/code> 的情况下，直接手动加一条 &lt;code>goto&lt;/code> 语句，把所有错误处理这部分的代码放到函数末尾，即 &lt;code>return&lt;/code> 之后。
这相当于在编译器没有实现指令重排的情况下，用人工方式做一次指令重排。最后优化的效果是非常明显的，可以看到 &lt;code>cache-misses&lt;/code> 比之前的那一次还要降低 25%。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/5.png" alt="image">&lt;/p>
&lt;p>上述例子只是使用 Go 语言时在做深度优化方面遇到的难题。在抽象能力方面，使用 Go 语言也会遇到一些困难。&lt;/p>
&lt;h3 id="零成本抽象zero-cost-abstraction">零成本抽象(Zero-Cost Abstraction)&lt;/h3>
&lt;p>什么是零成本抽象呢？使用 C++ 和 Rust 的同学对这个概念可能有所了解。零成本抽象是指我们不需要对没有使用的功能付出编译和运行的开销，也就是用户不需要给没有使用的东西付费。
对应地，如果用户对于已经使用的东西也没有再继续优化的空间，因为它已经默认提供了最佳实践。总结如下：&lt;/p>
&lt;ul>
&lt;li>不用的东西，不需要为之付出代价；&lt;/li>
&lt;li>用到的东西，你也不可能做得更好。&lt;/li>
&lt;/ul>
&lt;p>那么为什么说 Go 语言里面没有零成本抽象呢？以 Thrift 编解码为例，我们最开始使用的是 Apache Thrift，它为了支持多种不同 Protocol、Transport 组合，
抽象出了 TProtocol Interface、TTransport Interface，但 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 直接依赖具体的 BinaryProtocol 的实现（struct）。可以试想，Apache Thrift 这么做的代价是什么呢？这就是 Go 里面 Interface 带来的代价。&lt;/p>
&lt;p>Go 里面 Interface 是动态分发的，也就是运行时通过类型元数据和指针去动态调用所需方法，它会在运行时多做一次内存寻址。但这并不是最关键的，最关键的是它会使得编译器没有办法 inline 以及没有办法做很多优化。
一般比较注重性能的语言都会同时提供静态分发和动态分发两种方式的抽象能力，但是 Go 语言只提供了 Interface 动态分发能力，也就可以理解为在 Go 语言中抽象和性能是不可兼得的，这也就是 Go 语言抽象能力比较弱的原因。&lt;/p>
&lt;h3 id="sonic">Sonic&lt;/h3>
&lt;p>&lt;a href="https://github.com/bytedance/sonic">Sonic&lt;/a> 是 CloudWeGo 开源的一个 JSON 库，这个库有很多 CloudWeGo 的用户都使用过。最初这个库组成部分如下图所示，有 2/3 的代码都是 Assembly 汇编。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/6.png" alt="image">&lt;/p>
&lt;p>在 &lt;a href="https://github.com/bytedance/sonic">Sonic&lt;/a> 库中仅有的 27% 的 Go 源代码如下图所示。虽然它被统计到了 Go 代码中，但实际上是汇编代码。所以我们可以总结出，世界上最快的 Go 语言程序大概就是用汇编代码写就的。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/7.png" alt="image">&lt;/p>
&lt;h3 id="性能最好的-go-json-库">性能最好的 Go JSON 库&lt;/h3>
&lt;p>尽管 &lt;a href="https://github.com/bytedance/sonic">Sonic&lt;/a> 里面采用了各种黑科技，甚至有 2/3 的代码都是经过人工精调的汇编代码，但是 &lt;a href="https://github.com/bytedance/sonic">Sonic&lt;/a> 的综合性能还是不如 Rust 最通用的 Serde JSON 库。
如图所示，绿色柱状图代表 Serde JSON 库，蓝色柱状图代表 &lt;a href="https://github.com/bytedance/sonic">Sonic&lt;/a> 库。根据这个 Benchmark，即使是和 C、C++ 的库相比，用 Rust 语言编写的这个库在各方面综合表现也是最佳的。&lt;/p>
&lt;p>试想，又有多少 Go 组件能够得到如此大量的人力投入从而进行深度优化呢？这只是一个例子，其实我们之前在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 中的很多优化也是要和编译器以及 runtime 作斗争的。因此我们认识到在 Go 语言中想做深度优化是非常困难的。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/8.png" alt="image">&lt;/p>
&lt;h3 id="关于-rust">关于 Rust&lt;/h3>
&lt;p>我们为什么要选择 Rust 这门语言呢？在解答这个问题之前，要先了解这门语言。所以先介绍一下 Rust 语言的发展历史。&lt;/p>
&lt;h3 id="rust-的历史">Rust 的历史&lt;/h3>
&lt;p>Rust 语言由 Graydon Hoare 私人研发，他是 Mozilla 做编程语言的工程师，专门给语言开发编译器和工具集。当时 Mozilla 要开发 Servo 引擎，想要保证安全的同时又能拥有高性能，
于是就选择了 Rust 语言。2010 - 2015 年期间，Rust 是有 GC 的，后来社区一致表示支持 Rust 必须要有高性能，所以 GC 被取缔。2015 年，Rust 发布 1.0 版本，这也表示正式官宣 Rust 的稳定性。&lt;/p>
&lt;p>Rust 是以三年为单位进行社区规划和迭代的。2015 - 2018 年，Rust 达成了生产力的承诺，也就是它的工具文档还有编译器变得更加智能，也对开发者更加友好了。
2018 - 2021 年，Rust 做了更多异步生态的完善。之前的 Rust 是没有异步生态的，但是自 2018 年开始，它正式引入了异步功能。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/9.png" alt="image">&lt;/p>
&lt;h3 id="rust-2024">Rust 2024&lt;/h3>
&lt;p>2021 - 2024 年，Rust 有一个 2024 规划，主题叫做 Scaling Enpowerment（扩展授权）。之所以取这个名字，是因为 Rust 有一个目标——“empower everyone to build reliable and efficient software”。
Rust 最关注也是大家经常诟病的一点，就是 Rust 的整个学习曲线非常陡峭，所以在这个规划中写道 “Flatten the learning curve”。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/10.png" alt="image">&lt;/p>
&lt;h3 id="rust-三大优势">Rust 三大优势&lt;/h3>
&lt;p>在 2022 年，很多开源项目已经呈现爆炸式增长。我们了解到 Rust 这门语言后，发现它有三大非常重要的优势：第一是高性能；第二是很强的安全性；第三是协作方便。
因此我们想尝试在服务端使用 Rust 语言开发微服务，以此解决我们面临的一些性能上的问题。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>很多用户都对性能有很高的要求，也想知道 Rust 的性能如何。下图是各语言的 Benchmark 对比结果，可以看出 Rust 的性能是非常优秀的，远超过 Go 语言，甚至比 C++ 的性能更好。&lt;/p>
&lt;p>当然我们要着重说明，这个 Benchmark 要求所有语言必须使用相同的算法，并且不得经过额外优化。毕竟如果都用汇编代码写，其实各语言性能相差无几。
但是在真正的开发过程中，又有多少代码能够经过那么大量的人工精细优化呢？另外，有人可能会对 Rust 的性能比 C 和 C++ 更优秀产生质疑，其实这也是因为 Rust 对于程序员的输入要求得更加严格，所以编译器可以做更进一步的优化。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/11.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>安全性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>因为在 Rust 语言的安全性方面可查阅到大量资料，因此不再过多赘述。只阐述一个重要结论：Rust 1.0 之后，在非 Unsafe 代码中是不可能出现内存安全问题的。
这个结论是通过数学证明过的，因此非常可靠。我们应该如何理解这个结论呢？可以从它的推论入手，即：一切内存/并发安全问题，都是 unsafe 代码导致的。
也就是如果真的出现安全问题，我们可以限制在一个非常小的范围内进行排查。因为毕竟绝大多数的 Rust 语言代码都是 Safe Rust，而不是 Unsafe Rust。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>协作&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Rust 是一门真正通过工程实践形成的语言，它有非常 &lt;strong>智能的编译器&lt;/strong> 、 &lt;strong>完善的文档&lt;/strong> 、&lt;strong>集群的工具链&lt;/strong>和 &lt;strong>成熟的包管理&lt;/strong> ，因此 Rust 非常适合协作。
我们在使用时可以专注于逻辑功能的实现，而不用担心内存安全和并发安全的问题等等。还有非常重要的一点就是可以限制别人的代码，因为如果别人的代码有内存安全问题或并发安全问题，将无法进行编译。
所以在做 Code Review 时，我们只需关注逻辑上的功能正确性就可以，因为只要能够通过编译提交上来的代码，安全性是不必担心的。
这虽然是 Rust 语言的优点，但也给使用者带来一些不便之处。我们常听说 Rust 开发者很难，也正是因为编译。&lt;/p>
&lt;h3 id="rust-的影响力">Rust 的影响力&lt;/h3>
&lt;p>如下图，Rust 已经连续七年位居 Stack Overflow 最受开发者喜爱的编程语言榜榜首。此外，有一个非常重量级的项目叫做 “Rust for Linux”，
除了 C 语言之外，Rust 是 Linux 内核迄今为止接受的唯一语言。这些成绩足以看出 Rust 在开源业界的重量级和影响力。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/12.png" alt="image">&lt;/p>
&lt;h2 id="创建-rpc-框架-volo-的原因">创建 RPC 框架 Volo 的原因&lt;/h2>
&lt;p>明确了 CloudWeGo 选择 Rust 语言的原因以及 Rust 的优势，我也阐述一下创造 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架的原因以及 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 的特点。&lt;/p>
&lt;h3 id="生态现状">生态现状&lt;/h3>
&lt;p>创造 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架与当时的生态情况是有关的。我们当时调研过整个社区的生态，发现没有生产可用的 Async Thrift 实现。哪怕是社区中最成熟的 Tonic 框架，它的服务治理功能也是比较弱的，而且易用性也不够强。
更重要的是当时在 Rust 语言社区，还没有基于 Generic Associated Type（GAT，Rust 语言最新的⼀个重量级 Feature）和 Type Alias Impl Trait（TAIT，另⼀个重量级 Feature）的易用性强的抽象。&lt;/p>
&lt;h3 id="易用性">易用性&lt;/h3>
&lt;p>为什么单独说明 GAT 和 TAIT 这两个特性呢？按照 Rust 官方团队的说法，这是自 Rust 1.0 以来语言层面和 Type System 层面最大的变化。
举例简单说明，下图是一个现有的社区方案，代码是没有使用 GAT 和 TAIT 的超时中间件的编写，我们可以发现如果要保证性能不受损耗，需要编写大量代码。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/13.png" alt="image">&lt;/p>
&lt;p>而在 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架中，因为采用了 GAT 和 TAIT 这两个特性，编写代码如下图所示。我们可以明显对比出代码量和易用性方面的差距是非常明显的。
Rust 以难学难用而闻名，我们希望尽可能地降低用户使用 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架和 Rust 语言编写微服务的难度，提供给用户最符合人体工程学和直觉的编码体验，因此我们把框架易用性作为重要目标之一。
只有让大家真正地使用 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 才能体现它的价值。所以 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架 &lt;strong>基于 GAT 和 TAIT 特性&lt;/strong> ， &lt;strong>大大提升了用户编写中间件的便利程度&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/14.png" alt="image">&lt;/p>
&lt;p>除此之外，我们提供了 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> &lt;strong>命令行工具生成默认 Layout&lt;/strong> ，并且 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 的命令行工具提供 &lt;strong>IDL 管理的能力&lt;/strong> ，这在业界是首例。
我们还提供了过程宏等能够再度降低 Service 编写难度的功能。当然还有很多其他的精心设计，比如很多 API 都是尽量以最符合人体工程学的方式给出的，也可以避免误用。&lt;/p>
&lt;h3 id="扩展性">扩展性&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>基于 Service 的抽象&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>受益于 Rust 强大的表达和抽象能力，开发者可以基于非常灵活的 Service 抽象，用统一的形式对 RPC 的元信息请求和响应做一些处理，比如服务发现、负载均衡等服务治理功能都是直接实现 Service 即可。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/15.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>基于 RPC 元信息的控制&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>另外，在我们的框架设计中，所有框架行为都是受到 RPC 元信息控制的。因此我们只要在 Service 中对 RPC 元信息进行修改，就能直接控制框架的行为，从而实现所需的功能。&lt;/p>
&lt;p>下图是 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 自带的负载均衡中间件实现中最关键的一部分，即红色线框圈出的代码。只要把 Load Balance 选出来的地址放到 RPC 元信息中就可以，其他代码可以直接忽视掉。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/16.png" alt="image">&lt;/p>
&lt;h3 id="性能">性能&lt;/h3>
&lt;p>如果过多谈论框架的性能对比，容易引战。但是基于 Rust 语言的性能优势以及 CloudWeGo 团队对于极致性能的追求，我们可以预想到 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 的性能也是非常高的。&lt;/p>
&lt;p>如果把 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 进行跨语言的对比也是不太公平的，但是因为很多用户都关注性能数据，为了让使用者对 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架的性能有大致的了解，我们只给出比较简单的性能数据。
在与 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 相同的测试条件（限制 4C）下，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 极限 QPS 为 35W。同时，我们内部正在验证基于 &lt;a href="https://github.com/bytedance/monoio">Monoio&lt;/a>（CloudWeGo 开源的 Rust Async Runtime）的版本，极限 QPS 可以达到 44W。&lt;/p>
&lt;p>当然还有很多其他的性能指标，比如响应时间也是非常影响用户体验的。所以除了 Benchmark，我们选取了由 Go 迁移到 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架的两个业务，呈现真实的业务落地收益。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>业务 A（Proxy 类）&lt;/strong> 。A 业务的 IO 比较多，迁移到 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架后的各方面数据如下：&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>CPU Usage 630% -&amp;gt; 380%&lt;/li>
&lt;li>MEM 9GB -&amp;gt; 2GB&lt;/li>
&lt;li>P99 150-200ms -&amp;gt; 20-35ms&lt;/li>
&lt;li>AVG 4-5ms -&amp;gt; 1.5ms&lt;/li>
&lt;/ul>
&lt;p>可以看出不论是 CPU、内存还是延时的指标，都有非常明显的提升。下图中间红线代表 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 上线的时间，也就是红线左侧这一部分是 Go 的指标，红线右侧是 Rust 的指标，左右对比可以更直观看出 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架给业务 A 带来的收益。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/17.png" alt="image">&lt;/p>
&lt;ol start="2">
&lt;li>&lt;strong>业务 B（有大量业务逻辑）&lt;/strong> 。业务 B 是一个计算密集型的业务，使用 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架后 CPU 400% -&amp;gt; 130%。因此在计算密集型的业务中，CPU 的提升更加明显。&lt;/li>
&lt;/ol>
&lt;h3 id="相关生态">相关生态&lt;/h3>
&lt;p>随着 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架开源，一起开源的所有生态如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Volo&lt;/strong> 是 RPC 框架的名字，包含了 Volo-Thrift 和 Volo-gRPC 两部分。&lt;/li>
&lt;li>&lt;strong>Volo-rs 组织&lt;/strong> ：Volo 的相关生态。&lt;/li>
&lt;li>&lt;strong>Pilota&lt;/strong> ：Volo 使用的 Thrift 与 Protobuf 编译器及编解码的纯 Rust 实现（不依赖 protoc）。&lt;/li>
&lt;li>&lt;strong>Motore&lt;/strong> ：Volo 参考 Tower 设计的，使用了 GAT 和 TAIT 的 middleware 抽象层。&lt;/li>
&lt;li>&lt;strong>Metainfo&lt;/strong> ：Volo 用于进行元信息透传的组件，定义了一套元信息透传的标准。&lt;/li>
&lt;/ul>
&lt;p>全景图如下：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/18.png" alt="image">&lt;/p>
&lt;h3 id="仓库地址">仓库地址&lt;/h3>
&lt;p>以下是所有相关生态的仓库地址。欢迎大家来提 Issue 或 PR，一起共建 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a>！&lt;/p>
&lt;ul>
&lt;li>Volo：https://github.com/cloudwego/volo&lt;/li>
&lt;li>Volo-rs：https://github.com/volo-rs&lt;/li>
&lt;li>Pilota：https://github.com/cloudwego/pilota&lt;/li>
&lt;li>Motore：https://github.com/cloudwego/motore&lt;/li>
&lt;li>Metainfo：https://github.com/cloudwego/metainfo&lt;/li>
&lt;/ul>
&lt;h2 id="rust-语言和-go-语言如何选择">Rust 语言和 Go 语言如何选择&lt;/h2>
&lt;p>了解 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架后，关于 Rust 语言和 Go 如何选择的问题，我有一些主观的建议和想法。&lt;/p>
&lt;h3 id="和-cgo-对比">和 C++、Go 对比&lt;/h3>
&lt;p>如果 Go 的服务想用另一种语言重写，目前还是 Rust 语言和 C++ 可选性高一些，因此我将这三种语言进行对比，以期为面临选择编程语言的用户提供一些参考。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Rust_or_Go/19.png" alt="image">&lt;/p>
&lt;p>&lt;strong>在学习难度方面&lt;/strong>，Rust 语言和 C++ 学习难度比较高，而 Go 语言的学习难度比较低。&lt;/p>
&lt;p>&lt;strong>在性能方面&lt;/strong>，Rust 语言和 C++ 的性能比较高。我给 Go 语言的性能评级为中等，毕竟和 Python 这些服务相比，Go 语言还是要强很多的。&lt;/p>
&lt;p>&lt;strong>在安全性方面&lt;/strong>，C++ 的安全性比较低，Go 语言安全性中等，Rust 语言安全性比较高。因为 Go 语言 虽然能够通过 GC 防住一些内存安全的问题，但是它没有办法防住类似 Data Race 这种并发安全的问题，
而且大多数时候这类问题其实很难排查。Rust 能够做到可防可控，应防尽防，只要有内存安全问题或并发安全问题，都无法成功编译。&lt;/p>
&lt;p>&lt;strong>在协作方面&lt;/strong>，Rust 语言的协作能力比较高，Go 语言和 C++ 的协作等级是中等。首先，C++ 没有官方提供的包管理工具，它必须借助第三方社区提供的包管理工具，但是不同的项目使用的包管理工具可能是不一样的，
所以这是对用户来说非常不便的；其次，在开发者可以保证自己的代码没有 Bug、符合最佳实践的情况下，还是不可避免地会和一些第三方的库以及比较老旧社区一流的库产生交集，并且产生混用的情形；
最后，如果涉及到大型项目，需要团队协作开发，我们无法保证团队中其他人写出的代码也不存在内存安全问题。至于 Go 语言，它的编译时及工具链的能力相对来说比较弱，因此也定级为中等。&lt;/p>
&lt;p>&lt;strong>在特性和使用成本方面&lt;/strong>，用户应该都有所了解，不再过多赘述。从使用成本上来讲，我的评级为给 C++ 为高使用成本，Go 语言和 Rust 语言的使用成本是中等。C++ 的业务上线之后经常出状况，
而且排查问题困难是很常见的情况。而使用 Go 语言做一些通用的编程是可以的，但是一旦涉及到定制化的需求在实现上就有一定的困难，比如需要根据不同的平台系统做系统级编程，
使用 Go 语言做起来就非常麻烦。语言只是工具，我们还是要根据不同的场景选用更为合适的语言。&lt;/p>
&lt;p>那么 Go 语言和 Rust 语言的使用成本为什么是中等呢？因为我们不能只关注编写代码的效率，还要考虑运维和 Debug 的成本。Go 语言可能也会产生 Panic，我们内部也经常会有一些并发的问题，然后需要不断地排查。
而 Rust 语言前置了这部分成本，相比于其他语言框架在上线之后测试、保证稳定性，我们把这部分的时间精力用在了开发期间，这样也避免了线上事故带来的损失。因此我给 Go 语言和 Rust 语言评定的使用成本是中等。&lt;/p>
&lt;h3 id="rust--go">Rust &amp;amp; Go&lt;/h3>
&lt;p>如果将 Rust 语言和 Go 语言单独做对比，我们应该如何解读它们呢？这是一个非常经典的问题。可以尝试从以下四方面考虑：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>合作关系，取长补短&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>我们团队认为其实二者并不是对立关系，而是合作关系，它们是取长补短的。毕竟语言只是工具，很多时候我们只是需要一个更加得心应手的工具而已。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>(性能 &amp;raquo; 开发效率) || (安全性 &amp;raquo; 开发效率) -&amp;gt; Rust&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>对于需要极致性能，重计算的应用，以及需要稳定性并能接受一定开发速度损失的应用，推荐使用 Rust，Rust 在极致性能优化和安全性上的优势可以在这类应用中得以发挥。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>迭代速度要求高 -&amp;gt; Go&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>对于性能不敏感的应用、重 IO 的应用以及需要快速开发快速迭代胜过稳定性的应用，推荐使用 Go 语言，这种应用使用 Rust 并不会带来明显的收益。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>考虑团队技术储备和人才储备&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>当然，还有一个很重要的考虑因素，是团队现有的技术栈，即技术储备和人才储备。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>希望以上内容能让大家初步了解 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 以及相关的生态。目前 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 还处于早期发展阶段，欢迎各位感兴趣的同学加入我们，共同建设 CloudWeGo 以及 Rust 开源社区。
我们诚心期待更多开发者加入，也期待 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 能够助力越来越多的企业快速构建云原生架构。&lt;/p></description></item><item><title>Blog: 国内首个基于 Rust 语言的 RPC 框架 — Volo 正式开源！</title><link>https://www.cloudwego.io/zh/blog/2022/08/30/%E5%9B%BD%E5%86%85%E9%A6%96%E4%B8%AA%E5%9F%BA%E4%BA%8E-rust-%E8%AF%AD%E8%A8%80%E7%9A%84-rpc-%E6%A1%86%E6%9E%B6-volo-%E6%AD%A3%E5%BC%8F%E5%BC%80%E6%BA%90/</link><pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/08/30/%E5%9B%BD%E5%86%85%E9%A6%96%E4%B8%AA%E5%9F%BA%E4%BA%8E-rust-%E8%AF%AD%E8%A8%80%E7%9A%84-rpc-%E6%A1%86%E6%9E%B6-volo-%E6%AD%A3%E5%BC%8F%E5%BC%80%E6%BA%90/</guid><description>
&lt;p>&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 是字节跳动服务框架团队研发的&lt;strong>轻量级&lt;/strong>、&lt;strong>高性能&lt;/strong>、 &lt;strong>可扩展性强&lt;/strong>、&lt;strong>易用性好&lt;/strong>的 Rust RPC 框架，使用了 Rust 最新的 GAT 和 TAIT 特性。&lt;/p>
&lt;p>在字节内部，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 已经落地多个业务和基础组件，并且取得了超预期的性能收益（与 Go 版本对比，不那么公平）。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 与其它 CloudWeGo 开源项目一样，坚持内外维护一套代码，为开源使用提供了强有力的保障。同时，我们观察到 Rust 开源社区在 RPC 框架这块还比较薄弱，
&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 的开源希望能为社区的完善贡献一份力量，同时也能完善 CloudWeGo 生态矩阵，为追求性能、安全性和最新技术的开发者、企业以及 Rustaceans 开发 RPC 微服务、搭建云原生分布式系统提供强有力的支持。&lt;/p>
&lt;p>本文会为大家简单介绍 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 及其相关生态，并为大家提供一个简单的 Rust 与 Go 的选型建议。&lt;/p>
&lt;h2 id="01-项目缘起">01 项目缘起&lt;/h2>
&lt;p>其实 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 的创始成员来自于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 团队（CloudWeGo 开源的 Go RPC 框架），当时我们在 Go 上做了非常深度的性能优化，也因此深刻感受到了在 Go 上做性能优化所面临的阻碍。
因此，我们选择了 Rust，期望能够给需求极致性能、安全和指令级掌控能力的业务一个合适的选择。而 RPC 框架是分布式系统中重要的组成部分，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 就这么诞生了。&lt;/p>
&lt;h2 id="02-特性">02 特性&lt;/h2>
&lt;h3 id="高性能">高性能&lt;/h3>
&lt;p>Rust 以高性能和安全著称，我们在设计和实现过程中也时刻以高性能作为我们的目标，尽可能降低每一处的开销，提升每一处实现的性能。&lt;/p>
&lt;p>首先要说明，&lt;strong>和 Go 的框架对比性能是极不公平的&lt;/strong>，因此我们不会着重比较 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的性能，并且我们给出的数据仅能作为参考，希望大家能够客观看待。
同时，由于在开源社区并没有找到另一款成熟的 Rust 语言的 Async 版本 Thrift RPC 框架，而且性能对比总是容易引战，因此我们希望尽可能弱化性能数据的对比，仅会公布我们自己极限 QPS 的数据。&lt;/p>
&lt;p>在和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 相同的测试条件（限制 4C）下，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 极限 QPS 为 35W。同时，我们内部正在验证基于 &lt;a href="https://github.com/bytedance/monoio">Monoio&lt;/a>（CloudWeGo 开源的 Rust Async Runtime）的版本，极限 QPS 可以达到 44W。&lt;/p>
&lt;p>从我们线上业务的火焰图来看，得益于 Rust 的静态分发和优秀的编译优化，框架部分的开销基本可以忽略不计（不包含 syscall 开销）。&lt;/p>
&lt;h3 id="基于-gat-设计">基于 GAT 设计&lt;/h3>
&lt;p>我们热爱并追随最新的技术，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 的核心抽象使用了 Rust 最新的 GAT 特性，在这个过程中我们也借鉴了 &lt;strong>Tower&lt;/strong> 的设计。Tower 是一个非常优秀的抽象层设计，适用于非 GAT 的情况下。在此我们非常感谢 Tower 团队。&lt;/p>
&lt;p>Tower：https://github.com/tower-rs/tower&lt;/p>
&lt;p>通过 GAT，我们可以避免很多不必要的 Box 内存分配，以及提升易用性，给用户提供更友好的编程接口和更符合人体工程学的编程范式。&lt;/p>
&lt;p>我们的核心抽象如下：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_volo/1.png" alt="image">&lt;/p>
&lt;p>由于使用了 Rust 的 GAT 特性，因此我们可以解决返回异步 Future 带来的生命周期问题。同时，如果配合 &lt;code>type_alias_impl_trait&lt;/code> 使用，效果更佳，比如实现 Timeout 可以使用如下方式：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_volo/2.png" alt="image">&lt;/p>
&lt;h3 id="易用性好">易用性好&lt;/h3>
&lt;p>Rust 以难学难用而闻名，我们希望尽可能降低用户使用 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 框架以及使用 Rust 语言编写微服务的难度，提供最符合人体工程学和直觉的编码体验。因此，我们把易用性作为我们重要的目标之一。&lt;/p>
&lt;p>比如，我们提供了 Volo 命令行工具，用于初始化项目以及管理 IDL。同时，我们将 Thrift 及 gRPC 拆分为两个独立（但共用一些组件）的框架，以提供最符合不同协议语义的编程范式及接口。&lt;/p>
&lt;p>我们还提供了 &lt;code>#[service]&lt;/code> 宏（可以理解为不需要 &lt;code>Box&lt;/code> 的 &lt;code>async_trait&lt;/code>）来使得用户可以无心理负担地使用异步来编写 &lt;code>Service&lt;/code> 中间件。&lt;/p>
&lt;p>通过这个宏，我们编写 &lt;code>Service&lt;/code> 中间件可以简化到如下图：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/opensource_volo/3.png" alt="image">&lt;/p>
&lt;h3 id="扩展性强">扩展性强&lt;/h3>
&lt;p>受益于 Rust 强大的表达和抽象能力，通过灵活的中间件 Service 抽象，开发者可以以非常统一的形式，对 RPC 元信息、请求和响应做处理。&lt;/p>
&lt;p>比如，服务发现、负载均衡等服务治理功能，都可以以 Service 形式进行实现，而不需要独立实现 Trait。&lt;/p>
&lt;p>相关的扩展，我们会放在 github.com/volo-rs 组织下，也欢迎大家贡献自己的扩展到 volo-rs。&lt;/p>
&lt;h2 id="03-生态系统">03 生态系统&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 是 RPC 框架的名字，随着 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 一起开源的有以下几个项目：&lt;/p>
&lt;ol>
&lt;li>Volo-rs：Volo 的相关生态。&lt;/li>
&lt;li>Pilota：Volo 使用的 Thrift 与 Protobuf 编译器及编解码的纯 Rust 实现（不依赖 protoc）。&lt;/li>
&lt;li>Motore：Volo 参考 Tower 设计的、使用了 GAT 和 TAIT 的 middleware 抽象层。&lt;/li>
&lt;li>Metainfo：Volo 用于进行元信息透传的组件，期望定义一套元信息透传的标准。&lt;/li>
&lt;/ol>
&lt;h2 id="04-选型建议">04 选型建议&lt;/h2>
&lt;p>“什么情况下应该用 Rust、什么情况下应该用 Go？”这是一个非常经典的问题。在 Volo 团队看来，Rust 和 Go 并不是对立关系，而是合作关系，取长补短。&lt;/p>
&lt;p>对于性能不敏感的应用、重 IO 的应用以及需要快速开发快速迭代胜过稳定性的应用，推荐使用 Go，这种应用使用 Rust 并不会带来明显的收益。&lt;/p>
&lt;p>对于 &lt;strong>需要极致性能&lt;/strong>，&lt;strong>重计算&lt;/strong>的应用，以及&lt;strong>需要稳定性并能接受一定开发速度损失&lt;/strong>的应用，推荐使用 Rust，Rust 在极致性能优化和安全性上的优势可以在这类应用中得以发挥。&lt;/p>
&lt;p>当然，还有一个很重要的考虑因素，是团队现有的技术栈，即技术储备和人才储备。&lt;/p>
&lt;h2 id="05-总结">05 总结&lt;/h2>
&lt;p>希望本文能让大家对于 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 及相关生态有一个基本的了解。同时，&lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 还处于早期阶段，欢迎各位感兴趣的同学一起加入，共同建设 CloudWeGo 及 Rust 开源社区，向 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 提交 Issue 和 PR 一起来共建。
我们诚心期待更多的开发者加入，也期待 &lt;a href="https://github.com/cloudwego/volo">Volo&lt;/a> 助力越来越多的企业快速构建云原生架构。如果企业客户想内部试用，我们可以排期提供专项技术支持和交流。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Volo 概览: &lt;a href="https://github.com/cloudwego/volo">https://github.com/cloudwego/volo&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Volo Tutorial: &lt;a href="https://www.cloudwego.io/zh/docs/volo/">https://www.cloudwego.io/zh/docs/volo/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Volo 文档: &lt;a href="https://docs.rs/volo">https://docs.rs/volo&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Volo-rs 组织: &lt;a href="https://github.com/volo-rs">https://github.com/volo-rs&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.3.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/08/29/hertz-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/08/29/hertz-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/182">#182&lt;/a>] feat: 添加服务注册 &amp;amp; 服务发现 &amp;amp; 负载均衡。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/6">[#6]&lt;/a> feat: 添加 zookeeper 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/7">[#7]&lt;/a> feat: 添加 nacos 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/8">[#8]&lt;/a> feat: 添加 Consul 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/9">[#9]&lt;/a> feat: 添加 polaris 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/14">[#14]&lt;/a> feat: 添加 etcd 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/15">[#15]&lt;/a> feat: 添加 servicecomb 服务注册与发现的扩展。&lt;/li>
&lt;li>&lt;a href="https://github.com/hertz-contrib/registry/pull/16">[#16]&lt;/a> feat: 添加 eureka 服务注册与发现的扩展。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/175">#175&lt;/a>] refactor: 区别全局默认 dialer 和 client 局部 dialer（指定了 dialer 的 client 不再受全局 dialer 改变而改变）修改全局 dialer 影响面较大，标记 deprecated，后续统一到 client 初始化时传参指定 dialer 方式修改局部 dialer，以及移除了功能完全被 dialer 覆盖的 dialFunc 扩展。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/205">#205&lt;/a>] optimize: 更改默认返回值。&lt;/li>
&lt;/ul>
&lt;h2 id="test">Test&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/174">#174&lt;/a>] test: 修正 TestRouterMiddlewareAndStatic 单测。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/190">#190&lt;/a>] fix: 修改同名的路由组。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/192">#192&lt;/a>] fix: 修复 handler 中的引用相同包名的问题，并把获取 unique 变量名的方法单独提出来。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/208">#208&lt;/a>] fix: 当服务停止时修复取消注册失败。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/202">#202&lt;/a>] fix: 获取到了错误的 IPv6 本地回环地址。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/196">#196&lt;/a>] fix: 修复 typo。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/155">#155&lt;/a>] fix: 修复thrift的命名方式，struct name 与 thriftgo 的 namestyle 保持一致。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/169">#169&lt;/a>] fix: 修复 thrift 的 namespace 尾缀包含&amp;quot;.thrift&amp;quot;的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/184">#184&lt;/a>] fix: 修复使用标准网络库劫持连接时的超时错误。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/162">#162&lt;/a>] fix: 修复 IDL 中定义的路由最后一级为&amp;quot;/&amp;ldquo;时的报错。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/189">#189&lt;/a>] 回滚 &lt;a href="https://github.com/cloudwego/hertz/pull/162">cloudwego/hertz#162&lt;/a> 的修改。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/203">#203&lt;/a>] AddMissingPort 函数增加对裸 v6 地址的处理。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/186">#186&lt;/a>] 支持 codecov。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.4.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/08/26/kitex-v0.4.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/08/26/kitex-v0.4.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="重要变更介绍">重要变更介绍&lt;/h2>
&lt;h3 id="功能">功能&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>重试功能增强&lt;/strong>：支持自定义结果重试；支持请求粒度配置重试，详见 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/basic-feature/retry/">重试指南&lt;/a>&lt;/li>
&lt;li>&lt;strong>Frugal(thrift)&lt;/strong>: 支持了 IDL 默认值；使用 Frugal 可以支持不生成编解码代码，详见 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/advanced-feature/codec_frugal/#2-%E5%B8%A6%E4%B8%8A--thrift-frugal_tag-%E5%8F%82%E6%95%B0%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90%E4%B8%80%E6%AC%A1%E4%BB%A3%E7%A0%81">frugal&lt;/a>&lt;/li>
&lt;li>&lt;strong>Tool-Protobuf&lt;/strong>：结合 go_package 配置支持依赖外部库，详见 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/code-gen/code_generation/#%E4%BD%BF%E7%94%A8-protobuf-idl-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">protobuf IDL 的注意事项&lt;/a>；支持从文件扩展名猜测 IDL 的类型，生成 proto 代码时无需再指定 type 参数&lt;/li>
&lt;li>&lt;strong>Fastpb(protobuf)&lt;/strong>: 支持 fastpb 优化 pb 编解码，并默认集成到 Kitex，详见 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/code-gen/fastpb/">fastpb&lt;/a>&lt;/li>
&lt;li>&lt;strong>泛化调用&lt;/strong>：支持 HTTP+Protobuf 泛化调用&lt;/li>
&lt;li>&lt;strong>Kitex 依赖库支持 Windows&lt;/strong>：便于 Windows 环境运行（工具暂未支持）&lt;/li>
&lt;/ol>
&lt;h3 id="优化和修复">优化和修复&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>性能优化&lt;/strong>：gRPC Unary 吞吐提升 46-70%，相比官方 gRPC 吞吐高 51%-70%，详见 &lt;a href="https://github.com/cloudwego/kitex-benchmark">benchmark &lt;/a>&lt;/li>
&lt;li>&lt;strong>泛化调用&lt;/strong>：HTTP / Map / JSON 泛化调用支持了 Thrift 默认值&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="详细变更">详细变更&lt;/h2>
&lt;h3 id="feature">Feature&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/571">#571&lt;/a>] 功能(protobuf): 默认集成 &lt;a href="https://github.com/cloudwego/fastpb">fastpb&lt;/a> 到 Kitex，详情参考 &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/code-gen/fastpb/">doc&lt;/a>。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/592">#592&lt;/a>] 功能(generic): HTTP/Map/JSON 泛化调用支持 Thrift 默认值。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/600">#600&lt;/a>] 功能(thrift): 支持当使用 frugal 时不生成编解码代码。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/607">#607&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/610">#610&lt;/a>] 功能(proxyless): 提供 xDS 扩展的接口。支持基于 xDS 的流量路由，超时配置及服务发现。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/541">#541&lt;/a>] 功能(trans): 传输层增加 go net 作为扩展，并在 Windows OS 下作为默认网络库。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/540">#540&lt;/a>] 功能(retry): Retry 支持指定 error 或 resp 重试，同时新增 option 用来支持为方法设置重试策略。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/533">#533&lt;/a>] 功能(generic): 泛化调用 js_conv 注解支持 map 类型转换。&lt;/li>
&lt;/ul>
&lt;h3 id="optimize">Optimize&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/522">#522&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/538">#538&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/605">#605&lt;/a>] 优化(grpc): 优化 gRPC 协议性能。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/590">#590&lt;/a>] 优化(tool): 支持从文件扩展名猜测 IDL 的类型。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/559">#559&lt;/a>] 优化(timeout): 在超时中间件中使用超时封装方法判断底层超时，用来忽略一些定制超时错误日志。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/581">#581&lt;/a>] 优化(tool): Kitex 命令增加使用示例。&lt;/li>
&lt;/ul>
&lt;h3 id="bugfix">Bugfix&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/564">#564&lt;/a>] 修复(oneway): 当 oneway 请求发送完毕后，关闭对应的连接，否则后续的发送到该连接上的请求会被阻塞在 server 端，直到 server 端把上一个 oneway 请求处理完。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/577">#577&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/584">#584&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/602">#602&lt;/a>] 修复(rpcinfo): 修复长连接场景下 rpcinfo 复用问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/578">#578&lt;/a>] 修复: 修复 long pool dump 可能导致 panic 的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/583">#583&lt;/a>] 修复(tool): 修复 protobuf 生成代码引用了错误的 package 名字的问题&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/587">#587&lt;/a>] 修复(tool): 生成代码的时候跳过指定了外部 import path 的 proto 文件。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/594">#594&lt;/a>] 修复(generic): 泛化调用支持单引号中双引号带转义符的 tag 格式以兼容旧版本逻辑。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/595">#595&lt;/a>] 修复: 修复 union 为 nil 时 BLength 会 panic 的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/589">#589&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/596">#596&lt;/a>] 修复(frugal): 修复 frugal build tag。&lt;/li>
&lt;/ul>
&lt;h3 id="refactor">Refactor&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/566">#566&lt;/a>] refactor(metainfo): 移除 HTTP2 header 中没有使用的 meta keys。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/593">#593&lt;/a>] refactor(trans): 服务端支持通过 WithListener 配置 listener，其优先级高于 WithServiceAddr。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/582">#582&lt;/a>] refactor(tool): kitex 工具以文件嵌入方式使用模板并导出部分 API 供外部使用。&lt;/li>
&lt;/ul>
&lt;h3 id="test">Test&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/579">#579&lt;/a>] test: 长连接池 dump 增加单测。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/608">#608&lt;/a>] test: 修复 TestClientConnDecoupledFromApplicationRead 的 data race 问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/609">#609&lt;/a>] test: 修复 gonet 单测中的端口冲突问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/480">#480&lt;/a>] test: 给 client package 增加单测。&lt;/li>
&lt;/ul>
&lt;h3 id="chore">Chore&lt;/h3>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/558">#558&lt;/a>] ci: 修复 ci 中 setup-python 的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/487">#487&lt;/a>] ci: Workflow 中增加 golangci-lint。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/580">#580&lt;/a>] chore: 修复 remote 模块中 go net 相关的错误拼写。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/601">#601&lt;/a>] chore: 修复错误拼写并替换掉一些功能重复的代码。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/604">#604&lt;/a>] chore: 升级 fastpb 到 v0.0.2。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/603">#603&lt;/a>] chore: 升级 frugal 到 v0.1.2。&lt;/li>
&lt;/ul>
&lt;h3 id="dependency-change">Dependency Change&lt;/h3>
&lt;p>github.com/cloudwego/frugal v0.1.1 -&amp;gt; v0.1.3&lt;/p>
&lt;p>github.com/cloudwego/netpoll v0.2.5 -&amp;gt; v0.2.6&lt;/p>
&lt;p>github.com/cloudwego/thriftgo v0.1.2 -&amp;gt; v0.2.0&lt;/p>
&lt;p>google.golang.org/protobuf v1.26.0 -&amp;gt; v1.28.0&lt;/p>
&lt;p>github.com/choleraehyq/pid v0.0.13 -&amp;gt; v0.0.15&lt;/p>
&lt;p>新增&lt;/p>
&lt;p>github.com/cloudwego/fastpb v0.0.2&lt;/p>
&lt;p>github.com/jhump/protoreflect v1.8.2&lt;/p></description></item><item><title>Blog: Hertz v0.2.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/07/22/hertz-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/07/22/hertz-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/124">#124&lt;/a>] feat: 增加参数控制是否使用 hijackConnPool。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/116">#116&lt;/a>] feat: update 也可使用模板更新 handler 及 middleware。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/130">#130&lt;/a>] feat: 如果 Cookie.Value 中存在非法字符，则打印告警日志。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/143">#143&lt;/a>] feat: 增加一个接口支持自定义信号捕捉逻辑，以便根据场景调节优雅退出需要应对的信号类型。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/114">#114&lt;/a>] feat: 标准网络库 Read 方法中调用 connection.Release()，防止在多次少量调用 Read 方法时不回收内存导致的 OOM。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/112">#112&lt;/a>] feat: 修正了 x-www-form-urlencoded 编码下无法读到 bodystream 类型数据。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/105">#105&lt;/a>] feat: client 为 ALPN 和 http2 抽象出协议层 HostClient。client 删除 readbuffersize 和 writebuffersize 配置项。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/92">#92&lt;/a>] feat: hz 命名行工具支持 windows。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/102">#102&lt;/a>] feat: Hertz client 关闭默认的重试逻辑。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/111">#111&lt;/a>] optimize: 调用 bytesconv.AppendHTTPDate 时，为切片预分配容量，以防止产生额外的拷贝。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/128">#128&lt;/a>] optimize: 去掉路由树中无用逻辑。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/108">#108&lt;/a>] optimize: 通过提前调用 regexp.MustCompile，避免程序重复解析正则表达式。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/125">#125&lt;/a>] chore: 更新 license check 方式。&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/104">#104&lt;/a>] fix: cacheLock 可能会因潜在发生的 panic 导致解锁失败。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/96">#96&lt;/a>] fix: ci 可能被调度到 arm 机器上导致报错 exec format error。&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/103">#103&lt;/a>] style: 修正不符合语义的错误拼写 “Ungzipped”。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/90">#90&lt;/a>] style: 常量替换和去掉了重复的类型转换。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/94">#94&lt;/a>] refactor: 使用 appendCookiePart 函数简化代码。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/97">#97&lt;/a>] docs: 文档标点符号优化。&lt;/li>
&lt;/ul></description></item><item><title>Blog: 字节跳动开源 Go HTTP 框架 Hertz 设计实践</title><link>https://www.cloudwego.io/zh/blog/2022/06/21/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BC%80%E6%BA%90-go-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/21/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BC%80%E6%BA%90-go-http-%E6%A1%86%E6%9E%B6-hertz-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="01-前言">01 前言&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 是字节跳动服务框架团队研发的超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。在经过了字节跳动内部一年多的使用和迭代后，如今已在 CloudWeGo 正式开源。
目前，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万。除了各个业务线的同学使用外，也服务于内部很多基础组件，
如：函数计算平台 FaaS、压测平台、各类网关、Service Mesh 控制面等，均收到不错的使用反馈。在如此大规模的场景下，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 拥有极强的稳定性和性能，在内部实践中某些典型服务，
如框架占比较高的服务、网关等服务，迁移 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后相比 Gin 框架，资源使用显著减少，CPU 使用率随流量大小降低 30%—60%，时延也有明显降低。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 坚持 &lt;strong>内外维护一套代码&lt;/strong> ，为开源使用提供了强有力的保障。通过开源， &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也将丰富云原生的 Golang 中间件体系，完善 CloudWeGo 生态矩阵，
为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。&lt;/p>
&lt;p>本文将重点关注 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的&lt;strong>架构设计&lt;/strong>与 &lt;strong>功能特性&lt;/strong> 。&lt;/p>
&lt;h2 id="02-项目缘起">02 项目缘起&lt;/h2>
&lt;p>最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。随着内部业务的不断发展，高性能、多场景的需求日渐强烈。
而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。因此，为了满足业务需求，更好的服务各大业务线，
2020 年初，字节跳动服务框架团队经过内部使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，开始基于自研网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 开发内部框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，
让 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。&lt;/p>
&lt;h2 id="03-架构设计">03 架构设计&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 设计之初调研了大量业界优秀的 HTTP 框架，同时参考了近年来内部实践中积累的经验。为了保证框架整体上满足：1. 极致性能优化的可能性；2. 面对未来不可控需求的扩展能力，
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 采用了 4 层分层设计，保证各个层级功能内聚，同时通过层级之间的接口达到灵活扩展的目标。整体架构图如图 1 所示。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hertz_Architectural.png" alt="image">&lt;/p>
&lt;p align="center">
图1 Hertz 架构图
&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 从上到下分为：应用层、路由层、协议层和传输层，每一层各司其职，同时公共能力被统一抽象到公共层（Common），做到跨层级复用。
另外，同主库一同发布的还有作为子模块的 Hz 脚手架，它能够协助使用者快速搭建出项目核心骨架以及提供实用的构建工具链。&lt;/p>
&lt;h3 id="应用层">应用层&lt;/h3>
&lt;p>应用层是和用户直接交互的一层，提供丰富易用的 API，主要包括 Server、Client 和一些其他通用抽象。Server 提供了注册 HandlerFunc、Binding、Rendering 等能力；Client 提供了调用下游和服务发现等能力；
以及抽象一个 HTTP 请求所必须涉及到的请求（Request）、响应（Response）、上下文（RequestContext）、中间件（Middleware）等等。 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的 Server 和 Client 都能够提供中间件这样的扩展能力。&lt;/p>
&lt;p>应用层中一个非常重要的抽象就是对 Server HandlerFunc 的抽象。早期，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 路由的处理函数 （HandlerFunc）中并没有接收标准的 context.Context，我们在大量的实践过程中发现，
业务方通常需要一个标准的上下文在 RPC Client 或者日志、Tracing 等组件间传递，但由于请求上下文（RequestContext）生命周期局限于一次 HTTP 请求之内，而以上提到的场景往往存在异步的传递和处理，
导致如果直接传递请求上下文，会导致出现一些数据不一致的问题。为此我们做了诸多尝试，但是因为核心原因在于请求上下文（RequestContext）的生命周期无法优雅的按需延长，
最终在各种设计权衡下，我们在路由的处理函数签名中增加一个标准的上下文入参，通过分离出生命周期长短各异的两个上下文的方式，从根本上解决各种因为上下文生命周期不一致导致的异常问题，即：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/RequestContext.png" alt="image">&lt;/p>
&lt;h3 id="路由层">路由层&lt;/h3>
&lt;p>路由层负责根据 URI 匹配对应的处理函数。&lt;/p>
&lt;p>起初，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的路由基于 &lt;a href="https://github.com/julienschmidt/httprouter">httprouter&lt;/a> 开发，但随着使用的用户越来越多，&lt;a href="https://github.com/julienschmidt/httprouter">httprouter&lt;/a> 渐渐不能够满足需求，主要体现在 &lt;a href="https://github.com/julienschmidt/httprouter">httprouter&lt;/a> 不能够同时注册静态路由和参数路由，
即 &lt;code>/a/b&lt;/code>， &lt;code>/:c/d&lt;/code> 这两个路由不能够同时注册；甚至有一些更特殊的需求，如 &lt;code>/a/b&lt;/code>、&lt;code>/:c/b&lt;/code> ，当匹配 &lt;code>/a/b&lt;/code> 路由时，两个路由都能够匹配上。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 为满足这些需求重新构造了路由树，用户在注册路由时拥有很高的自由度：支持静态路由、参数路由的注册；支持按优先级匹配，如上述例子会优先匹配静态路由 &lt;code>/a/b&lt;/code>；支持路由回溯，
如注册 &lt;code>/a/b&lt;/code>、&lt;code>/:c/d&lt;/code>，当匹配 &lt;code>/a/d&lt;/code> 时仍然能够匹配上；支持尾斜线重定向，如注册 &lt;code>/a/b&lt;/code>，当匹配 &lt;code>/a/b/&lt;/code> 时能够重定向到 &lt;code>/a/b&lt;/code> 上。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了丰富的路由能力来满足用户的需求，更多的功能可以参考 &lt;a href="https://www.cloudwego.io/zh/docs/hertz/reference/config/">Hertz 配置文档&lt;/a>。&lt;/p>
&lt;h3 id="协议层">协议层&lt;/h3>
&lt;p>协议层负责不同协议的实现和扩展。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 支持&lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/framework-exten/advanced-exten/protocol/">协议的扩展&lt;/a>，用户只需要实现下面的接口便可以按照自己的需求在引擎（Engine）上扩展协议，
同时也支持通过 ALPN 协议协商的方式注册。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 首批只开源了 HTTP1 实现，未来会陆续开源 HTTP2、QUIC 等实现。
协议层扩展提供的灵活性甚至可以超越 HTTP 协议的范畴，用户完全可以按需注册任意符合自身需求的协议层实现，并且加入到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的引擎中来，同时，也能够无缝享受到传输层带来的极致性能。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Server.png" alt="image">&lt;/p>
&lt;h3 id="传输层">传输层&lt;/h3>
&lt;p>传输层负责底层的网络库的抽象和实现。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 支持底层网络库的扩展。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 原生完美适配 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，在时延方面有很多深度的优化，非常适合时延敏感的业务接入。&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 对 TLS 能力的支持有待完善，而 TLS 能力又是 HTTP 框架必备能力，
为此 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 底层同时支持基于 Golang 标准网络库的实现适配，同时支持网络库的一键切换，用户可根据自己的需求选择合适的网络库进行替换。如果用户有更加高效的网络库或其他网络库需求，也完全可以根据需求自行扩展。&lt;/p>
&lt;p>&lt;strong>网络库的扩展&lt;/strong>：
&lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/framework-exten/advanced-exten/network-lib/">https://www.cloudwego.io/zh/docs/hertz/tutorials/framework-exten/advanced-exten/network-lib/&lt;/a>&lt;/p>
&lt;h3 id="hz-脚手架">Hz 脚手架&lt;/h3>
&lt;p>与 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 一并开源的还有一个易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，让 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 达到开箱即用的状态；
Hz 也支持基于 IDL 的更新能力，能够基于 IDL 变动智能地更新项目代码。目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。
同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果默认模板不能够满足需求，完全能够按需定义。&lt;/p>
&lt;p>未来，我们将继续迭代 Hz，持续集成各种常用的中间件，提供更高层面的模块化构建能力。给 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的用户提供按需调整的能力，通过灵活的自定义配置打造一套满足自身开发需求的脚手架。&lt;/p>
&lt;h3 id="common-组件">Common 组件&lt;/h3>
&lt;p>Common 组件主要存放一些公共的能力，比如错误处理、单元测试能力、可观测性相关能力（Log、Trace、Metrics 等）。对于服务可观测性的能力，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了默认的实现，用户可以按需装配；
如果用户有特殊的需求，也可以通过 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供的接口注入。比如对于 Trace 能力，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了默认的实现，也提供了将 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 串起来的 Example。如果想注入自己的实现，也可以实现下面的接口：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Common.png" alt="image">&lt;/p>
&lt;p>&lt;strong>Example&lt;/strong>：
&lt;a href="https://github.com/cloudwego/hertz-examples/blob/main/tracer/README.md">https://github.com/cloudwego/hertz-examples/blob/main/tracer/README.md&lt;/a>&lt;/p>
&lt;h2 id="04-功能特性">04 功能特性&lt;/h2>
&lt;h3 id="中间件">中间件&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 除了提供 Server 的中间件能力，还提供了 Client 中间件能力。用户可以使用中间件能力将通用逻辑（如：日志记录、性能统计、异常处理、鉴权逻辑等等）和业务逻辑区分开，让用户更加专注于业务代码。
Server 和 Client 中间件使用方式相同，使用 Use 方法注册中间件，中间件执行顺序和注册顺序相同，同时支持预处理和后处理逻辑。&lt;/p>
&lt;p>Server 和 Client 的中间件实现方式并不相同。对于 Server 来说，我们希望减少栈的深度，同时也希望中间件能够默认的执行下一个，用户需要手动终止中间件的执行。
因此，我们将 Server 的中间件分成了两种类型，即不在同一个函数调用栈（该中间件调用完后返回，由上一个中间件调用下一个中间件，如图 2 中 B 和 C）和在同一个函数调用栈的中间件（该中间件调用完后由该中间件继续调用下一个中间件，如图 2 中 C 和 Business Handler）。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Middleware.png" alt="image">&lt;/p>
&lt;p align="center">
图2 中间件链路
&lt;/p>
&lt;p>其核心是需要一个地方存下当前的调用位置 index，并始终保持其递增。恰好 RequestContext 就是一个存储 index 合适的位置。
但是对于 Client，由于没有合适的地方存储 index，我们只能退而求其次，抛弃 index 的实现，将所有的中间件构造在同一调用链上，需要用户手动调用下一个中间件。&lt;/p>
&lt;h3 id="流式处理">流式处理&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供 Server 和 Client 的流式处理能力。HTTP 的文件场景是十分常见的场景，除了 Server 侧的上传场景之外，Client 的下载场景也十分常见。
为此，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 支持了 Server 和 Client 的流式处理。在内部网关场景中，从 Gin 迁移到 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后，CPU 使用量随流量大小不同可节省 30%—60% 不等，服务压力越大，收益越大。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开启流式功能的方式也很容易，只需要在 Server 上或 Client 上添加一个配置即可，可参考 CloudWeGo 官网 Hertz 文档的&lt;a href="https://www.cloudwego.io/zh/docs/hertz/tutorials/basic-feature/stream/">流式处理&lt;/a>部分。&lt;/p>
&lt;p>由于 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 采用 LT 的触发模式，由网络库主动将将数据从 TCP 缓冲区读到用户态，并存储到 buffer 中，否则 epoll 事件会持续触发。
因此 Server 在超大请求的场景下，由于 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 持续将数据读到用户态内存中，可能会有 OOM 的风险。HTTP 文件上传场景就是一个典型的场景，但 HTTP 上传服务又是很常见的场景，
因此我们支持标准网络库 go net，并针对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 做了特殊优化，暴露出 Read() 接口，防止 OOM 发生。&lt;/p>
&lt;p>对于 Client，情况并不相同。流式场景下会将连接封装成 Reader 暴露给用户，而Client 有连接池管理，那这样连接就多了一种状态，何时关连接，何时复用连接成了一个问题。
由于框架侧并不知道该连接何时会用完，框架侧复用该连接不现实，会导致串包问题。由于 GC 会关闭连接，因此我们起初设想流式场景下的连接交由用户后，由 GC 负责关闭，这样也不会导致资源泄漏。
但是在测试后发现，由于 GC 存在一定时间间隔，另外 TCP 中主动关闭连接的一方需要等待 2RTT，在高并发场景下会导致 fd 被打满的情况。
最终我们提供了复用连接的接口，对于性能有场要求用户，在使用完连接后可以将连接重新放入连接池中复用。&lt;/p>
&lt;h2 id="05-性能表现">05 性能表现&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 使用字节跳动自研高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，在提高网络库效率方面有诸多实践，参考已发布文章 &lt;strong>字节跳动在 Go 网络库上的实践&lt;/strong> 。
除此之外，&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 还针对 HTTP 场景进行优化，通过减少拷贝和系统调用次数提高吞吐以及降低时延。为了衡量 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 性能指标，我们选取了社区中有代表性的框架 Gin（net/http）和 Fasthttp 作为对比，如图3所示。
可以看到，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的极限吞吐、TP99 等指标均处于业界领先水平。未来，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 还将继续和 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 深度配合，探索 HTTP 框架性能的极限。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Fasthttp.png" alt="image">&lt;/p>
&lt;p align="center">
图3 Hertz 和其他框架性能对比
&lt;/p>
&lt;h2 id="06-一个demo">06 一个Demo&lt;/h2>
&lt;p>下面简单演示一下 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 是如何开发一个服务的。&lt;/p>
&lt;ol>
&lt;li>首先，定义 IDL，这里使用 Thrift 作为 IDL 的定义（也支持使用 Protobuf 定义的 IDL），编写一个名为 Demo 的 service。这个服务有一个 API: Hello，它的请求参数是一个 query，响应是一个包含一个 RespBody 字段的 Json。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hello.png" alt="image">&lt;/p>
&lt;ol start="2">
&lt;li>接下来我们使用 Hz 生成代码，并整理和拉取依赖。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hz.png" alt="image">&lt;/p>
&lt;ol start="3">
&lt;li>填充业务逻辑，比如我们返回 &lt;code>hello，${Name}&lt;/code>，那我们在 &lt;code>biz/handler/example/hello_service.go&lt;/code> 中添加以下代码即可。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hello_service.png" alt="image">&lt;/p>
&lt;ol start="4">
&lt;li>编译并运行项目。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Build.png" alt="image">&lt;/p>
&lt;p>到现在一个简单的 Hertz 项目已经生成，下面我们来测试一下。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Go_HTTP_Hertz/Hertz-Examples.png" alt="image">&lt;/p>
&lt;p>以上 Demo 可以在 &lt;a href="https://github.com/cloudwego/hertz-examples">Hertz-Examples&lt;/a> 中查看，之后就可以愉快地构建自己的项目了。&lt;/p>
&lt;h2 id="07-后记">07 后记&lt;/h2>
&lt;p>希望以上的分享能够让大家对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 有一个整体上的认识。同时，我们也在不断地迭代 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>、完善CloudWeGo 整体生态。欢迎各位感兴趣的同学们加入我们，共同建设 CloudWeGo。&lt;/p>
&lt;h2 id="08-参考资料">08 参考资料&lt;/h2>
&lt;p>&lt;strong>Hertz Doc&lt;/strong>：https://www.cloudwego.io/zh/docs/hertz/&lt;/p>
&lt;p>官网文章：&lt;a href="https://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/">&lt;strong>字节跳动在 Go 网络库上的实践&lt;/strong> &lt;/a>&lt;/p></description></item><item><title>Blog: 超大规模的企业级微服务 HTTP 框架 — Hertz 正式开源！</title><link>https://www.cloudwego.io/zh/blog/2022/06/21/%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1-http-%E6%A1%86%E6%9E%B6-hertz-%E6%AD%A3%E5%BC%8F%E5%BC%80%E6%BA%90/</link><pubDate>Tue, 21 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/21/%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E7%9A%84%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1-http-%E6%A1%86%E6%9E%B6-hertz-%E6%AD%A3%E5%BC%8F%E5%BC%80%E6%BA%90/</guid><description>
&lt;p>今天，经过了字节跳动内部一年多的使用和迭代，高性能企业级 HTTP 框架—— &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，已在 CloudWeGo 正式开源啦！&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 已经成为了字节跳动内部最大的 HTTP 框架，线上接入的服务数量超过 &lt;strong>1 万&lt;/strong>，
峰值 QPS 超过 &lt;strong>4 千万&lt;/strong>，具有 &lt;strong>高易用性&lt;/strong> 、 &lt;strong>易扩展&lt;/strong> 、&lt;strong>低时延&lt;/strong>的特点。对于字节跳动服务框架团队和 CloudWeGo 而言，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 将不仅仅是一个开源项目，它也是一个真实的超大规模企业级实践。&lt;/p>
&lt;p>&lt;strong>项目地址：https://github.com/cloudwego/hertz&lt;/strong>&lt;/p>
&lt;p>未来，字节跳动基础架构团队将以 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开源库为主进行迭代，坚持内外维护一套代码，统一进行迭代演进，为用户提供更好的体验。&lt;/p>
&lt;h2 id="01-hertz-概述">01 Hertz 概述&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 是一个超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。
随着内部业务的不断发展，对高性能、多场景的需求日渐强烈。而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。
因此，为了满足业务需求，更好的服务各大业务线，2020 年初，字节跳动服务框架团队经过内部对使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，
开始基于自研网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 开发内部框架 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>，让 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。
2021 年 7 月，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 正式上线 1.0 版本。&lt;/p>
&lt;p>在经历了字节跳动内部一年多的使用后，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架成为了字节跳动内部最大的 HTTP 框架，&lt;strong>线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万&lt;/strong>。
&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 除了业务线的同学使用外，也服务于内部很多基础组件，如：函数计算平台 FaaS、压测平台、各类网关、Service Mesh 控制面等，均收到不错的使用反馈。
在如此大规模的场景下，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 拥有极强的稳定性和性能，bug 和 kernel case 也几乎暴露无遗并进行修复。同时 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 坚持的内外维护一套代码，也为开源出去的 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 框架提供了强有力的保障。&lt;/p>
&lt;p>下面是 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的一些特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>稳定性&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在如此大规模的场景下，每一个 PR 的合入、每一次发版都要慎之又慎，稍有不慎便可能造成千万甚至更多的损失。我们制定了规范的 PR、发版流程，每次合入代码需要由有经验的同学审核。
即便如此，为了降低风险，我们也搭建了各种测试场景，包括兼容性、高并发、大小包等场景，每次的 PR、发版都需要测试一段时间，充分测试，将每次发版的风险减少到最低。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>高易用性&lt;/strong>&lt;/p>
&lt;p>在开发过程中，快速写出正确的代码往往是重要的。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在设计 API 时，考虑到用户的使用习惯，参考业界主流框架使用 API 的方式，并加以优化。在 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在迭代过程中，积极听取用户意见，持续打磨框架，
比如很多用户希望 Client 也有 Trace 的能力，为此，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> Client 支持了中间件能力；在代理场景中，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> Client 也支持了流式处理。
在做中间件和流式处理设计时，也考虑到用户实际使用习惯，帮助用户更快地写出正确的代码。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 也提供了命令行工具，一键生成代码，提高框架的易用性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>易扩展&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 采用了分层设计，提供了较多的接口以及默认的扩展实现，用户也可以自行扩展，详情可参考 CloudWeGo 官网的 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 扩展部分。
同时得益于框架的分层设计，框架的扩展性也会大很多。目前仅将稳定的能力开源给社区，更多的规划参考 RoadMap。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>低延时&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 默认使用自研的高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，在一些特殊场景中，相较于 go net，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 在 QPS、时延上均具有一定优势。关于性能数据，可参考下图 Echo 数据。
在内部实践中，某些典型服务，如框架占比较高的服务、网关等服务，迁移 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 后相比 Gin 框架，资源使用显著减少，&lt;strong>CPU 使用率随流量大小降低 30%—60%。&lt;/strong>
关于详细的性能数据，可参考：https://github.com/cloudwego/hertz-benchmark。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Hertz_Open_Source/Echo.png" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>命令行工具&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提供了一个简单易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，开箱即用使用 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a>；Hz 也提供更新能力，用户的 IDL 如果发生改变，Hz 可以更新脚手架。
目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。
同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果觉得默认模板不能够满足的需求，可以自定义生成的模板。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>自 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 发布以来，内部反响优异。在内部，除最常见的前后端通信场景外，还涉及网关、上传、下载、代理等场景；所用到的交互模式除 ping-pong 外，还有 streaming、chunk 等；
使用的协议除 HTTP1 外，还有 HTTP2、Websocket 等。这些复杂的交互场景和交互模式都对 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的 Server 和 Client 的可用性和稳定性提出了不小的挑战。
为此，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 快速响应用户需求；搭建稳定性测试服务尽可能模拟线上真实复杂场景；较高的单测覆盖率保证代码逻辑正常。&lt;/p>
&lt;h2 id="02-内外版本维护">02 内外版本维护&lt;/h2>
&lt;p>字节跳动内部有着完善的微服务体系，团队非常重视开源建设和承诺，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 和 CloudWeGo 中的开源项目 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 相同，&lt;strong>保持内外一致&lt;/strong>，项目的核心能力均迁移至开源库中，
在内部仅封装一层壳帮助企业内无感升级，以保证对开源长期维护的承诺，并且&lt;strong>所有开源特性，都会在内部的稳定性验证后才会开源出来&lt;/strong>。&lt;/p>
&lt;p>后续，团队将持续以 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 开源库为主进行迭代，及时响应社区需求与问题，为用户提供更好的体验和使用保障。&lt;/p>
&lt;p>对于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 的开发者来说，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 同样支持对框架进行灵活的扩展，以适应业务需求。我们也欢迎外部的开发者将自己的贡献提交到社区当中，在社区进行开源共建，共同打造一款有着完善生态、极致性能和高易用性的 HTTP 框架。&lt;/p>
&lt;h2 id="03-roadmap">03 RoadMap&lt;/h2>
&lt;p>对于基础架构团队而言，&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 不仅仅是一个开源项目，它也是一个&lt;strong>真实的超大规模企业级实践项目&lt;/strong>。通过开源，我们希望 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 能丰富云原生社区的 Golang 中间件体系，
完善 CloudWeGo 生态矩阵，为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。&lt;/p>
&lt;p>如前文所述，目前 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 只开源了内部经过稳定性验证的部分，未来，我们会进一步推动其走向完善：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>云原生能力支持&lt;/strong>。支持 xDS API，从 Istio 动态获取服务配置。&lt;/li>
&lt;li>&lt;strong>多协议的支持&lt;/strong>。&lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 目前只开源了 HTTP1 的部分，未来我们还会开源其他协议，如：HTTP2、Websocket、ALPN 等，为开发者提供更多场景的微服务需求支持。如果有需求也可以提交 issue 告诉我们，让我们知道您的需求以便快速支持。&lt;/li>
&lt;li>&lt;strong>更好用的命令行工具&lt;/strong>。我们将继续迭代 Hz，持续集成各种常用的中间件，提供模块化构建能力，用户可以按需选择所需组件。&lt;/li>
&lt;li>&lt;strong>更完善的生态支持&lt;/strong>。由于 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 没有采用 go net 的数据结构，需要更多的生态支持。第一批开源我们只开源了 CORS、Trace、Metrics 等生态。未来我们还将支持包括反向代理、Session 等生态。&lt;/li>
&lt;li>&lt;strong>结合内外部用户需求，持续迭代&lt;/strong>。项目开源后，我们也会根据开发者需求开展迭代。&lt;/li>
&lt;/ul>
&lt;p>欢迎大家向 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 提交 issue 和 PR 一起来共建。&lt;/p>
&lt;p>我们诚心期待更多的开发者加入，也期待 &lt;a href="https://github.com/cloudwego/hertz">Hertz&lt;/a> 助力越来越多的企业快速构建云原生架构。我们也真诚欢迎企业用户迁移使用，我们会提供专项技术支持和交流，欢迎入群咨询。&lt;/p>
&lt;h2 id="04-相关链接">04 相关链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>项目地址: &lt;a href="https://github.com/cloudwego/hertz">https://github.com/cloudwego/hertz&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>周边生态: &lt;a href="https://github.com/hertz-contrib">https://github.com/hertz-contrib&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Blog: Hertz v0.1.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/06/20/hertz-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/20/hertz-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/70">#70&lt;/a>] feat: 增加 hz 脚手架。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/64">#64&lt;/a>] feat: 增加 Hertz Request &amp;amp; Response 到 net/http Request &amp;amp; ResponseWriter 的适配器。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/45">#45&lt;/a>] feat: 添加 ctx.Body() 方法。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/44">#44&lt;/a>] feat: 在 request header 上添加 VisitAllCustomHeader 方法，使得传入的函数 f 只作用在用户自定义的 header 上（除了 cookie, host, content-length, content-type, user-agent 和 connection 以外的 header）。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/59">#59&lt;/a>] feat: 支持 windows 开发环境。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/37">#37&lt;/a>] refactor: 统一设置 request options 的入口，防止 options 未初始化导致 panic。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/52">#52&lt;/a>] refactor: 去掉 for 循环中多余的判空。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/33">#33&lt;/a>] refactor:
当子串长度确定为 1 时，可以直接调用 strings.IndexByte 函数而不是像 strings.Index 一样先调用 len() 判断子串长度后再调用 strings.IndexByte 函数；
为省去整型数字转字符串的工作，可以将相关变量直接定义成 string 类型而不是 int 类型；
net 包下的 JoinHostPort 函数会再次判断 &amp;lsquo;:&amp;rsquo; 是否在 addr 中，如果不在则将 host 与 port 相关字符串连接起来。然而在 AddingMissingPort 函数中调用 net.JoinHostPort 时，':' 应不在 addr 中。所以在此可以不调用 net.JoinHostPort，而是直接连接 host 和 port 信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[&lt;a href="https://github.com/cloudwego/hertz/pull/27">#27&lt;/a>] refactor: 当字符串不需要格式化时，使用 hertz 的 errors.NewPublic 创建 error 而不是使用 fmt.Errorf。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/29">#29&lt;/a>] style(*): 修正拼写错误。&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/57">#57&lt;/a>] optimize: 使用 http.TimeFormat 格式化 HTTP 中的 Date 信息，避免产生更多的复制。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/58">#58&lt;/a>] optimize: 服务端错误日志中添加对端地址。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/41">#41&lt;/a>] optimize(recovery): 使用 &amp;lsquo;CtxErrorf&amp;rsquo; 代替 &amp;lsquo;Errorf&amp;rsquo; 当服务 panic。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/hertz/pull/60">#60&lt;/a>] docs: readme 文件中添加 icon。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.3.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/06/02/kitex-v0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/06/02/kitex-v0.3.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/473">#473&lt;/a>] 功能 (grpc): 为 Kitex gRPC unary 模式增加短连接功能。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/431">#431&lt;/a>] 功能 (limiter):
&lt;ol>
&lt;li>支持自定义的限流实现，接口增加了请求参数的传递；&lt;/li>
&lt;li>修复多路复用场景下 Server 的 QPS 限流器问题，添加基于 OnMessage 的限流；&lt;/li>
&lt;li>调整默认的限流生效时机，只有使用框架 QPS 限流且非多路复用的场景下，才使用基于 OnRead 的限流。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="optimize">Optimize&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/465">#465&lt;/a>] 优化 (ttheader): Client 端在 TTHeader 解码结束后赋值 Remote Address (用于 Proxy 场景请求失败时获取对端地址)。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/466">#466&lt;/a>] 优化 (mux): 连接多路复用场景的 ErrReadTimeout 用 ErrRPCTimeout 封装返回。Proxy 场景请求失败时获取对端地址)。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/425">#425&lt;/a>] 优化 (limiter): 优化限流实现，保证第一秒的 Tokens 不会大幅超过限制。&lt;/li>
&lt;/ul>
&lt;h2 id="bugfix">Bugfix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/485">#485&lt;/a>] 修复 (grpc): 修复 grpc 内不恰当的 int 类型转换。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/474">#474&lt;/a>] 修复 (trans): 在 detection handler 中增加检测。当 OnInactive 比 OnActive 先发生，或者 OnActive 返回 error 时，防止空指针 panic。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/445">#445&lt;/a>] 修复 (retry):
&lt;ol>
&lt;li>修复重试中 &lt;code>callTimes&lt;/code> 字段的 race 问题；&lt;/li>
&lt;li>修复 &lt;code>rpcStats&lt;/code> 中一些字段的 race 问题。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/471">#471&lt;/a>] 修复 (retry): 修复在 backup request 中的一个 race 问题。&lt;/li>
&lt;/ul>
&lt;h2 id="test">Test&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/404">#404&lt;/a>] test: 增加 pkg/retry 的单测。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/439">#439&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/472">#472&lt;/a>] test: 增加 pkg/remote/remotecli 的单测。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/462">#462&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/457">#457&lt;/a>] test: 增加 pkg/remote/trans/nphttp2/grpc 的单测。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/420">#420&lt;/a>] test: 增加 pkg/remote/trans/nphttp2 的单测。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/464">#464&lt;/a>] refactor (ttheader): 修改 Kitex Protobuf 在 TTHeader 中的 protocolID，同时保证该变更与低版本的兼容性。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/453">#453&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/475">#475&lt;/a>] chore: 更新 netpoll 和 bytedance/gopkg 的版本。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/458">#458&lt;/a>] chore: 修复了 reviewdog 失效的问题与 fork pr 单测的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/454">#454&lt;/a>] chore: 现在的 CI 受限于 github runner 的性能经常会失败，尝试改成 self-hosted runner 来提升性能。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/449">#449&lt;/a>] chore: 更新 issue template，修改为更适合 Kitex 项目的问题模板。&lt;/li>
&lt;/ul>
&lt;h2 id="style">Style&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/486">#486&lt;/a>] style (trans): 为 detection trans handler 增加注释信息。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/482">#482&lt;/a>] docs: 在 Readme 中增加 FAQ 链接。&lt;/li>
&lt;/ul>
&lt;h2 id="dependency-change">Dependency Change&lt;/h2>
&lt;ul>
&lt;li>github.com/cloudwego/netpoll: v0.2.2 -&amp;gt; v0.2.4&lt;/li>
&lt;/ul></description></item><item><title>Blog: 从 CloudWeGo 谈云原生时代的微服务与开源</title><link>https://www.cloudwego.io/zh/blog/2022/05/26/%E4%BB%8E-cloudwego-%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%BC%80%E6%BA%90/</link><pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/05/26/%E4%BB%8E-cloudwego-%E8%B0%88%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%BC%80%E6%BA%90/</guid><description>
&lt;h1 id="从-cloudwego-谈云原生时代的微服务与开源">从 CloudWeGo 谈云原生时代的微服务与开源&lt;/h1>
&lt;blockquote>
&lt;p>本文整理自罗广明在 DIVE 全球基础软件创新大会 2022 的演讲分享，主题为《从 CloudWeGo 谈云原生时代的微服务与开源》。&lt;/p>
&lt;/blockquote>
&lt;h2 id="01-项目创造的思考与哲学">&lt;strong>01 项目创造的思考与哲学&lt;/strong>&lt;/h2>
&lt;p>我们团队经常会被人问到，你们为什么创造一个新的项目？我认为这是一个哲学问题。&lt;/p>
&lt;p>纵观整个开源社区，每个时间段都会有各种各样的项目被重复地创造出来，这其中的大部分项目很快便销声匿迹了，只有一部分项目能够存活下来。
当旁观者看到这样一番景象时，渐渐地，越来越多的人停留于项目搜寻，而放弃了成为项目创作者的机会。久而久之，我们开始忧虑下一代是否还会有新的项目可以使用？难道未来在同一领域，一个项目就能统一整个市场？&lt;/p>
&lt;p>其实，在程序员的世界里，参考旧的项目来创造新的项目一点都不可耻。创造不仅意味着思考、权衡与设计，更需要我们贡献项目的特殊与差异。这其中涌现了很多后起之秀，正是他们促成了开源社区的多样性。
“每一行代码都是一次精心的设计”是我们对优秀创造者的最佳赞誉。而一项优秀的代码设计往往包含两个最基本的特性：正确性和可维护性。同时，这两种特性恰恰又对应了两种不同的人格。&lt;/p>
&lt;p>第一种人格，设计者与实现者，其驾驭是相对简单的，只要功能实现，通过测试，运行正确就算完成了。然而，第二种人格，阅读者和维护者，却要求更高的代码质量，更明晰的代码结构和更好的扩展性。
只有同时具备这两种人格，开发者才能游刃有余地创造出一个优秀的项目。&lt;/p>
&lt;p>优秀的项目被创造出来意味着什么呢？千千万万的用户可以评估并且使用它。这也从侧面表明了开源本身可以避免更多项目被重复地创造出来。&lt;/p>
&lt;h2 id="02-cloudwego-简介">&lt;strong>02 CloudWeGo 简介&lt;/strong>&lt;/h2>
&lt;p>CloudWeGo 是字节跳动基础架构团队开源出来的项目，它是一套可快速构建&lt;strong>企业级&lt;/strong>云原生架构的中间件集合，它专注于微服务通信与治理，具备&lt;strong>高性能&lt;/strong>、&lt;strong>可扩展&lt;/strong>、&lt;strong>高可靠&lt;/strong>的特点，且关注&lt;strong>易用性&lt;/strong>。&lt;/p>
&lt;p>CloudWeGo 在第一阶段开源了四个项目：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>：高性能、强可扩展的 Golang RPC 框架&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>：高性能、I/O 非阻塞、专注于 RPC 场景的网络框架&lt;/li>
&lt;li>&lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a>：Golang 实现的 thrift 编译器，支持插件机制和语义检查&lt;/li>
&lt;li>Netpoll-http2：基于 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 的 HTTP/2 实现&lt;/li>
&lt;/ul>
&lt;p>除了这几个主要项目外，CloudWeGo 紧随其后陆续开源了 &lt;a href="https://github.com/cloudwego/kitex-benchmark">&lt;strong>Kitex-benchmark&lt;/strong>&lt;/a>、&lt;a href="https://github.com/cloudwego/netpoll-benchmark">&lt;strong>Netpoll-benchmark&lt;/strong>&lt;/a>、
&lt;a href="https://github.com/cloudwego/thrift-gen-validator">&lt;strong>Thrift-gen-validator&lt;/strong>&lt;/a>、&lt;a href="https://github.com/cloudwego/kitex-examples">&lt;strong>Kitex-examples&lt;/strong>&lt;/a> 、&lt;a href="https://github.com/cloudwego/netpoll-examples">&lt;strong>Netpoll-examples&lt;/strong>&lt;/a>等项目。&lt;/p>
&lt;p>鉴于文章篇幅有限，下文将重点介绍 CloudWeGo 核心项目 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。&lt;/p>
&lt;p>从&lt;strong>演进历史&lt;/strong>来看，2014 年，字节跳动技术团队引入 Golang 解决长连接推送业务面临的高并发问题，两年后，内部技术团队基于 Golang 推出了一个名为 Kite 的框架，同时对开源项目 Gin 做了一层很薄的封装，推出了 Ginex。
这两个框架极大推动了 Golang 在公司内部的应用。此后，围绕性能和可扩展性设计，字节跳动重构 Kite，并在次年 10 月完成并发布Kitex，投入到内部应用中。据悉，截至 2021 年 9 月，线上有 3w+ 微服务使用 Kitex，大部分服务迁移新框架后可以收获 CPU 和延迟上的收益。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Framework.PNG" alt="image">&lt;/p>
&lt;p>从&lt;strong>架构&lt;/strong>上看，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 主要分为两部分。其中 Kitex Core 是它的的主干逻辑，定义了框架的层次结构、接口，还有接口的默认实现。
最上面 Client 和 Server 是对用户暴露的，包含 Option 配置以及其初始化的逻辑；中间的 Modules 模块是框架治理层面的功能模块和交互元信息，而 Remote 模块是与对端交互的模块，包括编解码和网络通信。
另一部分 Kitex Tool 则是对应生成代码相关的实现，生成代码工具就是编译这个包得到的，里面包括 IDL 解析、校验、代码生成、插件支持、自更新等。&lt;/p>
&lt;p>从&lt;strong>功能与特性&lt;/strong>这两个角度来看，主要可以分为以下七个方面：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Functions_Features.PNG" alt="image">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高性能&lt;/strong>：网络传输模块 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 默认集成了自研的网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，性能相较使用 go net 有显著优势；除了网络库带来的性能收益，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Thrift 编解码也做了深度优化。关于性能数据可参考 &lt;a href="https://github.com/cloudwego/kitex-benchmark">kitex-benchmark&lt;/a>。&lt;/li>
&lt;li>&lt;strong>扩展性&lt;/strong>：&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 设计上做了模块划分，提供了较多的扩展接口以及默认的扩展实现，使用者也可以根据需要自行定制扩展，更多扩展能力参见 CloudWeGo &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/framework-exten/">官网文档&lt;/a>。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 也并未耦合 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，开发者也可以选择其它网络库扩展使用。&lt;/li>
&lt;li>&lt;strong>消息协议&lt;/strong>：RPC 消息协议默认支持 Thrift、Kitex Protobuf、gRPC。Thrift 支持 Buffered 和 Framed 二进制协议；Kitex Protobuf 是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 自定义的 Protobuf 消息协议，协议格式类似 Thrift；gRPC 是对 gRPC 消息协议的支持，可以与 gRPC 互通。除此之外，使用者也可以扩展自己的消息协议。&lt;/li>
&lt;li>&lt;strong>传输协议&lt;/strong>：传输协议封装消息协议进行 RPC 互通，传输协议可以额外透传元信息，用于服务治理，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持的传输协议有 TTHeader、HTTP2。TTHeader 可以和 Thrift、Kitex Protobuf 结合使用；HTTP2 目前主要是结合 gRPC 协议使用，后续也会支持 Thrift。&lt;/li>
&lt;li>&lt;strong>多消息类型&lt;/strong>：支持 PingPong、Oneway、双向 Streaming。其中 Oneway 目前只对 Thrift 协议支持，双向 Streaming 只对 gRPC 支持，后续会考虑支持 Thrift 的双向 Streaming。&lt;/li>
&lt;li>&lt;strong>服务治理&lt;/strong>：支持服务注册/发现、负载均衡、熔断、限流、重试、监控、链路跟踪、日志、诊断等服务治理模块，大部分均已提供默认扩展，使用者可选择集成。&lt;/li>
&lt;li>&lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 内置代码生成工具，可支持生成 Thrift、Protobuf 以及脚手架代码&lt;/strong>。原生的 Thrift 代码由本次一起开源的 &lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 生成，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Thrift 的优化由 Kitex Tool 作为插件支持。Protobuf 代码由 Kitex 作为官方 protoc 插件生成 ，目前暂未单独支持 Protobuf IDL 的解析和代码生成。&lt;/li>
&lt;/ul>
&lt;p>简单总结一下，CloudWeGo 不仅仅是一个开源的项目，也是一个真实的、超大规模的&lt;strong>企业级&lt;/strong>最佳实践。它源自企业，所以天生就适合在企业内部落地；它源自开源，最终也拥抱了开源，从 Go 基础库，到 Go 网络库和 Thrift 编译器，再到上层的服务框架，以及框架拥有的所有企业级治理能力，均对外开放开源。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Enterprise.PNG" alt="image">&lt;/p>
&lt;h2 id="03-cloudwego-的微服务治理">&lt;strong>03 CloudWeGo 的微服务治理&lt;/strong>&lt;/h2>
&lt;p>微服务架构是当前软件开发领域的技术热点。大系统终究会拆解成小系统，“合久必分，分而治之”，传统行业的系统架构大多都是庞大的单体架构，微服务是架构发展过程中一个非常自然的演变状态。&lt;/p>
&lt;p>那么，什么是微服务治理呢？众说纷纭，业界没有达成一个共识。广义上，服务治理关注服务生命周期相关要素，包括服务的架构设计、应用发布、注册发现、流量管理，监控与可观测性、故障定位、安全性等；
又或将其分为架构治理、研发治理、测试治理、运维治理、管理治理。狭义上，服务治理技术包括服务注册与发现、可观测性、流量管理、安全、控制。
后续主要是从狭义上服务治理的角度出发，展开介绍 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 相关的思考和探索。&lt;/p>
&lt;h3 id="服务注册与发现">&lt;strong>服务注册与发现&lt;/strong>&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 并不提供默认的服务注册发现，体现了框架的&lt;strong>中立&lt;/strong>特征。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持自定义注册模块和发现模块，使用者可自行扩展集成其他注册中心和服务发现实现，该扩展分别定义在 Pkg/Registry 和 Pkg/Discovery 下。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 服务注册扩展接口如下所示，更多详情可以查看官网框架扩展 -&amp;gt; &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/framework-exten/registry/">服务注册扩展&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Service_registry.png" alt="image">&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 服务发现扩展接口如下所示，更多详情可以查看官网框架扩展 -&amp;gt; &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/framework-exten/service_discovery/">服务发现扩展&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Service_discovery.png" alt="image">&lt;/p>
&lt;p>截止日前，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 已经通过社区开发者的支持，完成了 ETCD、ZooKeeper、Eureka、Consul、Nacos、Polaris 多种服务发现模式，当然也支持 DNS 解析以及 Static IP 直连访问模式，建立起了强大且完备的社区生态，供用户按需灵活选用。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Community_ecology.PNG" alt="image">&lt;/p>
&lt;p>特别鸣谢 @li-jin-gou @liu-song @baiyutang @duduainankai @horizonzy @Hanson 等几位社区贡献者对上述服务发现扩展库的实现与支持。更多代码详情可以查看 &lt;a href="https://github.com/kitex-contrib">https://github.com/kitex-contrib&lt;/a> 。&lt;/p>
&lt;h3 id="熔断">&lt;strong>熔断&lt;/strong>&lt;/h3>
&lt;p>前面介绍了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 服务注册与发现机制，这一点对于业务接入框架非常重要，缺少这一环节微服务之间无法实现互通。那么熔断对于微服务有什么作用呢？&lt;/p>
&lt;p>在微服务进行 RPC 调用时，下游服务难免会出错，当下游出现问题时，如果上游继续对其进行调用，既妨碍了下游的恢复，也浪费了上游的资源。为了解决这个问题，可以设置一些动态开关，当下游出错时，手动的关闭对下游的调用，然而更好的办法是使用熔断器，自动解决这个问题。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 提供了熔断器的实现，但是没有默认开启，需要用户主动开启后即可使用。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 大部分服务治理模块都是通过 Middleware 集成，熔断也是一样。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 提供了一套 CBSuite，封装了服务粒度的熔断器和实例粒度的熔断器。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>服务粒度熔断&lt;/strong>：按照服务粒度进行熔断统计，通过 WithMiddleware 添加。服务粒度的具体划分取决于 Circuit Breaker Key，即熔断统计的 Key，初始化 CBSuite 时需要传入 &lt;strong>GenServiceCBKeyFunc&lt;/strong>。
默认提供的是 &lt;code>circuitbreaker.RPCInfo2Key&lt;/code>，该 Key 的格式是 &lt;code>fromServiceName/toServiceName/method&lt;/code>，即按照方法级别的异常做熔断统计。&lt;/li>
&lt;li>&lt;strong>实例粒度熔断&lt;/strong>：按照实例粒度进行熔断统计，主要用于解决单实例异常问题，如果触发了实例级别熔断，框架会自动重试。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>熔断器的思路很简单根据 RPC 成功或失败的情况，限制对下游的访问&lt;/strong>。通常熔断器分为三个时期：CLOSED、OPEN、HALFOPEN。当RPC 正常时，为 CLOSED；
当 RPC 错误增多时，熔断器会被触发，进入 OPEN；OPEN 后经过一定的冷却时间，熔断器变为 HALFOPEN；HALFOPEN 时会对下游进行一些有策略的访问，
然后根据结果决定是变为 CLOSED，还是 OPEN。总的来说三个状态的转换大致如下图：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Conversion.png" alt="image">&lt;/p>
&lt;p>关于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 熔断器实现的更多细节和原理，可以查看官网基本特性 -&amp;gt; &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/basic-feature/circuitbreaker/">熔断器&lt;/a>章节。&lt;/p>
&lt;h3 id="限流">&lt;strong>限流&lt;/strong>&lt;/h3>
&lt;p>如果说熔断是从客户端出发保护调用链，以防止系统雪崩，那么限流则是一种保护服务端的措施，防止上游某个 Client 流量突增导致 Server 过载。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持限制最大连接数和最大 QPS。在初始化 Server 的时候，增加一个 Option：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Server.png" alt="image">&lt;/p>
&lt;p>其中 &lt;code>MaxConnections&lt;/code> 表示最大连接数，MaxQPS` 表示最大 QPS，此外，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 还提供了动态修改限流阈值的能力。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 分别使用了 ConcurrencyLimiter 和 RateLimiter 对最大连接数和最大 QPS 进行限流，其中 ConcurrencyLimiter 采用了简单的计数器算法，RateLimiter 采用了“令牌桶算法”。&lt;/p>
&lt;p>限流状态的监控也是重要的一环，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 定义了 &lt;code>LimitReporter&lt;/code> 接口，用于限流状态监控，例如当前连接数过多、QPS 过大等。如有需求，用户需要自行实现该接口，并通过 &lt;code>WithLimitReporter&lt;/code> 注入。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/LimitReporter.png" alt="image">&lt;/p>
&lt;h3 id="请求重试">&lt;strong>请求重试&lt;/strong>&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 提供三类重试：超时重试、Backup Request，建连失败重试。其中建连失败是网络层面问题，由于请求未发出，框架会默认重试，下面重点介绍前两类重试的使用。需要注意的是，因为很多的业务请求不具有&lt;strong>幂等性&lt;/strong>，这两类重试不会作为默认策略，用户需要按需开启。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超时重试&lt;/strong>：错误重试的一种，即客户端收到超时错误的时候，发起重试请求。&lt;/li>
&lt;li>&lt;strong>Backup Request&lt;/strong>：客户端在一段时间内还没收到返回，发起重试请求，任一请求成功即算成功。Backup Request 的等待时间 &lt;code>RetryDelay&lt;/code> 建议配置为 TP99，一般远小于配置的超时时间 &lt;code>Timeout&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Timeout.png" alt="image">&lt;/p>
&lt;p>服务中的长尾请求增加了服务的整体延迟，而长尾请求占比很低，如上图所示，一个真实服务的延迟分布，能明显看出长尾现象，最大延迟 60ms，而 99% 服务可以在 13ms 返回。
当请求延迟达到 13ms 的时候就已经进入长尾请求，这个时候我们可以再发出一条请求，这条请求大概率会在 13ms 内返回，任意一次请求返回我们就认为请求成功，即通过增加适当的负载，大大减少了响应时间的波动。
关于超时重试和 Backup Request 的优缺点以及适用场景，可见下表：&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Backup_Request.PNG" alt="image">&lt;/p>
&lt;h3 id="负载均衡">&lt;strong>负载均衡&lt;/strong>&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 默认提供了两种负载均衡算法实现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>WeightedRandom&lt;/strong>：这个算法使用的是基于权重的随机策略，也是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的默认策略。它会依据实例的权重进行加权随机，并保证每个实例分配到的负载和自己的权重成比例。&lt;/li>
&lt;li>&lt;strong>ConsistentHash&lt;/strong>：一致性哈希主要适用于对上下文（如实例本地缓存）依赖程度高的场景，如希望同一个类型的请求打到同一台机器，则可使用该负载均衡方法。&lt;/li>
&lt;/ul>
&lt;p>ConsistentHash 在使用时，需要注意如下事项：&lt;/p>
&lt;ul>
&lt;li>下游节点发生变动时，一致性哈希结果可能会改变，某些 Key 可能会发生变化；&lt;/li>
&lt;li>如果下游节点非常多，第一次冷启动时 Build 时间可能会较长，如果 RPC 超时短的话可能会导致超时；&lt;/li>
&lt;li>如果第一次请求失败，并且 Replica 不为 0，那么会请求到 Replica 上；而第二次及以后仍然会请求第一个实例。&lt;/li>
&lt;/ul>
&lt;h3 id="可观测性">&lt;strong>可观测性&lt;/strong>&lt;/h3>
&lt;p>框架自身不提供监控打点实现，提供了 &lt;code>Tracer&lt;/code> 接口，用户可以根据需求实现该接口，并通过 &lt;code>WithTracer&lt;/code> Option 注入到框架中。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Tracer.png" alt="image">&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的监控打点、Metrics 上报以及链路追踪，都可以通过上述接口进行扩展。&lt;/p>
&lt;p>目前 &lt;a href="https://github.com/kitex-contrib">kitex-contrib&lt;/a> 组织下提供了 &lt;a href="https://github.com/kitex-contrib/monitor-prometheus">Prometheus&lt;/a> 的监控扩展，
&lt;a href="https://github.com/kitex-contrib/tracer-opentracing">OpenTracing&lt;/a> 的链路追踪扩展，
以及 &lt;a href="https://github.com/kitex-contrib/obs-opentelemetry">OpenTelemetry&lt;/a> 可观测性全家桶（Metrics + Tracing + Logging）扩展实现，用户可以按需接入相应的扩展。&lt;/p>
&lt;h3 id="微服务框架与服务网格">&lt;strong>微服务框架与服务网格&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>服务框架&lt;/strong>是传统微服务技术的核心所在。早期微服务技术中的服务注册、发现、调用、治理、观测都离不开服务框架。这也带来了一些问题，比如业务研发者需要感知并使用服务框架的服务治理能力，框架版本升级困难，框架越来越重难于维护等等。&lt;/p>
&lt;p>&lt;strong>服务网格（Service Mesh）&lt;/strong> 是将无侵入服务治理定义的更为深入的微服务架构方案，被称为第二代微服务架构。通过将微服务治理能力以独立组件（Sidecar）整合并下沉到基础设施，服务网格可以实现应用业务逻辑与服务治理逻辑完全分离，这也使支持&lt;strong>多语言&lt;/strong>、&lt;strong>热升级&lt;/strong>等高阶特性变得顺理成章。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Service_Mesh.png" alt="image">&lt;/p>
&lt;p>进入云原生时代，随着服务网格技术的逐步发展，我们也要用发展的眼光进行架构规划和设计，微服务框架和服务网格未来必定会是并存的，统一组成服务治理体系。
在字节跳动，服务治理体系就是由服务框架和服务治理组成。以 Golang 服务为例，CloudWeGo 提供业务强相关、强侵入的服务治理，
字节 Service Mesh 提供业务弱相关、弱侵入的服务治理，相互搭配，相互协商，既解决了业务开发所需的脚手架和开发模式，又让服务治理的接入更加容易。&lt;/p>
&lt;p>与此同时，在服务网格和服务框架同时使用的场景下，服务框架必须要支持灵活卸载治理能力，服务网格也需要保证功能的稳定性。在未来技术的演进方向上，服务框架也主要专注于编解码、通信效率、多协议支持等方面，而服务网格则可以深入更多无侵入的服务治理功能研发中。&lt;/p>
&lt;p>此外，在大规模场景下，针对服务治理新功能的研发需求决策，我们往往还需要考虑以下因素：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能:&lt;/strong> 大部分业务很在意，也是团队一直努力的重点；&lt;/li>
&lt;li>&lt;strong>普遍性&lt;/strong>:需要评估是不是所有业务都需要的能力；&lt;/li>
&lt;li>&lt;strong>简洁&lt;/strong>: 通俗说，我们不太希望引入太多的线上问题或者太复杂的使用说明文档；&lt;/li>
&lt;li>&lt;strong>ROI&lt;/strong>：功能迭代、产品升级需要考虑整体投资回报率。&lt;/li>
&lt;/ul>
&lt;h2 id="04-cloudwego-的开源之路">&lt;strong>04 CloudWeGo 的开源之路&lt;/strong>&lt;/h2>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Library.png" alt="image">&lt;/p>
&lt;p>字节内部版本的 Kitex 是依赖于开源版本的 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>，因此可以理解为 Kitex 内外同源，不存在两个 Kitex。&lt;/p>
&lt;h3 id="开源的原因">&lt;strong>开源的原因&lt;/strong>&lt;/h3>
&lt;p>回到开篇的问题，为什么要创造一个新的项目，并且开源 CloudWeGo 呢？&lt;/p>
&lt;p>首先，CloudWeGo 里面的项目都是在字节内部经过大规模落地实践验证的，开源后每个功能的迭代也都是第一时间在内部使用验证过的，是一个真正的企业级落地项目，开源用户和字节内部业务使用的是同一套服务框架；
其次，CloudWeGo 提供的功能，尤其是协议支持和服务治理，都是能解决真实业务痛点的，每一行代码优化都能实实在在地提升用户服务的性能；
最后，CloudWeGo 的研发也借鉴了一些知名开源项目的设计思路，同时也依赖一些开源项目的实现，我们把 CloudWeGo 开源出去也是为了回馈社区，给开源社区贡献一份力量。&lt;/p>
&lt;p>CloudWeGo 在设计之初，就同时考虑了正确性和可维护性，除了代码逻辑的正确性，高质量的代码、明晰的代码结构和优良的扩展性一直都是 CloudWeGo 追求的方向和实践的信条。&lt;/p>
&lt;p>CloudWeGo 服务于用户、需求驱动，为用户提供开箱即用的服务框架及相关中间件，希望可以服务于更多企业和独立开发者，避免用户重复创造。&lt;/p>
&lt;h3 id="开源的历程">&lt;strong>开源的历程&lt;/strong>&lt;/h3>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Course.PNG" alt="image">&lt;/p>
&lt;p>CloudWeGo 自 2021 年 9 月 8 日正式对外官宣，主要子项目 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 先后发布 v0.1.0 和 v0.2.0，支持了许多新的功能，对性能、代码、文档也相继做了许多优化。
截止到 2022 年 4 月，距离首次官宣 7 个月，仅 CloudWeGo-Kitex 就收获了 &lt;strong>4000&lt;/strong> 个 Star，累计近 &lt;strong>50&lt;/strong> 个 Contributors，达到了一个新的里程碑，这很有趣，并且十分振奋人心，不是吗？&lt;/p>
&lt;p>CloudWeGo 团队自开源之初就非常重视社区建设，“&lt;strong>Community Over Code&lt;/strong>” 也是 CloudWeGo 社区所遵循的文化和目标。&lt;/p>
&lt;p>从搭建用户群，建设官网和文档，积极维护项目 Issue，及时处理新的 PR，再到我们与贡献者的深入沟通和对他们的培养，每一个动作都体现我们的决心。为了推进社区建设规范化和标准化，CloudWeGo 团队先后创建了 Community 仓库用来定义社区成员晋升机制以及存档社区材料。&lt;/p>
&lt;p>为了践行公开透明和开源开放的开源文化，搭建开放的对话与交流平台，CloudWeGo 组织了社区双周例会，在例会上同步社区近期计划并积极听取社区成员的建议，与社区贡献者讨论相关技术方案实现。&lt;/p>
&lt;p>截止目前，通过社区 Maintainer 的培养、Contributor 的主动申请、社区管理委员会的投票审批，已经正式通过了 5 位 Committer 的加入申请，极大地壮大了 CloudWeGo 社区核心力量，他们为社区的发展作出了重大贡献。&lt;/p>
&lt;h3 id="后续的规划">&lt;strong>后续的规划&lt;/strong>&lt;/h3>
&lt;p>CloudWeGo 在 2021 年底收录进入 CNCF Landscape，丰富了 CNCF 在 RPC 领域的生态，给全球用户在做技术选型时提供了一套新的选择。&lt;/p>
&lt;p>尽管取得了一些小小的成绩，但是 CloudWeGo 仍旧还是一个年轻的项目，开源贵在持之以恒、长期建设，CloudWeGo 团队也会持续完善，继续向前。&lt;/p>
&lt;p>从社区建设方面来看，CloudWeGo 团队将继续提供更多新人友好的 Good-first-issue，坚持组织社区例会，定期举办开源技术沙龙，提供更易于理解的技术文档，另外也将继续欢迎更多新的开发者参与到社区建设中来。&lt;/p>
&lt;p>从开源规划来看，HTTP 框架 Hertz 开源在即，还有更多中间件小工具、扩展库也都在持续开源中。此外，CloudWeGo 主创团队还研发了一套 Rust RPC 框架，正在内部落地实践验证中，在不久的将来，也将对外开源。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Microservices_Open_CloudWeGo/Plan.png" alt="image">&lt;/p>
&lt;p>从功能研发计划来看，以 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 为例，将继续以内外部用户需求为驱动力，持续开发新的功能并迭代完善已有的功能。其中，包括支持连接预热、自定义异常重试、对 Protobuf 支持的性能优化，支持 xDS 协议等。&lt;/p>
&lt;p>从开源生态来看，目前 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 已经完成了诸多开源项目的对接，未来也将会按需支持更多开源生态。
此外，CloudWeGo 也在和国内外主流公有云厂商进行合作对接，提供开箱即用、稳定可靠的微服务托管与治理产品的基座；CloudWeGo 也积极与国内外软件基金会开展合作和交流，探索新的合作模式。&lt;/p>
&lt;p>CloudWeGo 未来可期，我们期待更多用户使用我们的项目，也期待有更多开发者可以加入共建 CloudWeGo 社区，共同见证云原生时代一个初生但了不起的微服务中间件和开源项目。&lt;/p></description></item><item><title>Blog: 字节微服务框架的挑战和演进</title><link>https://www.cloudwego.io/zh/blog/2022/05/19/%E5%AD%97%E8%8A%82%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E6%BC%94%E8%BF%9B/</link><pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/05/19/%E5%AD%97%E8%8A%82%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8C%91%E6%88%98%E5%92%8C%E6%BC%94%E8%BF%9B/</guid><description>
&lt;h1 id="字节微服务框架的挑战和演进">字节微服务框架的挑战和演进&lt;/h1>
&lt;p>2014 年以来，字节跳动内部业务的快速发展，推动了长连接推送服务，它们面临着高并发的业务需求问题，对性能和开发效率都有很高要求。当时的业务，大部分都是由 Python 开发，难以应对新出现的问题。
项目负责人在一众现存的技术栈中选择了 Golang 这一门新兴的编程语言，快速解决了性能和开发效率的问题。随后，字节跳动内部开始逐渐推广使用 Golang 进行服务开发。&lt;/p>
&lt;p>2016 年， 第一代 Golang RPC 框架 Kite 正式发布。Kite 是一个基于 Apache Thrift 进行包装的 RPC 框架，它在 Facebook 开源的 Thrift 之上提供了结合字节跳动内部基础设施的治理功能，
同时还提供了一套简单易用的生成工具。随着 Kite 的发展，业务开始大规模使用 Golang。然而，在业务发展的过程中，由于研发专注于实现业务需求，对于框架的可维护性考量不足，Kite 逐渐背上了一些技术包袱，
越来越难以满足业务在高性能和新特性方面的需求。因此我们决定对 Kite 进行重新设计，于是出现了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。&lt;/p>
&lt;p>2020 年，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在内部发布了 v1.0.0，并且直接接入了 1,000+ 服务。由于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的优秀性能和易用性，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在内部得到了大规模发展。
直到 2021 年年中，字节跳动内部已有 2w+ 服务使用了 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。因此，我们决定全面优化 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>，将其实践成果进行开源，反馈给开源社区。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/GolangRPC.png" alt="image">&lt;/p>
&lt;p align="center">
字节跳动 Golang RPC 框架的演进
&lt;/p>
&lt;h2 id="kite-的缺陷">Kite 的缺陷&lt;/h2>
&lt;p>Kite 作为字节跳动第一代 Golang RPC 框架，主要存在以下缺陷：&lt;/p>
&lt;ol>
&lt;li>Kite 为了快速支持业务发展需求，不可避免地耦合了部分中台业务的功能；&lt;/li>
&lt;li>Kite 对 Go modules 支持不友好（Go modules 在 2019 年才进入语言核心）；&lt;/li>
&lt;li>Kite 自身的代码拆分成多仓库，版本更新时推动业务升级困难；&lt;/li>
&lt;li>Kite 强耦合了早期版本的 Apache Thrift，协议和功能拓展困难；&lt;/li>
&lt;li>Kite 的生成代码逻辑与框架接口强耦合，成为了性能优化的天花板。&lt;/li>
&lt;/ol>
&lt;p>因此，业务的快速发展和需求场景的多样化，催生了新一代 Golang RPC 框架 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。&lt;/p>
&lt;h2 id="kitex">Kitex&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的架构主要包括四个部分：Kitex Tool、Kitex Core、Kitex Byted、Second Party Pkg。&lt;/p>
&lt;ul>
&lt;li>Kitex Core 是一个携带了一套微服务治理功能的 RPC 框架，它是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的核心部分。&lt;/li>
&lt;li>Kitex Byted 是一套结合了字节跳动内部基础设施的拓展集合。通过这一套拓展集合，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 能够在内部支持业务的发展。&lt;/li>
&lt;li>Kitex Tool 是一个命令行工具，能够在命令行生成我们的代码以及服务的脚手架，可以提供非常便捷的开发体验。&lt;/li>
&lt;li>Second Party Pkg，例如 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>， Netpoll-http2，是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 底层的网络库，这两个库也开源在 CloudWeGo 组织中。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Architecture_design.png" alt="image">&lt;/p>
&lt;p align="center">
Kitex 的架构设计
&lt;/p>
&lt;p>总的来说， &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 主要有五个特点：面向开源、功能丰富、灵活可拓展、支持多协议、高性能。&lt;/p>
&lt;h2 id="面向开源">面向开源&lt;/h2>
&lt;p>由于之前已经体验过了 Kite 维护的各种问题，我们在立项之初就考虑到了未来可能会开源 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。因此，我们设计的第一个宗旨就是不将 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和公司内部的基础设施进行强耦合或者硬编码绑定。
Kitex Core 是一个非常简洁的框架，公司内部的所有基础设施都以拓展的方式注入到 Kitex Core 里。即使我们现在已经开源了，它也以这种形式存在。
公司内部基础设施的更新换代，和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 自身的迭代是相互独立的，这对于业务来说是非常好的体验。同时，在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的接口设计上，我们使用了 Golang 经典的 Option 模式，
它是可变参数，通过 Option 能够提供各种各样的功能，这为我们的开发和业务的使用都带来了非常大的灵活性。&lt;/p>
&lt;h2 id="kitex-的功能特性">Kitex 的功能特性&lt;/h2>
&lt;h3 id="治理能力">治理能力&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 内置了丰富的服务治理能力，例如超时熔断、重试、负载均衡、泛化调用、数据透传等功能。业务或者外部的用户使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 都是可以开箱即用的。
如果你有非常特殊的需求，你也可以通过我们的注入点去进行定制化操作，比如你可以自定义中间件去过滤或者拦截请求，定义跟踪器去注入日志、去注入服务发现等。
在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 中，几乎一切跟策略相关的东西都是可以定制的。&lt;/p>
&lt;p>以服务发现为例，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的核心库里定义了一个 Resolver interface 。任何一个实现了这四个方法的类型都可以作为一个服务发现的组件，然后注入到 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 来取代 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的服务发现功能。
在使用时，客户端只需要创建一个 Resolver 的对象，然后通过 client.WithResolver 注入客户端，就可以使用自己开发的服务发现组件。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Resolver.png" alt="image">&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的一个创新之处是使用 Suite 来打包自定义的功能，提供一键配置基础依赖的体验。&lt;/p>
&lt;p>它能在什么地方起作用呢？例如，一个外部企业想要启用或者接入 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>， 它不可能拥有字节跳动内部的所有基础设施。那么企业在使用的时候肯定需要定制化，他可能需要定义自己的注册中心、负载均衡、连接池等等。
如果业务方要使用这些功能的话，就需要加入非常非常多的参数。而 Suite 可以通过一个简单的类一次性包装这些功能，由此，业务方使用时，仍然是以单一的参数的方式添加，十分方便。
又例如，我现在开发一个叫 mysuite 的东西，我可能提供一个特殊的服务发现功能，提供了一个拦截的中间件，还有负载均衡功能等。
业务方使用时，不需要感知很多东西去配置，只需要添加一个 Suite 就足够了，这点非常方便一些中台方或者第三方去做定制。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Suite.png" alt="image">&lt;/p>
&lt;p align="center">
示例
&lt;/p>
&lt;h3 id="多协议">多协议&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 网络层基于高性能网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 实现。在 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 上，我们构建了 Thrift 和 Netpoll-http2；在 Thrift 上，我们还做了一些特殊的定制，例如，支持 Thrift 的泛化调用，还有基于 Thrift 的连接多路复用。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Multi-protocol.png" alt="image">&lt;/p>
&lt;p align="center">
多协议
&lt;/p>
&lt;h3 id="代码生成工具">代码生成工具&lt;/h3>
&lt;p>和 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 一同出现的，还有我们开发的一个简单易用的命令行工具 kitex。如果我们写了一个 IDL，只需要提供一个 module 参数和一个服务名称，kitex 就会为你生成服务代码脚手架。&lt;/p>
&lt;p>目前 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持了 Protobuf 和 Thrift 这两种 IDL 的定义。命令行工具内置丰富的选项，可以进行项目代码定制；同时，它底层依赖 Protobuf 官方的编译器，和我们自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。&lt;/p>
&lt;h2 id="kitex-的性能表现">Kitex 的性能表现&lt;/h2>
&lt;p>字节跳动内部 RPC 框架使用的协议主要都是基于 Thrift，所以我们在 Thrift 上深耕已久。结合自研的 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 能力，它可以直接暴露底层连接的 buffer。
在此基础上，我们设计出了 FastRead/FastWrite 编解码实现，测试发现它具有远超过 apache thrift 生成代码的性能。整体而言，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的性能相当不错，今年 1 月份的数据如下图所示，
可以看到，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在使用 Thrift 作为 Payload 的情况下，性能优于官方 gRPC，吞吐接近 gRPC 的两倍；此外，在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 使用定制的 Protobuf 协议时，性能也优于 gRPC。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Kitex_gRPC.png" alt="image">&lt;/p>
&lt;p align="center">
Kitex/gRPC 性能对比（2022 年 1 月数据）
&lt;/p>
&lt;h2 id="kitex一个-demo">Kitex：一个 demo&lt;/h2>
&lt;p>下面简单演示一下 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 是如何开发一个服务的。&lt;/p>
&lt;p>首先，定义 IDL。这里使用 Thrift 作为 IDL 的定义，编写一个名为 Demo 的 service。方法 Test 的参数是 String，它的返回也是 String。
编写完这个 demo.thrift 文件之后，就可以使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在命令行生成指定的生成代码。如图所示，只需要传入 module name，service name 和目标 IDL 就行了。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/IDL.png" alt="image">&lt;/p>
&lt;p align="center">
定义 IDL
&lt;/p>
&lt;p>随后，我们需要填充业务逻辑。文件中除了第 12 行，全部代码都是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 命令行工具生成的。通常一个 RPC 方法需要返回一个 Response，例如这里需要返回一个字符串，那么我们给 Response 赋值即可。
接下来需要通过 go mod tidy 把依赖拉下来，然后用 build.sh 构建，就可以启动服务了。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 默认的接听端口是 8888。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Handler.png" alt="image">&lt;/p>
&lt;p align="center">
定义 Handler 方法
&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Compile_run.png" alt="image">&lt;/p>
&lt;p align="center">
编译、运行
&lt;/p>
&lt;p>对于刚刚启动的服务端，我们可以写一个简单的客户端去调用它。服务端写完之后，写客户端也是非常方便的。
这里同样是 import 刚刚生成的生成代码，创建 Client、指定服务名字、构成相应的参数，填上“ Hello，word！” ，然后就可以调用了。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Client.png" alt="image">&lt;/p>
&lt;p align="center">
编写 Client
&lt;/p>
&lt;h1 id="kitex-在字节内部的落地">Kitex 在字节内部的落地&lt;/h1>
&lt;h2 id="与内部基础设施的集成">与内部基础设施的集成&lt;/h2>
&lt;p>谈到落地，第一步就是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和字节跳动内部的基础设施进行结合。字节跳动内部的所有基础设施都是以依赖的方式注入到 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的。
我们将日志、监控、tracing 都定义为 tracer，然后通过 WithTracer 这个 Option 将其注入到 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 里；服务发现是 WithResolver；Service Mesh 则是 WithProxy 等。
字节跳动内部的基础设施都是通过 Option 被注入到 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的，而且所有的 Option 都是通过前面说的 Suite 打包，简单地添加到业务的代码里完成。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Integration.png" alt="image">&lt;/p>
&lt;p align="center">
与内部基础设施的集成
&lt;/p>
&lt;h2 id="内部落地的经典案例合并部署">内部落地的经典案例：合并部署&lt;/h2>
&lt;p>这里介绍一个内部落地的经典案例：合并部署。其背景是，在开发微服务时，由于业务拆分和业务场景的多样化，微服务容易出现过微的情况。
当服务数量越来越多，网络传输和序列化开销就会越来越大，变得不可忽视。因此，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 框架需要考虑如何减小网络传输和序列化的开销。&lt;/p>
&lt;p>字节跳动基础架构经过一系列的探索和实践，最终推出了合并部署的机制。&lt;strong>它的思路&lt;/strong>是：将有强依赖关系的服务进行同机部署，减少它们之间的调用开销。理论上说起来比较简单，实际过程中需要非常多的组件进行配合。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的做法&lt;/strong>是：首先，它会依赖一套中心化的部署调度和流量控制；其次，我们开发了一套基于共享内存的通信协议，它可以使得我们两个不同的服务在同一台机器部署时，不需要通过网络进行数据传输，直接通过共享内存，减少额外的数据拷贝。&lt;/p>
&lt;p>在服务合并部署的模式下，我们需要特殊的服务发现和连接池的实现、定制化的服务启动和监听逻辑。这些在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 框架里都是通过依赖注入的方式给添加进来的。
&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 服务在启动过程中会感知到我们 PaaS 平台提供的指定的环境变量。当它察觉到自己需要按合并部署的方式启动之后，就会启动一个预先注入的特定 Suite，随后将相应的功能全都添加进来再启动，就可以执行我们的合并部署。&lt;/p>
&lt;p>那么，它的效果如何呢？在 2021 年的实践过程中，我们对抖音的某个服务约 30% 的流量进行了合并，服务端的 CPU 的消耗减少了 19%， TP99 延迟下降到 29%，效果相当显著。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Merge_deployment.png" alt="image">&lt;/p>
&lt;p align="center">
内部落地的经典案例：合并部署
&lt;/p>
&lt;h2 id="微服务框架推进的痛点">微服务框架推进的痛点&lt;/h2>
&lt;ul>
&lt;li>升级慢&lt;/li>
&lt;/ul>
&lt;p>大家可能好奇 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在字节跳动内部推广是不是很顺畅？其实并不是。作为一个相对而言比较新的框架， &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和其它新生项目一样，在推广的过程中都会遇到同样的问题。
特别是， &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 作为一个 RPC 框架，我们提供给用户的其实是一个代码的 SDK, 我们的更新是需要业务方的用户去感知、升级、部署上线，才能最终体现在他们的服务逻辑里，因此具有升级慢的问题。&lt;/p>
&lt;ul>
&lt;li>召回慢&lt;/li>
&lt;/ul>
&lt;p>同时，因为代码都是由研发人员编写，如果代码出现了 bug，我们就需要及时地去感知定位问题，通知负责人去更新版本。因此，会有召回慢的问题。&lt;/p>
&lt;ul>
&lt;li>问题排查困难&lt;/li>
&lt;/ul>
&lt;p>业务方的用户在写代码时，他们其实往往关注的是自己的业务逻辑，他们不会深入理解一个框架内部的实现。所以如果出现问题，他们往往会不知所措，需要依赖我们的业务同学才能进行相应的问题排查。所以会有问题排查困难的问题。&lt;/p>
&lt;p>针对&lt;strong>升级慢&lt;/strong>，我们有两个操作。一是，代码生成工具支持自动更新：当用户在使用时，我们会检查最新版本，然后直接将我们的版本更新到最新版本，这样可以及时把我们的框架新 feature、bug fix 直接推送到业务方；
二是，用户群发版周知：我们有一个几千人的用户群，当有了新版本，我们会在用群里周知，可以最大范围的覆盖到我们的目标用户。&lt;/p>
&lt;p>针对&lt;strong>召回慢&lt;/strong>，我们有三个操作。一是，我们在线上建立完整的版本分布统计，监控所有服务上线部署的框架的版本；
二是，我们会跟 PaaS 平台合作，在服务上线时进行卡点操作，检查它们使用的框架版本是不是有 bug，是否需要拦截；三是，针对有问题的版本，我们会及时封禁，及时推动用户更新。&lt;/p>
&lt;p>针对&lt;strong>问题排查困难&lt;/strong>，我们有两个操作。一是，我们积累了非常丰富的 Wiki 和问题排查手册，例如超时问题、 协议解析问题等。
二是，如果遇到难以解决的问题，我们在线上服务默认开启了 Debug 端口，保证框架开发同学可以第一时间赶到现场去排查。&lt;/p>
&lt;h2 id="kitex-在字节内部的发展">Kitex 在字节内部的发展&lt;/h2>
&lt;p>数据显示，在 2020 年，v1.0 版本发布的初始阶段，用户的接受度比较低。直到 2020 年 6 月，线上接受 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的数量还不到 1000。
随后进入快速发展的阶段，到 2021 年年初，累积接近 1w+ 的服务开始使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。2021 年底，4w+服务使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/Evolution_Kitex_High-performance/Number_of_AccessServices.png" alt="image">&lt;/p>
&lt;h1 id="kitex-的开源实践">Kitex 的开源实践&lt;/h1>
&lt;p>开源工作主要包括代码、文档和社区运营三个层面。&lt;/p>
&lt;p>&lt;strong>代码层面&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>代码拆分、脱敏；&lt;/li>
&lt;li>内部仓库引用开源仓库，避免内外多副本同时维护；&lt;/li>
&lt;li>在开源过程中确保内部用户平滑切换、体验无损；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>文档层面&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>重新梳理用户文档，覆盖方方面面；&lt;/li>
&lt;li>建立详尽的用例仓库(CloudWeGo/Kitex-examples)。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>社区运营&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>官网建设；&lt;/li>
&lt;li>组建用户群，进行答疑解惑；&lt;/li>
&lt;li>飞书机器人对接 Github 的 Issue 管理、PR 管理之类的业务，可以快速响应；&lt;/li>
&lt;li>对优秀贡献者进行奖励。&lt;/li>
&lt;/ul>
&lt;p>在以上努力下，&lt;a href="https://github.com/cloudwego/kitex">CloudWeGo/Kitex&lt;/a> 仓库目前收获了 4.1k+ stars；&lt;a href="https://github.com/kitex-contrib">kitex-contrib&lt;/a> 获得多个外部用户贡献的仓库；CloudWeGo 飞书用户群近 950 个用户……&lt;/p>
&lt;h1 id="未来展望">未来展望&lt;/h1>
&lt;p>首先，我们仍然会持续向开源社区反馈最新的技术进展。例如在 Thrift 协议上，虽然对 Thrift 的编解码已经做到非常极致的优化了，我们还在探索利用 JIT 手段来提供更多的性能提升；
在 Protobuf 上，我们会补足短板，将在 Thrift 方面的优化经验迁移到 Protobuf 上，对 Protobuf 的生成代码和编解码进行优化； &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 后续也会进一步融入云原生社区，所以也在考虑支持 xDS 协议。
其次，我们会去拓展更多的开源组件，去对接现存的云原生社区的各种常用的或者热门组件。最后，我们也会尝试去对接更多的公有云基础设施，使得用户在公有云上使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 时能够拥有愉悦的体验。&lt;/p></description></item><item><title>Blog: Kitex v0.3.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/04/29/kitex-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/04/29/kitex-v0.3.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/366">#366&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/426">#426&lt;/a> ] 功能(client): 客户端支持预热操作&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/395">#395&lt;/a> ] 功能(mux): 连接多路复用支持优雅关闭&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/399">#399&lt;/a> ] 功能(protobuf): 定义 fastpb protocol API 并在编解码模块对应支持&lt;/li>
&lt;/ul>
&lt;h2 id="optimise">Optimise&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/402">#402&lt;/a> ] 优化(connpool): 导出 pkg/remote/connpool 里的 getCommonReporter&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/389">#389&lt;/a> ] 优化(rpcinfo)：填充由 defaultCodec 解码得到的 rpcinfo 中缺失的 Invocation().PackageName, Invocation().ServiceName and Config().TransportProtocol 字段&lt;/li>
&lt;/ul>
&lt;h2 id="bugfix">Bugfix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/413">#413&lt;/a> ] 修复(mux): 在 NetpollMux transHandler 中设置 sendMsg的PayloadCodec，以修复泛化请求编码报错问题&lt;a href="https://github.com/cloudwego/kitex/issues/411">issue #411&lt;/a>&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/406">#406&lt;/a> ] 修复(grpc): 修复 http2 framer 的读写逻辑，例如避免对端无法及时收到 framer&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/398">#398&lt;/a> ] 修复(utils)：修复了 Dump() 接口无法 dump 出 ring 里所有数据的 bug&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/428">#428&lt;/a> ] 修复(trans)：当写入失败时，关闭连接以避免内存泄漏&lt;/li>
&lt;/ul>
&lt;h2 id="tool">Tool&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/340">#340&lt;/a> ] tool(protobuf): 重新设计并实现 Protobuf 生成代码，不使用反射完成编解码，当前仅支持 proto3&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/396">#396&lt;/a> ] chore: 用 bytedance/gopkg 里的 xxhash3 替换掉 cespare/xxhash&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/400">#400&lt;/a> ] chore: 升级 workflow 的 go 版本到 1.18&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/407">#407&lt;/a> ] chore: 单独增加文件对 grpc 源码使用做声明&lt;/li>
&lt;/ul>
&lt;h2 id="test">Test&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/401">#401&lt;/a> ] test: 补充 kitex/server 的单测&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/393">#393&lt;/a> ] test: 补充 pkg/remote/bound package 单测&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/403">#403&lt;/a> ] test: 补充 netpollmux package 单测&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/401">#401&lt;/a> ] test: 补充 klog package 单测&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/392">#392&lt;/a> ] test: 补充 utils package 单测&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/373">#373&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/432">#432&lt;/a>, &lt;a href="https://github.com/cloudwego/kitex/pull/434">#434&lt;/a> ] test: 补充 gRPC transport 部分的单测，单测覆盖率提升到 76%&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/424">#424&lt;/a> ] test: 补充 transmeta 实现 handler 的单元测试&lt;/li>
&lt;/ul>
&lt;h2 id="dependency-change">Dependency Change&lt;/h2>
&lt;ul>
&lt;li>github.com/cloudwego/netpoll: v0.2.0 -&amp;gt; v0.2.2&lt;/li>
&lt;li>github.com/bytedance/gopkg: 20210910103821-e4efae9c17c3 -&amp;gt; 20220413063733-65bf48ffb3a7&lt;/li>
&lt;/ul></description></item><item><title>Blog: Netpoll v0.2.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/04/28/netpoll-v0.2.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/04/28/netpoll-v0.2.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="improvement">Improvement&lt;/h2>
&lt;ul>
&lt;li>Fix: Loops 缩容不再全部重置&lt;/li>
&lt;li>Chore: mcache bsr 计算使用 math/bits.Len 代替，以提升性能。&lt;/li>
&lt;li>Feat: 修复 LinkBuffer Close 时没有回收 caches 的问题（不是内存泄漏）&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>Fix: 修复短链接 send&amp;amp;close 场景无法触发 OnRequest 回调的问题&lt;/li>
&lt;li>Fix: 修复 zcReader 读到 io.EOF 后丢失部分数据的问题&lt;/li>
&lt;li>Fix: 修复 flush 没有检查连接关闭的问题&lt;/li>
&lt;/ul>
&lt;h2 id="doc">Doc&lt;/h2>
&lt;ul>
&lt;li>Doc: 更新了用户文档&lt;/li>
&lt;li>Doc: 增加了 Reader.Slice 的定义描述&lt;/li>
&lt;li>Doc: 修复了 examples 中的死链&lt;/li>
&lt;/ul>
&lt;h2 id="revert">Revert&lt;/h2>
&lt;ul>
&lt;li>Revert: 重置了 loops 初始化数量&lt;/li>
&lt;/ul></description></item><item><title>Blog: CloudWeGo 助 NextArch 基金会推动标准化建设</title><link>https://www.cloudwego.io/zh/blog/2022/04/01/cloudwego-%E5%8A%A9-nextarch-%E5%9F%BA%E9%87%91%E4%BC%9A%E6%8E%A8%E5%8A%A8%E6%A0%87%E5%87%86%E5%8C%96%E5%BB%BA%E8%AE%BE/</link><pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/04/01/cloudwego-%E5%8A%A9-nextarch-%E5%9F%BA%E9%87%91%E4%BC%9A%E6%8E%A8%E5%8A%A8%E6%A0%87%E5%87%86%E5%8C%96%E5%BB%BA%E8%AE%BE/</guid><description>
&lt;blockquote>
&lt;p>导语：2022 年 3 月，NextArch 基金会正式成立微服务技术小组，致力于推动微服务技术和开源生态的持续发展，根据各个企业在微服务生产实践中遇到的问题，针对不同行业和应用场景输出标准化解决方案，
并且联合 PolarisMesh、TARS、go-zero、GoFrame、&lt;strong>&lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a>&lt;/strong> 和 Spring Cloud Tencent 等开源社区提供开箱即用的实现，降低终端用户的使用门槛。
来自腾讯、字节跳动、七牛云、快手、BIGO、好未来和蓝色光标等多家企业的技术专家已经加入技术小组，欢迎更多企业和开源社区加入。&lt;/p>
&lt;/blockquote>
&lt;p>2021 年 11 月，Linux 基金会正式成立 NextArch 基金会，共计 40 余家企业或单位联合参与了该基金会的筹建工作，并作为首批共建和支持单位加入，目前已增至 53 家企业。NextArch 基金会致力于在异构基础设施、多元化技术栈和混合云场景下的构建下一代技术架构，始终秉承一个开放中立的治理模式，发展适合企业数字化转型的开源生态。&lt;/p>
&lt;p>微服务是下一代架构的关键部分，越来越多企业采用微服务架构。市场调研表明，随着企业数字化转型持续深入，2023 年微服务云市场的规模达到 18.8 亿美元，从 2018 到 2023 年的复合年增长率达到 22.4%。众所周知，微服务相比于传统架构具有诸多优势，但是，我们在微服务实施的各个环节中都可能面临问题。&lt;/p>
&lt;p>为了降低微服务架构的落地成本，来自腾讯、快手、字节跳动、好未来、七牛云和蓝色光标等多家企业的技术专家在 NextArch 基金会成立微服务技术小组，共同探讨各自企业在微服务领域中遇到的问题，分享大家在生产过程中的实践经验，并且面向不同的应用场景和终端用户，联合相关开源社区输出标准化的解决方案。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/CloudWeGo_helps_NextArch/community.png" alt="image">&lt;/p>
&lt;p>在采用微服务架构之前，我们需要思考为什么采用微服务架构，并不是所有的开发团队和发展阶段都适合采用微服务架构。通常，采用微服务架构可以解决以下问题：首先，开发团队具有一定的规模，所有成员共同开发一个单体应用的内耗太高，如果采用微服务架构，每个服务可以由单个或者少数成员独立负责。第二，业务系统的功能模块很多，耦合在一起会增加测试和部署的成本，任何一个模块故障也会导致整个系统故障。第三，功能模块之间的负载无法隔离，容易互相影响，没有办法针对热点模块的计算层或者存储层进行扩容。&lt;/p>
&lt;p>如果我们采用微服务架构，单个服务是⾮常简单的，但是，分布式服务之间的功能调用远⽐单体应用内部更加复杂。在单体应用中，⼀个函数可以调⽤其他任何一个公共函数。在微服务架构中，一个函数只可以调⽤同⼀个微服务的函数。如何实现分布式服务之间的通信是微服务架构的首要问题，构建高性能、高可用的远程调用能力并不容易。值得庆幸的是，已经有 grpc、thrift、tars、go-zero、GoFrame、&lt;a href="https://github.com/cloudwego/kitex">cloudwego/kitex&lt;/a> 和 spring cloud 等大量开源的分布式服务开发框架，这些框架可以帮助终端用户快速地构建微服务。不幸的是，仅仅把服务开发出来并且跑通是不够的，保障大规模服务的稳定运营还需要考虑诸多问题，例如：在分布式架构中如何处理基础设施以及应用层的各种异常、如何实现大规模服务的无损发布和流量调度，如何定位和分析复杂调用链路中出现的问题等。对于中大型企业来说，还存在异构的开发技术栈和运行时环境，存在跨地域和混合云的架构要求，如何在更加复杂的应用场景中解决上述问题，面临更多的挑战。&lt;/p>
&lt;p>目前，这个方向还没有开箱即用的解决方案，终端用户必须在不同的基础设施和适当的工具之间做出抉择，才能解决各种问题。近日，NextArch 微服务技术小组向基金会提交了首个提案，根据各自企业在分布式或者微服务生产实践中的经验和痛点，面向多语言、多框架和异构基础设施，针对不同行业和应用场景输出微服务落地的标准化方案，并且依托相关开源社区提供推荐实现，方便终端用户落地。我们也期待更多企业和开源社区加入 NextArch 基金会，共同探讨分布式或者微服务治理的标准化方案。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/CloudWeGo_helps_NextArch/framework.png" alt="image">&lt;/p>
&lt;h3 id="部分-nextarch-microservice-sig-成员引文">部分 NextArch Microservice SIG 成员引文：&lt;/h3>
&lt;p>&lt;strong>PolarisMesh 单家骏&lt;/strong>&lt;/p>
&lt;p>腾讯云专家工程师，具备 10 年以上中间件研发经验。北极星开源社区（PolarisMesh）联合发起人，负责开源项目的技术规划、代码开发和社区运营等工作。&lt;/p>
&lt;p>自分布式架构发展至今，微服务成为了复杂业务系统的首选模式，在企业得到了充分的生产落地，然而各个微服务框架及工具链，对于微服务治理体系的理解存在差异性，使得业务系统在实现微服务治理上存在较大的成本，同时也不利于微服务技术的沉淀及长期发展。北极星是腾讯自研和开源的微服务治理框架，覆盖了腾讯内部 90% 以上的业务，解决了业务系统因多语言、多框架以及业务差异性所带来的服务治理不一致的问题，在腾讯内部完成了服务发现和治理的标准化。我们期望通过加入 NextArch 基金会这样一个中立组织，可以讨论业界微服务治理的相关实践及解决方案，沉淀出标准化的服务治理体系，促进微服务生态的进一步发展，也期望北极星开源社区可以推动并承载微服务治理标准体系的落地。&lt;/p>
&lt;p>&lt;strong>go-zero 万俊峰&lt;/strong>&lt;/p>
&lt;p>万俊峰，七牛云技术副总裁，go-zero 开源社区/go-zero 作者。负责 go-zero 框架的规划、代码编写、代码 review、工具链规划、社区建设、开源推广&lt;/p>
&lt;p>微服务在发展了这么多年之后，已经呈现出百花齐放的状态，各种微服务框架和治理能力在很多公司都得到了充分的落地，并带来了巨大的业务价值。但当前的现状也没有形成足够的技术共识和规范，我们需要进一步提炼和抽象微服务的能力，并加以标准化。这样可以更好的沉淀经验，并将各语言的微服务框架提供规划化对接，从而推动微服务技术的进一步发展。同时也期望在 SIG 组织能够更多的讨论微服务落地的各种最佳实践，也期望能够通过 go-zero 开源社区帮助推动共识的微服务治理标准落地。&lt;/p>
&lt;p>&lt;strong>GoFrame 郭强&lt;/strong>&lt;/p>
&lt;p>腾讯高级工程师，GoFrame 开源框架项目发起人及主要贡献者，负责 GoFrame 框架发展规划、社区建设维护、核心代码开发。GoFrame 是一款模块化、高性能、企业级的 Go 基础开发框架。&lt;/p>
&lt;p>微服务是一种架构设计思想，目的是为了有效解决业务复杂度提高带来的项目架构问题。微服务需要解决的不仅是技术问题，也是项目协作问题。在&amp;quot;微服务化&amp;quot;过后，项目架构将引入更多的痛点：职责边界界定、服务高效通信、分布事务处理、微服务化治理、服务版本管理、项目迭代协作等等。微服务思想发展至今，这些痛点的解决方案已比较成熟，并且大同小异。NextArch 微服务 SIG 需要做的是在这些方案之上分析共性之处，形成统一化和规范化的解决方案。以帮助企业更快速地实现微服务化，同时，也需要提供一些最佳实践，帮助企业提高在服务化后的项目管理手段。80% 的解决方案抽象，20% 的最佳实践沉淀。&lt;/p>
&lt;p>&lt;strong>CloudWeGo 罗广明&lt;/strong>&lt;/p>
&lt;p>字节跳动微服务架构师，CloudWeGo 开源负责人。CloudWeGo 是一套由字节跳动开源的、可快速构建企业级云原生架构的中间件集合，专注于解决微服务通信与治理的难题，具备高性能、可扩展、高可靠的特点。&lt;/p>
&lt;p>微服务技术发展至今，业界涌现出一大批微服务开发框架、技术和最佳实践。这个多样化是不可避免的，没有一个微服务开发框架能够统一所有的语言，但是微服务架构里面所涉及的服务治理体系，却可以做到统一和规范化。NextArch 微服务 SIG 正是在这样的背景下诞生了，旨在提供统一服务治理体系，解决共性问题，将促进微服务框架和技术的进一步演进和发展。&lt;/p></description></item><item><title>Blog: 一文了解字节跳动微服务中间件 CloudWeGo</title><link>https://www.cloudwego.io/zh/blog/2022/03/28/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6-cloudwego/</link><pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/03/28/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6-cloudwego/</guid><description>
&lt;p>云原生时代，各行各业的基础架构都在经历微服务架构转型，研发效率和稳定性是所有互联网公司需要考虑的问题。开发者想要搭建微服务，离不开配套的微服务治理，如治理平台、监控、链路跟踪、注册/发现、配置中心、服务网格等。
随着 Golang 逐渐成为云原生时代的主要编程语言，基于 Golang 的微服务中间件在开源社区有着较强的诉求。&lt;/p>
&lt;p>字节跳动也同样面临这些问题。2014 年，字节跳动引入 Golang 解决长连接推送业务面临的高并发问题，两年后，内部技术团队基于 Golang 推出了一个名为 Kite 的框架，
同时对开源项目 Gin 做了一层很薄的封装，推出了 Ginex。字节跳动基础架构/服务框架团队负责人成国柱在 QCon 2021 的分享中表示，这两个原始框架的推出，极大推动了 Golang 在公司内部的应用。&lt;/p>
&lt;p>但是由于关联技术迭代和业务诉求增加，深度耦合的 Kite 和 Thrift ，很难从网络模型或编解码层面改造优化，继续支持新特性势必会造成代码臃肿、迭代受阻问题。
2019 年下半年，字节跳动技术团队开始重新设计 Golang RPC 框架，同时为了在网络通信上有更好的性能并能支持连接多路复用、感知连接状态，自研了网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>。&lt;/p>
&lt;p>字节跳动重构 Kite 为 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> ，围绕性能和可扩展性设计，并在次年 10 月完成发布，投入到内部应用中。
据悉，截至 2021 年 9 月，线上有 3w+ 微服务使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>，大部分服务迁移新框架后可以收获 CPU 和延迟上的收益。&lt;/p>
&lt;p>“在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 得到内部广泛使用后，我们决定围绕微服务逐步把我们的实践开源出去，并且对外保持统一。
”字节跳动 CloudWeGo 技术专家谈道，“但微服务相关的项目较多，每个项目单独开源对外部用户并不友好，因此我们以 CloudWeGo 作为项目名，逐步将内部整个微服务体系开源，内外统一使用开源库，各项目以开源库为主进行迭代。”&lt;/p>
&lt;p>2021 年 9 月 8 日，字节跳动宣布正式开源 CloudWeGo。&lt;/p>
&lt;h2 id="中间件工具箱cloudwego">&lt;strong>中间件“工具箱”CloudWeGo&lt;/strong>&lt;/h2>
&lt;p>CloudWeGo 是一套字节跳动内部微服务中间件集合，具备高性能、强扩展性和稳定性的特点，专注于解决微服务通信与治理的难题，满足不同业务在不同场景的诉求。
此外，CloudWeGo 也重视与云原生生态的集成，支持对接 K8s 注册中心、Prometheus 监控以及 OpenTracing 链路追踪等。&lt;/p>
&lt;p>目前，CloudWeGo 第一批开源了四个项目：&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>、&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>、&lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 和 &lt;a href="https://github.com/cloudwego/netpoll-http2">netpoll-http2&lt;/a>，
以 RPC 框架 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 为主。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 内置了部分治理策略以及丰富的扩展接口，便于融入微服务体系中；&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 主要面向对高性能有诉求的场景。&lt;/p>
&lt;p>CloudWeGo 的每一个组件都可以单独使用。“很多人担心 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 是一个很重的框架，其实 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 没有耦合任何其他组件包括 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 内置的一些治理能力，用户也可以选择性集成。
&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 作为一个网络库，其他 RPC 框架、HTTP 框架都可以单独接入使用。&lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 是 Thrift IDL 解析和代码生成器，也是独立的工具，并且提供插件机制，用户可定制生成代码。”
字节跳动 CloudWeGo 技术专家表示，“我们会继续开源其他内部项目，如 HTTP 框架 Hertz、基于共享内存的 IPC 通信库 ShmIPC 等，提供更多场景的微服务需求支持。”&lt;/p>
&lt;h2 id="cloudwego-的优势和局限">&lt;strong>CloudWeGo 的优势和局限&lt;/strong>&lt;/h2>
&lt;p>微服务中间件和业务紧密联系，是整个业务架构的基础，在进行技术选型时必须慎重。业内公认的选型标准关键在于两方面：&lt;/p>
&lt;ul>
&lt;li>能解决实际业务问题和上生产抗流量，且易用性高、可治理、成熟稳定&lt;/li>
&lt;li>技术是开源的，且开源项目的 star 数、项目活跃度（Issue&amp;amp;PR）、文档更新频率、发版周期稳定可靠&lt;/li>
&lt;/ul>
&lt;p>CloudWeGo 的优势在于，已经在字节跳动经过大规模生产流量验证，有可以参考的稳定性和可靠性实际案例。“CloudWeGo 的特点之一是高性能，但实际上在开发之初它经常遇到性能瓶颈，
于是内部专门进行了网络库、Thrift 序列化的专项优化，优化的过程会比较漫长，一个瓶颈点要花很长时间反复测试调整实现，我们也发过两篇文章&lt;a href="http://www.cloudwego.io/zh/blog/2021/09/23/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-go-rpc-%E6%A1%86%E6%9E%B6-kitex-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/">《字节跳动 Go RPC 框架 Kitex 性能优化实践》&lt;/a>和&lt;a href="http://www.cloudwego.io/zh/blog/2021/10/09/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%9C%A8-go-%E7%BD%91%E7%BB%9C%E5%BA%93%E4%B8%8A%E7%9A%84%E5%AE%9E%E8%B7%B5/">《字节跳动在 Go 网络库上的实践》&lt;/a>分享了优化实践。”字节跳动 CloudWeGo 技术专家表示。&lt;/p>
&lt;p>据悉，与同类型项目相比，CloudWeGo 开发团队不仅考虑了高性能、强扩展性，还考虑到了易用性。“以 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 为例，目前从治理功能的多样性上不及一些开源框架，
从性能、扩展性、使用体验多维度综合来看，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 具有一定的优势。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持多协议，由于内部以 Thrift 为主，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Thrift 支持也做了性能优化，
如果使用 Thrift，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 将是最佳的选择。”字节跳动 CloudWeGo 技术专家告诉 InfoQ。&lt;/p>
&lt;p>此外，为了遵守长期投入承诺，内外维护一套代码、统一迭代，字节跳动已经将与内部生态没有耦合的项目直接迁移到 CloudWeGo 开源库，并将内部依赖调整为开源库。
而对于需要集成治理能力融入微服务体系的 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>，开源团队则对内外部代码做了拆分，把 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的核心代码迁移到开源库，内部库封装一层壳保证用户无感知升级，
而集成内部治理特性的模块则作为 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的扩展保留在内部库。未来，字节跳动也会持续把已经在内部经过稳定性验证的新特性，迁移到开源库。&lt;/p>
&lt;p>在字节跳动内部，为了便于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 融入内部的治理体系，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 面向内部提供了 Byted Suite 扩展，集成内部的注册中心、配置中心、监控等，内部 ServiceMesh 已经得到了大规模落地，
&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 会根据服务的信息判断是否是 ServiceMesh 模式，若是，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 则会卸载治理组件，治理能力下沉至 Mesh 中。
为了提高与 ServiceMesh 通信的性能，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 单独扩展 TransHandler 模块集成内部实现的 ShmIPC，与 ServiceMesh 通信走 ShmIPC ，后续 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 ShmIPC 的扩展以及 ShmIPC 库也会开源出来。&lt;/p>
&lt;p>不过 CloudWeGo 依然有自己的局限性。字节跳动 CloudWeGo 技术专家告诉 InfoQ：CloudWeGo 功能的丰富度和多样性还不够，还需要进一步完善，字节跳动技术团队会收集外部用户的需求，评估排期支持，期待更多的开发者加入。
目前 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> Server 性能优势明显，但 Client 相比 Server 性能表现不佳，后续会重点对 Client 进行优化。此外，基于不同的语言框架，默认场景必须能兼容互通而非性能最佳。
“刚开源时得到大家的关注，看到一些压测对比显示 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 性能表现一般，主要是压测场景未对齐，后续我们也会考虑面向开源尽量提供性能较优的策略。”&lt;/p>
&lt;h2 id="开源不是为了完成-kpi-">&lt;strong>“开源”不是为了“完成 KPI ”&lt;/strong>&lt;/h2>
&lt;p>目前，CloudWeGo 在社区中也比较有活力。据悉，在未被正式宣布开源前，一个月内 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 收获了 1.2k stars，&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 收获了 700+ stars。
9 月 8 日，字节跳动正式宣布开源 CloudWeGo 后，截至 10 月初，项目整体 star 数已经超过 4800，且已被收录进 CNCF landscape。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/article_to_learn_about_CloudWeGo/image.png" alt="image">&lt;/p>
&lt;p>字节跳动 CloudWeGo 技术专家表示：“我们收到了来自社区的大量反馈，如很多用户对 Protobuf 的诉求较为强烈，我们已经针对这个问题，计划开展 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Protobuf 支持的性能优化。
欢迎大家向 CloudWeGo 提交 issue 和 PR，共建 CloudWeGo。我们也为企业和组织使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 设置了专项支持，希望 CloudWeGo 将来能真正成为通用的、可落地的微服务通信与治理开源方案。”&lt;/p>
&lt;p>关于开源，字节跳动 CloudWeGo 技术专家的观点旗帜鲜明：“完成 KPI 不是这个项目开源的目的。健康的开源模式注重开放共享，共同成长和长期主义。CloudWeGo 认同个体参与、社区价值以及开源共同体带来的归属感。”&lt;/p>
&lt;p>“字节跳动作为开源项目的受益者、参与者，也希望成为开源项目的推动者、主导者，将内部优秀的最佳实践反馈给开源社区，与社区共同建设、丰富基础架构领域开源生态，为广大开发者和企业在技术选型时提供更多更优的选择。”
字节跳动 CloudWeGo 技术专家谈道，“我们拥抱开源的文化，倾听社区的反馈，积极响应用户的需求，并且提供友好的中英文文档和快速开发 guideline，为社区开发者快速深入了解 CloudWeGo 以及参与贡献提供便利与支持。”&lt;/p>
&lt;p>&lt;strong>项目地址：&lt;/strong>&lt;a href="https://github.com/cloudwego">https://github.com/cloudwego&lt;/a>&lt;/p>
&lt;p>&lt;strong>受访嘉宾:&lt;/strong> 字节跳动 CloudWeGo 技术专家罗广明、杨芮、马子昂&lt;/p>
&lt;p>&lt;strong>原文链接:&lt;/strong> &lt;a href="https://www.infoq.cn/article/9ixlu4kjapg3ufhymm3j">https://www.infoq.cn/article/9ixlu4kjapg3ufhymm3j&lt;/a>&lt;/p></description></item><item><title>Blog: Kitex v0.2.1 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/03/24/kitex-v0.2.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/03/24/kitex-v0.2.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="bugfix">Bugfix&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/383">#383&lt;/a> ] 修复(generic)：在泛化调用的时候检查 IDL 是否有循环依赖。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/359">#359&lt;/a> ] 修复(tool)：修复 protobuf CombineService 缺失 streaming 引用的问题。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/363">#363&lt;/a> ] 修复(client)：修复 oneway 请求的 sequence ID 没有被编码的问题以及降低 oneway 调用的丢包率。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/367">#367&lt;/a> ] 修复(generic/tool)：修复 CombineServices 可能存在多次加载同一个 service 问题。&lt;/li>
&lt;/ul>
&lt;h2 id="optimise">Optimise&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/362">#362&lt;/a> ] 优化(diagnosis)：lbcaches 是全局的，无需为每个 client 注册 ProbeFunc 用于诊断查询。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/374">#374&lt;/a> ] 优化(rpcinfo)：RPCInfo.To().Tag() 优先使用服务发现的 instance tag 而不是 remoteinfo tag。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/355">#355&lt;/a> ] 优化(连接池)：修改默认的连接池最小空闲等待时间为 2s。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/354">#354&lt;/a> ] 优化(hook)：为 &lt;code>onServerStart&lt;/code>和 &lt;code>onShutdown&lt;/code>添加资源锁，当做一些如&lt;code>RegisterStartHook&lt;/code>和 &lt;code>server.Run&lt;/code>中的 &lt;code>range&lt;/code>之类的读写操作时请求对应的资源锁。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/331">#331&lt;/a> ] 优化(discovery)：增加「实例不存在」错误定义。&lt;/li>
&lt;/ul>
&lt;h2 id="refactor">Refactor&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/352">#352&lt;/a> ] 重构(event)：删除额外的原子操作并用普通赋值操作替换。&lt;/li>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/343">#343&lt;/a> ] 重构(loadbalancer)：将 buildWeightedVirtualNodes 函数合入 buildVirtualNodes 函数中，成为一个函数。&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/376">#376&lt;/a> ] 升级依赖 choleraehyq/pid 以兼容Go 1.18。&lt;/li>
&lt;/ul>
&lt;h2 id="docs">Docs&lt;/h2>
&lt;ul>
&lt;li>[&lt;a href="https://github.com/cloudwego/kitex/pull/364">#364&lt;/a> ] 更新 README 到新博客的链接。&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.2.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/02/24/kitex-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/02/24/kitex-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="feature">Feature&lt;/h2>
&lt;ul>
&lt;li>Feat(grpc): gRPC 相关配置支持通过 options 来设置，并且为了兼容旧版本默认窗口大小调整为 64K&lt;/li>
&lt;li>Feat(kerror): 为 basicError 添加新的 error 封装 func WithCauseAndExtraMsg&lt;/li>
&lt;li>Feat(rpcinfo): 添加 FreezeRPCInfo 以支持异步 context 使用&lt;/li>
&lt;li>Feat(codec): 默认编解码器支持限定包体积大小&lt;/li>
&lt;/ul>
&lt;h2 id="bugfix">Bugfix&lt;/h2>
&lt;ul>
&lt;li>Fix(remotecli): 修复重置的连接可能被复用的问题&lt;/li>
&lt;li>Fix(generic): 修复泛化调用的客户端不能使用继承的 service 的方法的问题&lt;/li>
&lt;li>Fix(generic): 修复泛化调用 client 侧判断 Oneway 不准确的问题&lt;/li>
&lt;/ul>
&lt;h2 id="optimise">Optimise&lt;/h2>
&lt;ul>
&lt;li>Optimize(retry): 提高异常重试的重试成功率&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果超时的请求先于重试的请求返回，可能会导致重试请求也失败；同时也可以避免超时请求不必要的解码处理。&lt;/p>
&lt;/blockquote>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>Chore: 升级 netpoll 的版本至 v0.2.0&lt;/li>
&lt;li>Chore: 添加第三方库的license&lt;/li>
&lt;/ul></description></item><item><title>Blog: Netpoll v0.2.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/02/22/netpoll-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/02/22/netpoll-v0.2.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="improvement">Improvement&lt;/h2>
&lt;ul>
&lt;li>Feat: 添加 OnConnect 回调&lt;/li>
&lt;li>Feat: 新增 Until API&lt;/li>
&lt;li>Feat: 支持不带 timeout 的 dial&lt;/li>
&lt;/ul>
&lt;h2 id="fix">Fix&lt;/h2>
&lt;ul>
&lt;li>Fix: 修复当只设置了 onConnect 回调时，不会触发 close callback 的 bug&lt;/li>
&lt;li>Fix: 添加最大节点限制，避免异常情况下的 OOM 问题&lt;/li>
&lt;li>Fix: 修复 reset operator 时，没有 reset OnWrite 的问题&lt;/li>
&lt;li>Fix: 修复连接关闭时，写 panic 的问题&lt;/li>
&lt;li>Fix: 修复单测失败问题&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>docs: 更新 readme&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.1.4 版本发布</title><link>https://www.cloudwego.io/zh/blog/2022/01/18/kitex-v0.1.4-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2022/01/18/kitex-v0.1.4-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="功能优化">功能优化&lt;/h2>
&lt;ul>
&lt;li>在 rpctimeout 的 middleware 的输出日志中过滤掉超时日志&lt;/li>
&lt;li>调整默认日志级别为 Info&lt;/li>
&lt;li>给 sentAt 变量加锁，避免单测出现 DATA RACE，实际上不会有并发问题&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复客户端编码失败时连接会泄漏的问题&lt;/li>
&lt;li>修复 middleware builder 中设置 TimeoutAdjust 不生效的问题&lt;/li>
&lt;/ul>
&lt;h2 id="工具">工具&lt;/h2>
&lt;ul>
&lt;li>修复 protobuf 的 handler 参数名&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>kitex 会给每个 stream server 生成一个名为 &amp;ldquo;{{.ServiceName}}&lt;em>{{.Name}}Server&amp;rdquo; 的 stream 类型，
但是在 handler.go 中使用的是 &amp;ldquo;{{.ServiceName}}&lt;/em>{{.RawName}}Server&lt;/p>
&lt;/blockquote>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>删除不必要的类型转换&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.1.3 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/12/30/kitex-v0.1.3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/12/30/kitex-v0.1.3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="功能优化">功能优化&lt;/h2>
&lt;ul>
&lt;li>JSON 泛化调用场景，向服务端传递 Base 信息，从而服务端可获取 Caller 等信息&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复 streaming 的 metric 上报（server侧）丢失 method 信息的问题&lt;/li>
&lt;li>修复 JSON 和 HTTP 泛化中 base64 和 binary 的不兼容改动&lt;/li>
&lt;li>修复 gRPC 流控相关的问题，该问题会导致 client 侧出现持续超时&lt;/li>
&lt;/ul>
&lt;h2 id="ci">CI&lt;/h2>
&lt;ul>
&lt;li>增加场景测试&lt;/li>
&lt;/ul>
&lt;h2 id="chore">Chore&lt;/h2>
&lt;ul>
&lt;li>更新了 &lt;a href="https://github.com/cloudwego/kitex/blob/develop/ROADMAP.md">ROADMAP&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.1.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/12/22/kitex-v0.1.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Wed, 22 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/12/22/kitex-v0.1.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="hotfix">Hotfix&lt;/h2>
&lt;ul>
&lt;li>修复 v0.1.0 gRPC 请求优化引入的部分问题&lt;/li>
&lt;li>修复 IDL 中未定义 package 时，gRPC 的方法信息错误问题&lt;/li>
&lt;/ul>
&lt;h2 id="依赖更新">依赖更新&lt;/h2>
&lt;ul>
&lt;li>更新 netpoll-http2 依赖，解决 streaming 场景下大包（&amp;gt;4K）请求报错的问题&lt;/li>
&lt;/ul>
&lt;h2 id="杂项">杂项&lt;/h2>
&lt;ul>
&lt;li>使用 GitHub 的 PR 模板，强制开发者提交 PR 时填写相关描述&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.1.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/12/13/kitex-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/12/13/kitex-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="功能">功能&lt;/h2>
&lt;h3 id="泛化调用">泛化调用&lt;/h3>
&lt;ul>
&lt;li>IDL 解析支持多 Service&lt;/li>
&lt;li>暴露 SetSeqID 方法便于二进制泛化场景 server 侧使用&lt;/li>
&lt;li>泛化 client 支持关闭，规避内存泄漏问题&lt;/li>
&lt;/ul>
&lt;h3 id="日志">日志&lt;/h3>
&lt;ul>
&lt;li>修改日志风格，使用 &amp;ldquo;key=value&amp;rdquo; 列出信息&lt;/li>
&lt;li>使用 klog 作为全局的日志输出工具&lt;/li>
&lt;li>使用全局的 default logger&lt;/li>
&lt;li>日志打印更多 context 信息，例如 logId，方便问题排查&lt;/li>
&lt;li>go func 传入服务信息用于 recover panic 后输出关键信息方便问题排查&lt;/li>
&lt;/ul>
&lt;h3 id="option">Option&lt;/h3>
&lt;ul>
&lt;li>增加 NewThriftCodecDisableFastMode 方法，来关闭 FastWrite 和 FastRead&lt;/li>
&lt;li>Kitex server 支持端口复用&lt;/li>
&lt;li>默认 RPC 超时设置为 0（在后续 PR 中，revert 了该变更）&lt;/li>
&lt;/ul>
&lt;h3 id="proxy">Proxy&lt;/h3>
&lt;ul>
&lt;li>Proxy 增加 ContextHandler 接口用于传递初始化ctx给 mwbuilder&lt;/li>
&lt;li>注册 lbcache 的 Dump 给 diagnosis，用于问题诊断&lt;/li>
&lt;li>将 PRCConfig 传递给 proxy.Config&lt;/li>
&lt;/ul>
&lt;h2 id="优化">优化&lt;/h2>
&lt;ul>
&lt;li>减少了对象的堆分配&lt;/li>
&lt;li>优化多路复用性能&lt;/li>
&lt;li>优化 grpc 编解码性能，通过 Release 时释放(Close) LinkBuffer&lt;/li>
&lt;li>在计算 backup request 的消耗(cost)时，区分 ErrRPCFinish&lt;/li>
&lt;li>多路复用分片队列逻辑移动至 netpoll/mux，并重命名分片字典&lt;/li>
&lt;li>优化Fast api中容器类型的长度编码逻辑&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复 server 端 WithErrorHandler 配置不生效问题&lt;/li>
&lt;li>调整 lbcache 中的 Balancer 初始化逻辑&lt;/li>
&lt;li>修复 TraceCtl 可能为 nil 的问题(仅影响单测)&lt;/li>
&lt;li>设置默认的 rpc timeout, 并支持设置 WithRPCTimeout(0) 来关闭超时中间件&lt;/li>
&lt;li>修复 default logger 使用错误的 call depth&lt;/li>
&lt;li>重命名 BackwardProxy 为 ReverseProxy&lt;/li>
&lt;li>修复 grpc 场景下的 panic&lt;/li>
&lt;li>修复 grpc 场景下的潜在风险（keepalive 超时导致 panic）&lt;/li>
&lt;li>修复 void 方法中的异常缺失&lt;/li>
&lt;li>修复实例变更时 dump 信息不正确问题。&lt;/li>
&lt;/ul>
&lt;h2 id="文档">文档&lt;/h2>
&lt;ul>
&lt;li>修复失效的中文链接&lt;/li>
&lt;li>将全部 doc 移至官网 cloudwego.io&lt;/li>
&lt;/ul>
&lt;h2 id="netpoll-api-change">Netpoll API Change:&lt;/h2>
&lt;ul>
&lt;li>适应 netpoll.Writer.Append 的 API 改动，返回值从 2个 变为 1个&lt;/li>
&lt;/ul>
&lt;h2 id="依赖变化">依赖变化&lt;/h2>
&lt;ul>
&lt;li>github.com/cloudwego/netpoll: v0.0.4 -&amp;gt; v0.1.2&lt;/li>
&lt;/ul></description></item><item><title>Blog: Netpoll v0.1.2 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/12/13/netpoll-v0.1.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/12/13/netpoll-v0.1.2-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>LinkBuffer 增加了空值校验&lt;/li>
&lt;/ul></description></item><item><title>Blog: Netpoll v0.1.1 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/12/09/netpoll-v0.1.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/12/09/netpoll-v0.1.1-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="优化">优化:&lt;/h2>
&lt;ul>
&lt;li>优化了多路复用下，分片队列的性能&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>修复了 book 方法在多路复用下的 bug&lt;/li>
&lt;/ul>
&lt;h2 id="文档">文档&lt;/h2>
&lt;ul>
&lt;li>修正了一些大小写和语法问题，并更新了链接&lt;/li>
&lt;/ul></description></item><item><title>Blog: Netpoll v0.1.0 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/12/01/netpoll-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/12/01/netpoll-v0.1.0-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="功能">功能:&lt;/h2>
&lt;ul>
&lt;li>增加了分片队列，用于支持连接多路复用&lt;/li>
&lt;li>优化方案：尽可能的维护单节点 LinkBuffer 来减少 copy&lt;/li>
&lt;li>优化方案：修复了 waitReadSize 的 bug，并优化了 input trigger 效率&lt;/li>
&lt;li>优化方案：减少了 waitRead 和 inputAck 冲突时产生的超时错误&lt;/li>
&lt;li>逻辑简化：简化了连接状态机&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>修复了 eventLoop 提前 GC 的 bug&lt;/li>
&lt;/ul>
&lt;h2 id="文档">文档&lt;/h2>
&lt;ul>
&lt;li>更新 README，将 Performance 部分移动至 netpoll-benchmark 项目&lt;/li>
&lt;li>更新了 reference，添加了官网信息，移除了 change log&lt;/li>
&lt;/ul>
&lt;h2 id="重大变更">重大变更&lt;/h2>
&lt;ul>
&lt;li>WriteBuffer 返回值由 (n int, err error) 改为 (err error)&lt;/li>
&lt;/ul></description></item><item><title>Blog: RPC 框架 Kitex 实践入门：性能测试指南</title><link>https://www.cloudwego.io/zh/blog/2021/11/24/rpc-%E6%A1%86%E6%9E%B6-kitex-%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</link><pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/11/24/rpc-%E6%A1%86%E6%9E%B6-kitex-%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</guid><description>
&lt;p>日前，字节跳动服务框架团队正式开源 CloudWeGo ，在抖音、今日头条均有深度应用的 Golang 微服务 RPC 框架 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 也包含在其中。&lt;/p>
&lt;p>本文旨在分享开发者在压测 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 时需要了解的场景和技术问题。这些建议有助于用户更好地结合真实 RPC 场景对 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 进行调优，使之更贴合业务需要、发挥最佳性能。用户也可以参考官方提供的压测项目 &lt;a href="https://github.com/cloudwego/kitex-benchmark">kitex-benchmark&lt;/a> 了解更多细节。&lt;/p>
&lt;h2 id="微服务场景的特点">微服务场景的特点&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 诞生于字节跳动大规模微服务架构实践，面向的场景自然是微服务场景，因此下面会先介绍微服务的特点，方便开发者深入理解 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在其中的设计思考。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>RPC 通信模型&lt;/p>
&lt;p>微服务间的通信通常以 PingPong 模型为主，所以除了常规的吞吐性能指标外，每次 RPC 的平均时延也是开发者需要考虑的点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复杂的调用链路&lt;/p>
&lt;p>一次 RPC 调用往往需要多个微服务协作完成，而下游服务又会有其自身依赖，所以整个调用链路会是一个复杂的网状结构。
在这种复杂调用关系中，某个中间节点出现的延迟波动可能会传导到整个链路上，导致整体超时。当链路上的节点足够多时，即便每个节点的波动概率很低，最终汇聚到链路上的超时概率也会被放大。
所以单一服务的延迟波动 —— 即 P99 延迟指标，也是一个会对线上服务产生重大影响的关键指标。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>包体积大小&lt;/p>
&lt;p>虽然一个服务通信包的大小取决于实际业务场景，但在字节跳动的内部统计中，我们发现线上请求大多以小包（&amp;lt;2KB）为主，所以在兼顾大包场景的同时，也重点优化了小包场景下的性能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="针对微服务场景进行压测">针对微服务场景进行压测&lt;/h2>
&lt;h3 id="确定压测对象">确定压测对象&lt;/h3>
&lt;p>衡量一个 RPC 框架的性能需要从两个视角分别去思考：Client 视角与 Server 视角。在大规模的业务架构中，上游 Client 不见得使用的也是下游的框架，而开发者调用的下游服务也同样如此，如果再考虑到 Service Mesh 的情况就更复杂了。&lt;/p>
&lt;p>一些压测项目通常会把 Client 和 Server 进程混部进行压测，然后得出&lt;strong>整个框架&lt;/strong>的性能数据，这其实和线上实际运行情况很可能是不符的。&lt;/p>
&lt;p>如果要压测 Server，应该给 Client 尽可能多的资源，把 Server 压到极限，反之亦然。如果 Client 和 Server 都只给了 4 核 CPU 进行压测，会导致开发者无法判断最终得出来的性能数据是哪个视角下的，更无法给线上服务做实际的参考。&lt;/p>
&lt;h3 id="对齐连接模型">对齐连接模型&lt;/h3>
&lt;p>常规 RPC 的连接模型主要有三种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>短连接&lt;/strong>：每次请求都创建新连接，得到返回后立即关闭连接&lt;/li>
&lt;li>&lt;strong>长连接池&lt;/strong>：单个连接同时只能处理一次完整请求与返回&lt;/li>
&lt;li>&lt;strong>连接多路复用&lt;/strong>：单个连接可以同时异步处理多个请求与返回&lt;/li>
&lt;/ul>
&lt;p>每类连接模型没有绝对好坏，取决于实际使用场景。连接多路复用虽然一般来说性能相对最好，但应用上必须依赖协议能够支持包序列号，且一些老框架服务可能也并不支持多路复用的方式调用。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 最早为保证最大程度的兼容性，在 Client 端默认使用了短连接，而其他主流开源框架默认使用连接多路复用，这导致一些用户在使用默认配置压测时，出现了比较大的性能数据偏差。&lt;/p>
&lt;p>后来为了契合开源用户的常规使用场景，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在 v0.0.2 中也加入了&lt;a href="https://github.com/cloudwego/kitex/pull/40/files">默认使用长连接&lt;/a>的设置。&lt;/p>
&lt;h3 id="对齐序列化方式">对齐序列化方式&lt;/h3>
&lt;p>对于 RPC 框架来说，不考虑服务治理的话，计算开销主要都集中在序列化与反序列化中。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对于 Protobuf 的序列化使用的是官方的 &lt;a href="https://github.com/golang/protobuf">Protobuf&lt;/a> 库，对于 Thrift 的序列化，则专门进行了性能优化，这方面的内容在&lt;a href="https://www.cloudwego.io/zh/blog/2021/09/23/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-go-rpc-%E6%A1%86%E6%9E%B6-kitex-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/#thrift-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%98%E5%8C%96">官网博客&lt;/a>中有介绍。&lt;/p>
&lt;p>当前开源框架大多优先支持 Protobuf，而部分框架内置使用的 Protobuf 其实是做了许多性能优化的 &lt;a href="https://github.com/gogo/protobuf">gogo/protobuf&lt;/a> 版本，但由于 gogo/protobuf 当前有&lt;a href="https://github.com/gogo/protobuf/issues/691">失去维护的风险&lt;/a>，所以出于可维护性角度考虑，我们依然决定只使用官方的 Protobuf 库，当然后续我们也会计划对 Protobuf 进行优化。&lt;/p>
&lt;h3 id="使用独占-cpu">使用独占 CPU&lt;/h3>
&lt;p>虽然线上应用通常是多个进程共享 CPU，但在压测场景下，Client 与 Server 进程都处于极端繁忙的状况，如果同时还共享 CPU 会导致大量上下文切换，从而使得数据缺乏可参考性，且容易产生前后很大波动。&lt;/p>
&lt;p>所以我们建议是将 Client 与 Server 进程隔离在不同 CPU 或者不同独占机器上进行。如果还想要进一步避免其他进程产生影响，可以再加上 nice -n -20 命令调高压测进程的调度优先级。&lt;/p>
&lt;p>另外如果条件允许，相比云平台虚拟机，使用真实物理机会使得测试结果更加严谨与具备可复现性。&lt;/p>
&lt;h2 id="性能数据参考">性能数据参考&lt;/h2>
&lt;p>在满足上述要求的前提下，我们对多个框架使用 Protobuf 进行了压测对比，压测代码在 kitex-benchmark 仓库。在充分压满 Server 的目标下，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在连接池模式下的 P99 Latency 在所有框架中最低。而在多路复用模式下，Kitex 在各指标上也都具有更加明显的优势。&lt;/p>
&lt;p>&lt;strong>配置：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Client 16 CPUs，Server 4 CPUs&lt;/li>
&lt;li>1KB 请求大小，Echo 场景&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>参考数据：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>KITEX：连接池模式（默认模式）&lt;/li>
&lt;li>KITEX-MUX：多路复用模式&lt;/li>
&lt;li>其他框架均使用多路复用模式&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/kitex_performance_testing/qps.png" alt="image">
&lt;img src="https://www.cloudwego.io/img/blog/kitex_performance_testing/tp99.png" alt="image">&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>在当前主流的 Golang 开源 RPC 框架中，每个框架其实在设计目标上都各有侧重：有些框架侧重于通用性，有些侧重于类似 Redis 这种轻业务逻辑的场景，有些侧重于吞吐性能，而有些则更侧重 P99 时延。&lt;/p>
&lt;p>字节跳动的业务在日常迭代中，常常会出现因某个 feature 导致一个指标上升，另一个指标下降的情况，因此 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 在设计之初就更倾向于解决大规模微服务场景下各种问题。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 发布后，我们接到了大量来自用户的自测数据，感谢社区对我们的关注和支持，也欢迎广大开发者基于本文提供的测试指南，针对自己的实际场景选择合适的工具。更多问题，请在 GitHub 上提 Issue 交流。&lt;/p>
&lt;h2 id="相关链接">相关链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Kitex: &lt;a href="https://github.com/cloudwego/kitex">https://github.com/cloudwego/kitex&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Netpoll: &lt;a href="https://github.com/cloudwego/netpoll">https://github.com/cloudwego/netpoll&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kitex-benchmark: &lt;a href="https://github.com/cloudwego/kitex-benchmark">https://github.com/cloudwego/kitex-benchmark&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>netpoll-benchmark: &lt;a href="https://github.com/cloudwego/netpoll-benchmark">https://github.com/cloudwego/netpoll-benchmark&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>官方 Protobuf 库: &lt;a href="https://github.com/golang/protobuf">https://github.com/golang/protobuf&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Thriftgo: &lt;a href="https://github.com/cloudwego/thriftgo">https://github.com/cloudwego/thriftgo&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.0.8 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/11/05/kitex-v0.0.8-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Fri, 05 Nov 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/11/05/kitex-v0.0.8-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="优化">优化&lt;/h2>
&lt;ul>
&lt;li>使用分片 ring 减少连接池的锁开销。&lt;/li>
&lt;li>装填 TTHeader 中的上游服务信息到 rpcinfo 中，用于在 decode 出错时输出来源信息。&lt;/li>
&lt;li>Unlink uds 调整至 CreateListener 中。&lt;/li>
&lt;li>event.go 和 ring_single.go 中的 Mutex 改为 RWMutex。&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复 netpollmux shard index 溢出的问题。&lt;/li>
&lt;li>移除 &lt;code>WithCircuitBreaker&lt;/code> option 里对参数的反射，避免 data-race。&lt;/li>
&lt;li>在重试场景下， 修复 rpc finish 错误导致的小概率失败的问题，并且加上了熔断 sample 的校验。&lt;/li>
&lt;li>修复 endpoint_test.go 中的一处单测错误。&lt;/li>
&lt;li>修改 conn_wrapper.go 中 longconn 变量命名为 conn.。&lt;/li>
&lt;/ul>
&lt;h2 id="生成工具">生成工具&lt;/h2>
&lt;ul>
&lt;li>代码生成工具支持透传thrift-go插件参数。&lt;/li>
&lt;/ul>
&lt;h2 id="文档">文档&lt;/h2>
&lt;ul>
&lt;li>将 README 中的性能结果改为引用 kitex-benchmark 仓库的数据。&lt;/li>
&lt;/ul>
&lt;h2 id="依赖变化">依赖变化&lt;/h2>
&lt;ul>
&lt;li>github.com/tidwall/gjson: v1.8.0 -&amp;gt; v1.9.3&lt;/li>
&lt;/ul></description></item><item><title>Blog: Kitex v0.0.5 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/09/26/kitex-v0.0.5-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/09/26/kitex-v0.0.5-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="功能">功能:&lt;/h2>
&lt;ul>
&lt;li>增加默认的 ErrorHandler 封装 Error（用户指定会被覆盖）。&lt;/li>
&lt;li>metainfo 支持反向传递。&lt;/li>
&lt;li>支持了 JSON 泛化调用，使用指南可参考：&lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/advanced-feature/generic_call/">Kitex 泛化调用使用指南&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="优化">优化:&lt;/h2>
&lt;ul>
&lt;li>多路复用场景下使用了新的 netpoll API 来改善吞吐和延迟。&lt;/li>
&lt;li>多路复用场景下支持 metainfo 的正向和反向传递。&lt;/li>
&lt;li>Client 会在需要的时候默认使用 RPCTimeout 中间件。&lt;/li>
&lt;li>连接池配置增加全局空闲连接和单实例空闲连接合法性校验。&lt;/li>
&lt;li>当更新 QPS 最大限制时会重置计数器。&lt;/li>
&lt;li>减小 QPS 限流的误差。&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>修复 WithExitWaitTime 没有正确设置退出等待时间的问题。&lt;/li>
&lt;li>修复更新 QPS 限制器更新间隔时，协程泄漏的问题。&lt;/li>
&lt;li>服务注册使用真实监听的地址。&lt;/li>
&lt;/ul>
&lt;h2 id="工具">工具:&lt;/h2>
&lt;ul>
&lt;li>修复了当 protobuf 文件只有 unary 方法时，生成出错的问题。&lt;/li>
&lt;/ul>
&lt;h2 id="文档">文档:&lt;/h2>
&lt;ul>
&lt;li>提供了英文版的README和其他文档。&lt;/li>
&lt;li>补充了泛化调用手册： &lt;a href="https://www.cloudwego.io/docs/kitex/tutorials/advanced-feature/generic_call/">English&lt;/a> | &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/advanced-feature/generic_call/">中文&lt;/a>。&lt;/li>
&lt;li>README 中增加了 landsapce 和 roadmap。&lt;/li>
&lt;/ul>
&lt;h2 id="依赖变化">依赖变化:&lt;/h2>
&lt;ul>
&lt;li>github.com/cloudwego/netpoll: v0.0.3 -&amp;gt; v0.0.4&lt;/li>
&lt;li>github.com/bytedance/gopkg: v0.0.0-20210709064845-3c00f9323f09 -&amp;gt; v0.0.0-20210910103821-e4efae9c17c3&lt;/li>
&lt;/ul></description></item><item><title>Blog: 字节跳动 Go RPC 框架 Kitex 性能优化实践</title><link>https://www.cloudwego.io/zh/blog/2021/09/23/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-go-rpc-%E6%A1%86%E6%9E%B6-kitex-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</link><pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/09/23/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-go-rpc-%E6%A1%86%E6%9E%B6-kitex-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</guid><description>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>Kitex 是字节跳动框架组研发的下一代高性能、强可扩展性的 Go RPC 框架。除具备丰富的服务治理特性外，相比其他框架还有以下特点：
集成了自研的网络库 Netpoll；支持多消息协议（Thrift、Protobuf）和多交互方式（Ping-Pong、Oneway、 Streaming）；提供了更加灵活可扩展的代码生成器。&lt;/p>
&lt;p>目前公司内主要业务线都已经大范围使用 Kitex，据统计当前接入服务数量多达 8k。Kitex 推出后，我们一直在不断地优化性能，本文将分享我们在 Netpoll 和 序列化方面的优化工作。&lt;/p>
&lt;h2 id="自研网络库-netpoll-优化">自研网络库 Netpoll 优化&lt;/h2>
&lt;p>自研的基于 epoll 的网络库 —— Netpoll，在性能方面有了较为显著的优化。测试数据表明，当前版本(2020.12) 相比于上次分享时(2020.05)，吞吐能力 ↑30%，延迟 AVG ↓25%，TP99 ↓67%，性能已远超官方 net 库。以下，我们将分享两点显著提升性能的方案。&lt;/p>
&lt;h3 id="epoll_wait-调度延迟优化">epoll_wait 调度延迟优化&lt;/h3>
&lt;p>Netpoll 在刚发布时，遇到了延迟 AVG 较低，但 TP99 较高的问题。经过认真研究 epoll_wait，我们发现结合 polling 和 event trigger 两种模式，并优化调度策略，可以显著降低延迟。&lt;/p>
&lt;p>首先我们来看 Go 官方提供的 syscall.EpollWait 方法：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">EpollWait&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">epfd&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">events&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#000">EpollEvent&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">n&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里共提供 3 个参数，分别表示 epoll 的 fd、回调事件、等待时间，其中只有 msec 是动态可调的。&lt;/p>
&lt;p>通常情况下，我们主动调用 EpollWait 都会设置 msec=-1，即无限等待事件到来。事实上不少开源网络库也是这么做的。但是我们研究发现，msec=-1 并不是最优解。&lt;/p>
&lt;p>epoll_wait 内核源码(如下) 表明，msec=-1 比 msec=0 增加了 fetch_events 检查，因此耗时更长。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#000">static&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">ep_poll&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">eventpoll&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">ep&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000">epoll_event&lt;/span> &lt;span style="color:#000">__user&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">events&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000">maxevents&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">long&lt;/span> &lt;span style="color:#000">timeout&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">timeout&lt;/span> &lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span> &lt;span style="color:#204a87;font-weight:bold">else&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">timeout&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">goto&lt;/span> &lt;span style="color:#000">send_events&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">fetch_events&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">eavail&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">goto&lt;/span> &lt;span style="color:#000">send_events&lt;/span>&lt;span style="color:#000;font-weight:bold">;&lt;/span>
&lt;span style="color:#000">send_events&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Benchmark 表明，在有事件触发的情况下，msec=0 比 msec=-1 调用要快 18% 左右，因此在频繁事件触发场景下，使用 msec=0 调用明显是更优的。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Benchmark&lt;/th>
&lt;th style="text-align:left">time/op&lt;/th>
&lt;th style="text-align:left">bytes/op&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">BenchmarkEpollWait, msec=0&lt;/td>
&lt;td style="text-align:left">270 ns/op&lt;/td>
&lt;td style="text-align:left">0 B/op&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkEpollWait, msec=-1&lt;/td>
&lt;td style="text-align:left">328 ns/op&lt;/td>
&lt;td style="text-align:left">0 B/op&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">EpollWait Delta&lt;/td>
&lt;td style="text-align:left">-17.68%&lt;/td>
&lt;td style="text-align:left">~&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>而在无事件触发的场景下，使用 msec=0 显然会造成无限轮询，空耗大量资源。&lt;/p>
&lt;p>综合考虑后，我们更希望在有事件触发时，使用 msec=0 调用，而在无事件时，使用 msec=-1 来减少轮询开销。伪代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">var&lt;/span> &lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">n&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">syscall&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">EpollWait&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">epfd&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">events&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">msec&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">n&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">continue&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么这样就可以了吗？事实证明优化效果并不明显。&lt;/p>
&lt;p>我们再做思考：&lt;/p>
&lt;p>msec=0 仅单次调用耗时减少 50ns，影响太小，如果想要进一步优化，必须要在调度逻辑上做出调整。&lt;/p>
&lt;p>进一步思考：&lt;/p>
&lt;p>上述伪代码中，当无事件触发，调整 msec=-1 时，直接 continue 会立即再次执行 EpollWait，而由于无事件，msec=-1，当前 goroutine 会 block 并被 P 切换。
但是被动切换效率较低，如果我们在 continue 前主动为 P 切换 goroutine，则可以节约时间。因此我们将上述伪代码改为如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">var&lt;/span> &lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">for&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">n&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">syscall&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">EpollWait&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">epfd&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">events&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">msec&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">n&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>
&lt;span style="color:#000">runtime&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Gosched&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">continue&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">msec&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>测试表明，调整代码后，吞吐量 ↑12%，TP99 ↓64%，获得了显著的延迟收益。&lt;/p>
&lt;h3 id="合理利用-unsafepointer">合理利用 unsafe.Pointer&lt;/h3>
&lt;p>继续研究 epoll_wait，我们发现 Go 官方对外提供的 syscall.EpollWait 和 runtime 自用的 epollwait 是不同的版本，即两者使用了不同的 EpollEvent。以下我们展示两者的区别：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8f5902;font-style:italic">// @syscall
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">EpollEvent&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">Events&lt;/span> &lt;span style="color:#204a87;font-weight:bold">uint32&lt;/span>
&lt;span style="color:#000">Fd&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int32&lt;/span>
&lt;span style="color:#000">Pad&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int32&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// @runtime
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">epollevent&lt;/span> &lt;span style="color:#204a87;font-weight:bold">struct&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">events&lt;/span> &lt;span style="color:#204a87;font-weight:bold">uint32&lt;/span>
&lt;span style="color:#000">data&lt;/span> &lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">8&lt;/span>&lt;span style="color:#000;font-weight:bold">]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// unaligned uintptr
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们看到，runtime 使用的 epollevent 是系统层 epoll 定义的原始结构；而对外版本则对其做了封装，将 epoll_data(epollevent.data) 拆分为固定的两字段：Fd 和 Pad。
那么 runtime 又是如何使用的呢？在源码里我们看到这样的逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">**&lt;/span>&lt;span style="color:#000">pollDesc&lt;/span>&lt;span style="color:#000;font-weight:bold">)(&lt;/span>&lt;span style="color:#000">unsafe&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Pointer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">ev&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">pd&lt;/span>
&lt;span style="color:#000">pd&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">**&lt;/span>&lt;span style="color:#000">pollDesc&lt;/span>&lt;span style="color:#000;font-weight:bold">)(&lt;/span>&lt;span style="color:#000">unsafe&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Pointer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">ev&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>显然，runtime 使用 epoll_data(&amp;amp;ev.data) 直接存储了 fd 对应结构体(pollDesc)的指针，这样在事件触发时，可以直接找到结构体对象，并执行相应逻辑。
而对外版本则由于只能获得封装后的 Fd 参数，因此需要引入额外的 Map 来增删改查结构体对象，这样性能肯定相差很多。&lt;/p>
&lt;p>所以我们果断抛弃了 syscall.EpollWait，转而仿照 runtime 自行设计了 EpollWait 调用，同样采用 unsafe.Pointer 存取结构体对象。测试表明，该方案下 吞吐量 ↑10%，TP99 ↓10%，获得了较为明显的收益。&lt;/p>
&lt;h2 id="thrift-序列化反序列化优化">Thrift 序列化/反序列化优化&lt;/h2>
&lt;p>序列化是指把数据结构或对象转换成字节序列的过程，反序列化则是相反的过程。RPC 在通信时需要约定好序列化协议，client 在发送请求前进行序列化，
字节序列通过网络传输到 server，server 再反序列进行逻辑处理，完成一次 RPC 请求。Thrift 支持 Binary、Compact 和 JSON 序列化协议。目前公司内部使用的基本都是 Binary，这里只介绍 Binary 协议。&lt;/p>
&lt;p>Binary 采用 TLV 编码实现，即每个字段都由 TLV 结构来描述，TLV 意为：Type 类型， Length 长度，Value 值，Value 也可以是个 TLV 结构，其中 Type 和 Length 的长度固定，Value 的长度则由 Length 的值决定。
TLV 编码结构简单清晰，并且扩展性较好，但是由于增加了 Type 和 Length，有额外的内存开销，特别是在大部分字段都是基本类型的情况下有不小的空间浪费。&lt;/p>
&lt;p>序列化和反序列的性能优化从大的方面来看可以从空间和时间两个维度进行优化。从兼容已有的 Binary 协议来看，空间上的优化似乎不太可行，只能从时间维度进行优化，包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>减少内存操作次数，包括内存分配和拷贝，尽量预分配内存，减少不必要的开销；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>减少函数调用次数，比如可调整代码结构和 inline 等手段进行优化；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="调研">调研&lt;/h3>
&lt;p>根据 go_serialization_benchmarks 的压测数据，我们找到了一些性能卓越的序列化方案进行调研，希望能够对我们的优化工作有所启发。&lt;/p>
&lt;p>通过对 protobuf、gogoprotobuf 和 Cap&amp;rsquo;n Proto 的分析，我们得出以下结论：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>网络传输中出于 IO 的考虑，都会尽量压缩传输数据，protobuf 采用了 Varint 编码在大部分场景中都有着不错的压缩效果；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>gogoprotobuf 采用预计算方式，在序列化时能够减少内存分配次数，进而减少了内存分配带来的系统调用、锁和 GC 等代价；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cap&amp;rsquo;n Proto 直接操作 buffer，也是减少了内存分配和内存拷贝（少了中间的数据结构），并且在 struct pointer 的设计中把固定长度类型数据和非固定长度类型数据分开处理，针对固定长度类型可以快速处理；&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>从兼容性考虑，不可能改变现有的 TLV 编码格式，因此数据压缩不太现实，但是 2 和 3 对我们的优化工作是有启发的，事实上我们也是采取了类似的思路。&lt;/p>
&lt;h3 id="思路">思路&lt;/h3>
&lt;h4 id="减少内存操作">减少内存操作&lt;/h4>
&lt;p>&lt;strong>buffer 管理&lt;/strong>&lt;/p>
&lt;p>无论是序列化还是反序列化，都是从一块内存拷贝数据到另一块内存，这就涉及到内存分配和内存拷贝操作，尽量避免内存操作可以减少不必要的系统调用、锁和 GC 等开销。&lt;/p>
&lt;p>事实上 Kitex 已经提供了 LinkBuffer 用于 buffer 的管理，LinkBuffer 设计上采用链式结构，由多个 block 组成，其中 block 是大小固定的内存块，构建对象池维护空闲 block，由此复用 block，减少内存占用和 GC。&lt;/p>
&lt;p>刚开始我们简单地采用 sync.Pool 来复用 netpoll 的 LinkBufferNode，但是这样仍然无法解决对于大包场景下的内存复用（大的 Node 不能回收，否则会导致内存泄漏）。
目前我们改成了维护一组 sync.Pool，每组中的 buffer size 都不同，新建 block 时根据最接近所需 size 的 pool 中去获取，这样可以尽可能复用内存，从测试来看内存分配和 GC 优化效果明显。&lt;/p>
&lt;p>&lt;strong>string / binary 零拷贝&lt;/strong>&lt;/p>
&lt;p>对于有一些业务，比如视频相关的业务，会在请求或者返回中有一个很大的 Binary 二进制数据代表了处理后的视频或者图片数据，同时会有一些业务会返回很大的 String（如全文信息等）。
这种场景下，我们通过火焰图看到的热点都在数据的 copy 上，那我们就想了，我们是否可以减少这种拷贝呢？&lt;/p>
&lt;p>答案是肯定的。既然我们底层使用的 Buffer 是个链表，那么就可以很容易地在链表中间插入一个节点。&lt;/p>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/buffer-linkerd-list.png" alt="!image">&lt;/p>
&lt;p>我们就采用了类似的思想，当序列化的过程中遇到了 string 或者 binary 的时候， 将这个节点的 buffer 分成两段，在中间原地插入用户的 string / binary 对应的 buffer，这样可以避免大的 string / binary 的拷贝了。&lt;/p>
&lt;p>这里再介绍一下，如果我们直接用 []byte(string) 去转换一个 string 到 []byte 的话实际上是会发生一次拷贝的，原因是 Go 的设计中 string 是 immutable 的但是 []byte 是 mutable 的，
所以这么转换的时候会拷贝一次；如果要不拷贝转换的话，就需要用到 unsafe 了：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000">StringToSliceByte&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span> &lt;span style="color:#204a87;font-weight:bold">string&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#204a87">len&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">s&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)(&lt;/span>&lt;span style="color:#000">unsafe&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Pointer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">reflect&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">SliceHeader&lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">Data&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">reflect&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">StringHeader&lt;/span>&lt;span style="color:#000;font-weight:bold">)(&lt;/span>&lt;span style="color:#000">unsafe&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Pointer&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">s&lt;/span>&lt;span style="color:#000;font-weight:bold">))).&lt;/span>&lt;span style="color:#000">Data&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;span style="color:#000">Len&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">l&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;span style="color:#000">Cap&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span> &lt;span style="color:#000">l&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>
&lt;span style="color:#000;font-weight:bold">}))&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码的意思是，先把 string 的地址拿到，再拼装上一个 slice byte 的 header，这样就可以不拷贝数据而将 string 转换成 []byte 了，不过要注意这样生成的 []byte 不可写，否则行为未定义。&lt;/p>
&lt;p>&lt;strong>预计算&lt;/strong>&lt;/p>
&lt;p>线上存在某些服务有大包传输的场景，这种场景下会引入不小的序列化 / 反序列化开销。一般大包都是容器类型的大小非常大导致的，如果能够提前计算出 buffer，一些 O(n) 的操作就能降到 O(1)，减少了函数调用次数，在大包场景下也大量减少了内存分配的次数，带来的收益是可观的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基本类型&lt;/p>
&lt;ul>
&lt;li>如果容器元素为基本类型（bool, byte, i16, i32, i64, double）的话，由于基本类型大小固定，在序列化时是可以提前计算出总的大小，并且一次性分配足够的 buffer，O(n) 的 malloc 操作次数可以降到 O(1)，从而大量减少了 malloc 的次数，同理在反序列化时可以减少 next 的操作次数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>struct 字段重排&lt;/p>
&lt;ul>
&lt;li>
&lt;p>上面的优化只能针对容器元素类型为基本类型的有效，那么对于元素类型为 struct 的是否也能优化呢？答案是肯定的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>沿用上面的思路，假如 struct 中如果存在基本类型的 field，也可以预先计算出这些 field 的大小，在序列化时为这些 field 提前分配 buffer，写的时候也把这些 field 顺序统一放到前面写，这样也能在一定程度上减少 malloc 的次数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>一次性计算&lt;/p>
&lt;ul>
&lt;li>上面提到的是基本类型的优化，如果在序列化时，先遍历一遍 request 所有 field，便可以计算得到整个 request 的大小，提前分配好 buffer，在序列化和反序列时直接操作 buffer，这样对于非基本类型也能有优化效果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>定义新的 codec 接口：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">type&lt;/span> &lt;span style="color:#000">thriftMsgFastCodec&lt;/span> &lt;span style="color:#204a87;font-weight:bold">interface&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">BLength&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// count length of whole req/resp
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">FastWrite&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span>
&lt;span style="color:#000">FastRead&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">int&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在 Marshal 和 Unmarshal 接口中做相应改造：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">thriftCodec&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Marshal&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">message&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Message&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">out&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">ByteBuffer&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">msg&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ok&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">.(&lt;/span>&lt;span style="color:#000">thriftMsgFastCodec&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">ok&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">msgBeginLen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">MessageBeginLength&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">methodName&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">thrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">TMessageType&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">msgType&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#204a87">int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">seqID&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;span style="color:#000">msgEndLen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">MessageEndLength&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">out&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Malloc&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">msgBeginLen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">msg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">BLength&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+&lt;/span> &lt;span style="color:#000">msgEndLen&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// malloc once
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">perrors&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewProtocolErrorWithMsg&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">fmt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Sprintf&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;thrift marshal, Malloc failed: %s&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#000;font-weight:bold">()))&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteMessageBegin&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">methodName&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">thrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">TMessageType&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">msgType&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#204a87">int32&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">seqID&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">msg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">FastWrite&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteMessageEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">c&lt;/span> &lt;span style="color:#000">thriftCodec&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">Unmarshal&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">ctx&lt;/span> &lt;span style="color:#000">context&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Context&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">message&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Message&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">in&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">ByteBuffer&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">error&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000">data&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">message&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Data&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">msg&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">ok&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">data&lt;/span>&lt;span style="color:#000;font-weight:bold">.(&lt;/span>&lt;span style="color:#000">thriftMsgFastCodec&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#000">ok&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#000">message&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">PayloadLen&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">msgBeginLen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">MessageBeginLength&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">methodName&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">msgType&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">seqID&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#000">tProt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">next&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">message&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">PayloadLen&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span> &lt;span style="color:#000">msgBeginLen&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">-&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">MessageEndLength&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// next once
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewTransError&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">PROTOCOL_ERROR&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">_&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">msg&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">FastRead&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewTransError&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">PROTOCOL_ERROR&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">err&lt;/span> &lt;span style="color:#000;font-weight:bold">=&lt;/span> &lt;span style="color:#000">tProt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">ReadMessageEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">err&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">NewTransError&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">remote&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">PROTOCOL_ERROR&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">err&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Error&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">tProt&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Recycle&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">err&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>生成代码中也做相应改造：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Demo&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">BLength&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">StructBeginLength&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;Demo&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">field1Length&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">field2Length&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">field3Length&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#ce5c00;font-weight:bold">...&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">FieldStopLength&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#000">l&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">StructEndLength&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">l&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">func&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">*&lt;/span>&lt;span style="color:#000">Demo&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#000">FastWrite&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span> &lt;span style="color:#000;font-weight:bold">[]&lt;/span>&lt;span style="color:#204a87;font-weight:bold">byte&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span> &lt;span style="color:#204a87;font-weight:bold">int&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">:=&lt;/span> &lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteStructBegin&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:],&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;Demo&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">if&lt;/span> &lt;span style="color:#000">p&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">!=&lt;/span> &lt;span style="color:#204a87;font-weight:bold">nil&lt;/span> &lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">fastWriteField2&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">fastWriteField4&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">fastWriteField1&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">p&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">fastWriteField3&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteFieldStop&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#000">offset&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">+=&lt;/span> &lt;span style="color:#000">bthrift&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">Binary&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">WriteStructEnd&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">buf&lt;/span>&lt;span style="color:#000;font-weight:bold">[&lt;/span>&lt;span style="color:#000">offset&lt;/span>&lt;span style="color:#000;font-weight:bold">:])&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">return&lt;/span> &lt;span style="color:#000">offset&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="使用-simd-优化-thrift-编码">使用 SIMD 优化 Thrift 编码&lt;/h4>
&lt;p>公司内广泛使用 list&amp;lt;i64/i32&amp;gt; 类型来承载 ID 列表，并且 list&amp;lt;i64/i32&amp;gt; 的编码方式十分符合向量化的规律，于是我们用了 SIMD 来优化 list&amp;lt;i64/i32&amp;gt; 的编码过程。&lt;/p>
&lt;p>我们使用了 avx2，优化后的结果比较显著，在大数据量下针对 i64 可以提升 6 倍性能，针对 i32 可以提升 12 倍性能；在小数据量下提升更明显，针对 i64 可以提升 10 倍，针对 i32 可以提升 20 倍。&lt;/p>
&lt;h4 id="减少函数调用">减少函数调用&lt;/h4>
&lt;p>&lt;strong>inline&lt;/strong>&lt;/p>
&lt;p>inline 是在编译期间将一个函数调用原地展开，替换成这个函数的实现，它可以减少函数调用的开销以提高程序的性能。&lt;/p>
&lt;p>在 Go 中并不是所有函数都能 inline，使用参数-gflags=&amp;quot;-m&amp;quot;运行进程，可显示被 inline 的函数。以下几种情况无法内联：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>包含循环的函数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>包含以下内容的函数：闭包调用，select，for，defer，go 关键字创建的协程；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>超过一定长度的函数，默认情况下当解析 AST 时，Go 申请了 80 个节点作为内联的预算。每个节点都会消耗一个预算。比如，a = a + 1 这行代码包含了 5 个节点：AS, NAME, ADD, NAME, LITERAL。当一个函数的开销超过了这个预算，就无法内联。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>编译时通过指定参数-l可以指定编译器对代码内联的强度（go 1.9+），不过这里不推荐大家使用，在我们的测试场景下是 buggy 的，无法正常运行：&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#8f5902;font-style:italic">// The debug[&amp;#39;l&amp;#39;] flag controls the aggressiveness. Note that main() swaps level 0 and 1, making 1 the default and -l disable. Additional levels (beyond -l) may be buggy and are not supported.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// 0: disabled
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// 1: 80-nodes leaf functions, oneliners, panic, lazy typechecking (default)
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// 2: (unassigned)
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// 3: (unassigned)
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">// 4: allow non-leaf functions
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>内联虽然可以减少函数调用的开销，但是也可能因为存在重复代码，从而导致 CPU 缓存命中率降低，所以并不能盲目追求过度的内联，需要结合 profile 结果来具体分析。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">go &lt;span style="color:#204a87">test&lt;/span> -gcflags&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;-m=2&amp;#39;&lt;/span> -v -test.run TestNewCodec 2&amp;gt;&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> grep &lt;span style="color:#4e9a06">&amp;#34;function too complex&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> wc -l
&lt;span style="color:#0000cf;font-weight:bold">48&lt;/span>
go &lt;span style="color:#204a87">test&lt;/span> -gcflags&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;-m=2 -l=4&amp;#39;&lt;/span> -v -test.run TestNewCodec 2&amp;gt;&lt;span style="color:#000;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> grep &lt;span style="color:#4e9a06">&amp;#34;function too complex&amp;#34;&lt;/span> &lt;span style="color:#000;font-weight:bold">|&lt;/span> wc -l
&lt;span style="color:#0000cf;font-weight:bold">25&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的输出结果可以看出，加强内联程度确实减少了一些&amp;quot;function too complex&amp;quot;，看下 benchmark 结果：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Benchmark&lt;/th>
&lt;th style="text-align:left">time/op&lt;/th>
&lt;th style="text-align:left">bytes/op&lt;/th>
&lt;th style="text-align:left">allocs/op&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">BenchmarkOldMarshal-4&lt;/td>
&lt;td style="text-align:left">309 µs ± 2%&lt;/td>
&lt;td style="text-align:left">218KB&lt;/td>
&lt;td style="text-align:left">11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkNewMarshal-4&lt;/td>
&lt;td style="text-align:left">310 µs ± 3%&lt;/td>
&lt;td style="text-align:left">218KB&lt;/td>
&lt;td style="text-align:left">11&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上面开启最高程度的内联强度，确实消除了不少因为“function too complex”带来无法内联的函数，但是压测结果显示收益不太明显。&lt;/p>
&lt;h3 id="测试结果">测试结果&lt;/h3>
&lt;p>我们构建了基准测试来对比优化前后的性能，下面是测试结果。&lt;/p>
&lt;p>环境：Go 1.13.5 darwin/amd64 on a 2.5 GHz Intel Core i7 16GB&lt;/p>
&lt;p>&lt;strong>小包&lt;/strong>&lt;/p>
&lt;p>data size: 20KB&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Benchmark&lt;/th>
&lt;th style="text-align:left">time/op&lt;/th>
&lt;th style="text-align:left">bytes/op&lt;/th>
&lt;th style="text-align:left">allocs/op&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">BenchmarkOldMarshal-4&lt;/td>
&lt;td style="text-align:left">138 µs ± 3%&lt;/td>
&lt;td style="text-align:left">25.4KB&lt;/td>
&lt;td style="text-align:left">19&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkNewMarshal-4&lt;/td>
&lt;td style="text-align:left">29 µs ± 3%&lt;/td>
&lt;td style="text-align:left">26.4KB&lt;/td>
&lt;td style="text-align:left">11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Marshal Delta&lt;/td>
&lt;td style="text-align:left">-78.97%&lt;/td>
&lt;td style="text-align:left">3.87%&lt;/td>
&lt;td style="text-align:left">-42.11%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkOldUnmarshal-4&lt;/td>
&lt;td style="text-align:left">199 µs ± 3%&lt;/td>
&lt;td style="text-align:left">4720&lt;/td>
&lt;td style="text-align:left">1360&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkNewUnmarshal-4&lt;/td>
&lt;td style="text-align:left">94µs ± 5%&lt;/td>
&lt;td style="text-align:left">4700&lt;/td>
&lt;td style="text-align:left">1280&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Unmarshal Delta&lt;/td>
&lt;td style="text-align:left">-52.93%&lt;/td>
&lt;td style="text-align:left">-0.24%&lt;/td>
&lt;td style="text-align:left">-5.38%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>大包&lt;/strong>&lt;/p>
&lt;p>data size: 6MB&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Benchmark&lt;/th>
&lt;th style="text-align:left">time/op&lt;/th>
&lt;th style="text-align:left">bytes/op&lt;/th>
&lt;th style="text-align:left">allocs/op&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">BenchmarkOldMarshal-4&lt;/td>
&lt;td style="text-align:left">58.7ms ± 5%&lt;/td>
&lt;td style="text-align:left">6.96MB&lt;/td>
&lt;td style="text-align:left">3350&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkNewMarshal-4&lt;/td>
&lt;td style="text-align:left">13.3ms ± 3%&lt;/td>
&lt;td style="text-align:left">6.84MB&lt;/td>
&lt;td style="text-align:left">10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Marshal Delta&lt;/td>
&lt;td style="text-align:left">-77.30%&lt;/td>
&lt;td style="text-align:left">-1.71%&lt;/td>
&lt;td style="text-align:left">-99.64%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkOldUnmarshal-4&lt;/td>
&lt;td style="text-align:left">56.6ms ± 3%&lt;/td>
&lt;td style="text-align:left">17.4MB&lt;/td>
&lt;td style="text-align:left">391000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkNewUnmarshal-4&lt;/td>
&lt;td style="text-align:left">26.8ms ± 5%&lt;/td>
&lt;td style="text-align:left">17.5MB&lt;/td>
&lt;td style="text-align:left">390000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Unmarshal Delta&lt;/td>
&lt;td style="text-align:left">-52.54%&lt;/td>
&lt;td style="text-align:left">0.09%&lt;/td>
&lt;td style="text-align:left">-0.37%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="无拷贝序列化">无拷贝序列化&lt;/h2>
&lt;p>在一些 request 和 response 数据较大的服务中，序列化和反序列化的代价较高，有两种优化思路：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如前文所述进行序列化和反序列化的优化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以无拷贝序列化的方式进行调用&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="调研-1">调研&lt;/h3>
&lt;p>通过无拷贝序列化进行 RPC 调用，最早出自 Kenton Varda 的 Cap&amp;rsquo;n Proto 项目，Cap&amp;rsquo;n Proto 提供了一套数据交换格式和对应的编解码库。&lt;/p>
&lt;p>Cap&amp;rsquo;n Proto 本质上是开辟一个 bytes slice 作为 buffer ，所有对数据结构的读写操作都是直接读写 buffer，读写完成后，
在头部添加一些 buffer 的信息就可以直接发送，对端收到后即可读取，因为没有 Go 语言结构体作为中间存储，所有无需序列化这个步骤，反序列化亦然。&lt;/p>
&lt;p>简单总结下 Cap&amp;rsquo;n Proto 的特点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>所有数据的读写都是在一段连续内存中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将序列化操作前置，在数据 Get/Set 的同时进行编解码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在数据交换格式中，通过 pointer（数据存储位置的 offset）机制，使得数据可以存储在连续内存的任意位置，进而使得结构体中的数据可以以任意顺序读写&lt;/p>
&lt;ul>
&lt;li>对于结构体的固定大小字段，通过重新排列，使得这些字段存储在一块连续内存中&lt;/li>
&lt;li>对于结构体的不定大小字段（如 list），则通过一个固定大小的 pointer 来表示，pointer 中存储了包括数据位置在内的一些信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>首先 Cap&amp;rsquo;n Proto 没有 Go 语言结构体作为中间载体，得以减少一次拷贝，然后 Cap&amp;rsquo;n Proto 是在一段连续内存上进行操作，编码数据的读写可以一次完成，因为这两个原因，使得 Cap' Proto 的性能表现优秀。&lt;/p>
&lt;p>下面是相同数据结构下 Thrift 和 Cap&amp;rsquo;n Proto 的 Benchmark，考虑到 Cap&amp;rsquo;n Proto 是将编解码操作前置了，所以对比的是包括数据初始化在内的完整过程，即结构体数据初始化+（序列化）+写入 buffer +从 buffer 读出+（反序列化）+从结构体读出数据。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Thrift" data-lang="Thrift">&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">MyTest&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">i64&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Num&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">2&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Ano&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Ano&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">3&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">list&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">i64&lt;/span>&lt;span style="color:#000;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Nums&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#8f5902;font-style:italic">// 长度131072 大小1MB
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#204a87;font-weight:bold">struct&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Ano&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000;font-weight:bold">{&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1&lt;/span>&lt;span style="color:#000;font-weight:bold">:&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#204a87;font-weight:bold">i64&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline"> &lt;/span>&lt;span style="color:#000">Num&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>&lt;span style="color:#f8f8f8;text-decoration:underline">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Benchmark&lt;/th>
&lt;th style="text-align:left">Iter&lt;/th>
&lt;th style="text-align:left">time/op&lt;/th>
&lt;th style="text-align:left">bytes/op&lt;/th>
&lt;th style="text-align:left">alloc/op&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">BenchmarkThriftReadWrite&lt;/td>
&lt;td style="text-align:left">172&lt;/td>
&lt;td style="text-align:left">6855840 ns/op&lt;/td>
&lt;td style="text-align:left">3154209 B/op&lt;/td>
&lt;td style="text-align:left">545 allocs/op&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BenchmarkCapnpReadWrite&lt;/td>
&lt;td style="text-align:left">1500&lt;/td>
&lt;td style="text-align:left">844924 ns/op&lt;/td>
&lt;td style="text-align:left">2085713 B/op&lt;/td>
&lt;td style="text-align:left">9 allocs/op&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ReadWrite Delta&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">-87.68%&lt;/td>
&lt;td style="text-align:left">-33.88%&lt;/td>
&lt;td style="text-align:left">-98.35%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>（反序列化）+读出数据，视包大小，Cap&amp;rsquo;n Proto 性能大约是 Thrift 的 8-9 倍。写入数据+（序列化），视包大小，Cap&amp;rsquo;n Proto 性能大约是 Thrift 的 2-8 倍。整体性能 Cap' Proto 性能大约是 Thrift 的 4-8 倍。&lt;/p>
&lt;p>前面说了 Cap&amp;rsquo;n Proto 的优势，下面总结一下 Cap&amp;rsquo;n Proto 存在的一些问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Cap&amp;rsquo;n Proto 的连续内存存储这一特性带来的一个问题：当对不定大小数据进行 resize ，且需要的空间大于原有空间时，只能在后面重新分配一块空间，导致原来数据的空间成为了一个无法去掉的 hole 。
这个问题随着调用链路的不断 resize 会越来越严重，要解决只能在整个链路上严格约束：尽量避免对不定大小字段的 resize ，当不得不 resize 的时候，重新构建一个结构体并对数据进行深拷贝。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cap&amp;rsquo;n Proto 因为没有 Go 语言结构体作为中间载体，使得所有的字段都只能通过接口进行读写，用户体验较差。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="thrift-协议兼容的无拷贝序列化">Thrift 协议兼容的无拷贝序列化&lt;/h3>
&lt;p>Cap&amp;rsquo;n Proto 为了更好更高效地支持无拷贝序列化，使用了一套自研的编解码格式，但在现在 Thrift 和 ProtoBuf 占主流的环境中难以铺开。为了能在协议兼容的同时获得无拷贝序列化的性能，我们开始了 Thrift 协议兼容的无拷贝序列化的探索。&lt;/p>
&lt;p>Cap&amp;rsquo;n Proto 作为无拷贝序列化的标杆，那么我们就看看 Cap&amp;rsquo;n Proto 上的优化能否应用到 Thrift 上：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>自然是无拷贝序列化的核心，不使用 Go 语言结构体作为中间载体，减少一次拷贝。此优化点是协议无关的，能够适用于任何已有的协议，自然也能和 Thrift 协议兼容，但是从 Cap&amp;rsquo;n Proto 的使用上来看，用户体验还需要仔细打磨一下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Cap&amp;rsquo;n Proto 是在一段连续内存上进行操作，编码数据的读写可以一次完成。Cap&amp;rsquo;n Proto 得以在连续内存上操作的原因：有 pointer 机制，数据可以存储在任意位置，允许字段可以以任意顺序写入而不影响解码。
但是一方面，在连续内存上容易因为误操作，导致在 resize 的时候留下 hole，另一方面，Thrift 没有类似于 pointer 的机制，故而对数据布局有着更严格的要求。这里有两个思路：&lt;/p>
&lt;ul>
&lt;li>坚持在连续内存上进行操作，并对用户使用提出严格要求：1. resize 操作必须重新构建数据结构 2. 当存在结构体嵌套时，对字段写入顺序有着严格要求（可以想象为把一个存在嵌套的结构体从外往里展开，写入时需要按展开顺序写入），
且因为 Binary 等 TLV 编码的关系，在每个嵌套开始写入时，需要用户主动声明（如 StartWriteFieldX）。&lt;/li>
&lt;li>不完全在连续内存上操作，局部内存连续，可变字段则单独分配一块内存，既然内存不是完全连续的，自然也无法做到一次写操作便完成输出。为了尽可能接近一次写完数据的性能，我们采取了一种链式 buffer 的方案，
一方面当可变字段 resize 时只需替换链式 buffer 的一个节点，无需像 Cap&amp;rsquo;n Proto 一样重新构建结构体，另一方面在需要输出时无需像 Thrift 一样需要感知实际的结构，只要把整个链路上的 buffer 写入即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>先总结下目前确定的两个点：1. 不使用 Go 语言结构体作为中间载体，通过接口直接操作底层内存，在 Get/Set 时完成编解码 2. 通过链式 buffer 存储数据&lt;/p>
&lt;p>然后让我们看下目前还有待解决的问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>不使用 Go 语言结构体后带来的用户体验劣化&lt;/p>
&lt;ul>
&lt;li>解决方案：改善 Get/Set 接口的使用体验，尽可能做到和 Go 语言结构体同等的易用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Cap&amp;rsquo;n Proto 的 Binary Format 是针对无拷贝序列化场景专门设计的，虽然每次 Get 时都会进行一次解码，但是解码代价非常小。而 Thrift 的协议（以 Binary 为例），没有类似于 pointer 的机制，
当存在多个不定大小字段或者存在嵌套时，必须顺序解析而无法直接通过计算偏移拿到字段数据所在的位置，而每次 Get 都进行顺序解析的代价过于高昂。&lt;/p>
&lt;ul>
&lt;li>解决方案：我们在表示结构体的时候，除了记录结构体的 buffer 节点，还加了一个索引，里面记录了每个不定大小字段开始的 buffer 节点的指针。
下面是目前的无拷贝序列化方案与 FastRead/Write，在 4 核下的极限性能对比测试：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">包大小&lt;/th>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">QPS&lt;/th>
&lt;th style="text-align:left">TP90&lt;/th>
&lt;th style="text-align:left">TP99&lt;/th>
&lt;th style="text-align:left">TP999&lt;/th>
&lt;th style="text-align:left">CPU&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">1KB&lt;/td>
&lt;td style="text-align:left">无序列化&lt;/td>
&lt;td style="text-align:left">70,700&lt;/td>
&lt;td style="text-align:left">1 ms&lt;/td>
&lt;td style="text-align:left">3 ms&lt;/td>
&lt;td style="text-align:left">6 ms&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FastWrite/FastRead&lt;/td>
&lt;td style="text-align:left">82,490&lt;/td>
&lt;td style="text-align:left">1 ms&lt;/td>
&lt;td style="text-align:left">2 ms&lt;/td>
&lt;td style="text-align:left">4 ms&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">2KB&lt;/td>
&lt;td style="text-align:left">无序列化&lt;/td>
&lt;td style="text-align:left">65,000&lt;/td>
&lt;td style="text-align:left">1 ms&lt;/td>
&lt;td style="text-align:left">4 ms&lt;/td>
&lt;td style="text-align:left">9 ms&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FastWrite/FastRead&lt;/td>
&lt;td style="text-align:left">72,000&lt;/td>
&lt;td style="text-align:left">1 ms&lt;/td>
&lt;td style="text-align:left">2 ms&lt;/td>
&lt;td style="text-align:left">8 ms&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">4KB&lt;/td>
&lt;td style="text-align:left">无序列化&lt;/td>
&lt;td style="text-align:left">56,400&lt;/td>
&lt;td style="text-align:left">2 ms&lt;/td>
&lt;td style="text-align:left">5 ms&lt;/td>
&lt;td style="text-align:left">10 ms&lt;/td>
&lt;td style="text-align:left">380%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FastWrite/FastRead&lt;/td>
&lt;td style="text-align:left">52,700&lt;/td>
&lt;td style="text-align:left">2 ms&lt;/td>
&lt;td style="text-align:left">4 ms&lt;/td>
&lt;td style="text-align:left">10 ms&lt;/td>
&lt;td style="text-align:left">380%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">32KB&lt;/td>
&lt;td style="text-align:left">无序列化&lt;/td>
&lt;td style="text-align:left">27,400&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FastWrite/FastRead&lt;/td>
&lt;td style="text-align:left">19,500&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">/&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">1MB&lt;/td>
&lt;td style="text-align:left">无序列化&lt;/td>
&lt;td style="text-align:left">986&lt;/td>
&lt;td style="text-align:left">53 ms&lt;/td>
&lt;td style="text-align:left">56 ms&lt;/td>
&lt;td style="text-align:left">59 ms&lt;/td>
&lt;td style="text-align:left">260%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FastWrite/FastRead&lt;/td>
&lt;td style="text-align:left">942&lt;/td>
&lt;td style="text-align:left">55 ms&lt;/td>
&lt;td style="text-align:left">59 ms&lt;/td>
&lt;td style="text-align:left">62 ms&lt;/td>
&lt;td style="text-align:left">290%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">10MB&lt;/td>
&lt;td style="text-align:left">无序列化&lt;/td>
&lt;td style="text-align:left">82&lt;/td>
&lt;td style="text-align:left">630 ms&lt;/td>
&lt;td style="text-align:left">640 ms&lt;/td>
&lt;td style="text-align:left">645 ms&lt;/td>
&lt;td style="text-align:left">240%&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FastWrite/FastRead&lt;/td>
&lt;td style="text-align:left">82&lt;/td>
&lt;td style="text-align:left">630 ms&lt;/td>
&lt;td style="text-align:left">640 ms&lt;/td>
&lt;td style="text-align:left">640 ms&lt;/td>
&lt;td style="text-align:left">270%&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>测试结果概述：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>小包场景，无序列化性能表现较差，约为 FastWrite/FastRead 的 85%。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大包场景，无序列化性能表现较好，4K 以上的包较 FastWrite/FastRead 提升 7%-40%。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>希望以上的分享能够对社区有所帮助。同时，我们也在尝试 share memory-based IPC、io_uring、tcp zero copy 、RDMA 等，更好地提升 Kitex 性能；重点优化同机、同容器的通讯场景。欢迎各位感兴趣的同学加入我们，共同建设 Go 语言生态！&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/alecthomas/go_serialization_benchmarks">https://github.com/alecthomas/go_serialization_benchmarks&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://capnproto.org/">https://capnproto.org/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions-2/intrinsics-for-shuffle-operations-1/mm256-shuffle-epi8.html">Intel® C++ Compiler Classic Developer Guide and Reference&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Blog: Netpoll v0.0.4 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/09/16/netpoll-v0.0.4-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/09/16/netpoll-v0.0.4-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="优化">优化:&lt;/h2>
&lt;ul>
&lt;li>默认支持 TCP_NODELAY&lt;/li>
&lt;li>支持在一个循环中读写&lt;/li>
&lt;li>返回 nocopy rw 的真实错误&lt;/li>
&lt;li>更改了循环策略的默认数量&lt;/li>
&lt;li>重新定义了 EventLoop.Serve arg: Listener -&amp;gt; net.Listener&lt;/li>
&lt;li>在 DisableGopool 中增加了API&lt;/li>
&lt;li>删除了读锁&lt;/li>
&lt;li>连接 Flush API 调整为阻塞的&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>设置剩余待读取大小。&lt;/li>
&lt;/ul></description></item><item><title>Blog: 字节跳动开源内部微服务中间件 CloudWeGo</title><link>https://www.cloudwego.io/zh/blog/2021/09/07/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BC%80%E6%BA%90%E5%86%85%E9%83%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6-cloudwego/</link><pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/09/07/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%BC%80%E6%BA%90%E5%86%85%E9%83%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E9%97%B4%E4%BB%B6-cloudwego/</guid><description>
&lt;h2 id="开源背景">开源背景&lt;/h2>
&lt;p>&lt;a href="https://github.com/cloudwego">CloudWeGo&lt;/a> 是一套由字节跳动开源的、以 Go 语言为核心的、可快速构建企业级云原生架构的中间件集合，专注于微服务通信与治理，具备高性能、可扩展、高可靠的特点。&lt;/p>
&lt;p>字节跳动内部使用 Golang 作为主要的业务开发语言，我们支持着数万个 Golang 微服务的可靠通信，经过数量众多的微服务和海量流量的验证，我们已经有了较为成熟的微服务最佳实践，于是考虑将内部的实践开源出去丰富社区生态。
但微服务相关的项目较多，每个项目单独开源对外部用户并不友好，为了更好地让大家聚焦于微服务，我们以 CloudWeGo 作为项目名，逐步将内部微服务体系的项目开源，内外统一使用开源库，各项目以开源库为主进行迭代。&lt;/p>
&lt;p>内外维护一套代码，统一迭代演进，是我们开源前明确的原则，但毕竟涉及到代码库的调整，我们要保证内部用户尽可能无感知的迁移到开源库，本着对内部和开源用户负责的态度，我们要先确认内部可以平滑过渡，所以开源时并未对外宣传。
让我们欣慰的是，在未宣传的情况下，一个月内 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 收获了 1.2k stars，&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 收获了700+ stars。&lt;/p>
&lt;p>CloudWeGo 不仅仅是一个对外的开源项目，也是一个真实的超大规模企业级实践项目。&lt;/p>
&lt;p>我们希望通过 CloudWeGo 丰富云原生社区的 Golang 产品体系，助力其他企业快速构建云原生架构，也希望吸引外部开发者共建，促进面向多元场景支持的演进，丰富产品能力。&lt;/p>
&lt;p>因为 CloudWeGo 下的项目会依赖很多内部的基础工具库，我们也推动将内部常用的 Golang 基础工具库开源出去，统一在 &lt;a href="https://github.com/bytedance/gopkg">bytedance/gopkg&lt;/a> 维护。&lt;/p>
&lt;h2 id="cloudwego-开源项目">CloudWeGo 开源项目&lt;/h2>
&lt;p>CloudWeGo 第一批以 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> RPC 框架和 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 网络库为主开源四个项目。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 和 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 开源前我们发布过两篇文章 &lt;a href="https://mp.weixin.qq.com/s/Xoaoiotl7ZQoG2iXo9_DWg">字节跳动 Go RPC 框架 Kitex 性能优化实践&lt;/a>
和 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;amp;mid=2247485756&amp;amp;idx=1&amp;amp;sn=4d2712e4bfb9be27a790fa15159a7be1&amp;amp;chksm=e9d0c2dedea74bc8179af39888a5b2b99266587cad32744ad11092b91ec2e2babc74e69090e6&amp;amp;scene=21#wechat_redirect">字节跳动在 Go 网络库上的实践&lt;/a>
分享我们的实践，文章发布后大家都在关注我们什么时候开源，因为我们希望将成熟的实践开源出去，所以没有过早的推动开源。&lt;/p>
&lt;h3 id="kitex">Kitex&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 是字节跳动内部的 Golang 微服务 RPC 框架，具有高性能、强可扩展的主要特点。在 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 之前内部的 Golang 框架是 Kite，但 Kite 与 Thrift 深度耦合、生成代码逻辑重，
很难从网络模型或编解码层面改造优化，继续支持新特性势必会造成代码越发臃肿迭代受阻问题，于是我们针对曾经的痛点设计了新的框架 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。虽然 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 是新框架，但已经在线上应用一年多，目前字节内部超过 50% 的 Golang 微服务使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a>。&lt;/p>
&lt;p>以下简述 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的一些特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>高性能：网络传输模块 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 默认集成了自研的网络库 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，性能相较使用 go net 有显著优势；除了网络库带来的性能收益，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Thrift 编解码也做了优化，详见 &lt;a href="https://mp.weixin.qq.com/s/Xoaoiotl7ZQoG2iXo9_DWg">优化实践&lt;/a>。关于性能数据可参考 &lt;a href="https://github.com/cloudwego/kitex-benchmark">kitex-benchmark&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扩展性：&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 设计上做了模块划分，提供了较多的扩展接口以及默认的扩展实现，使用者也可以根据需要自行定制扩展，更多扩展能力参见 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/framework-exten/">文档&lt;/a>。&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 也并未耦合 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，开发者也可以选择其它网络库扩展使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息协议：RPC 消息协议默认支持 Thrift、Kitex Protobuf、gRPC。Thrift 支持 Buffered 和 Framed 二进制协议；Kitex Protobuf 是 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 自定义的 Protobuf 消息协议，协议格式类似 Thrift；gRPC 是对 gRPC 消息协议的支持，可以与 gRPC 互通。除此之外，使用者也可以扩展自己的消息协议。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传输协议：传输协议封装消息协议进行 RPC 互通，传输协议可以额外透传元信息，用于服务治理，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 支持的传输协议有 TTHeader、HTTP2。TTHeader 可以和 Thrift、Kitex Protobuf 结合使用；HTTP2 目前主要是结合 gRPC 协议使用，后续也会支持 Thrift。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多消息类型：支持 PingPong、Oneway、双向 Streaming。其中 Oneway 目前只对 Thrift 协议支持，双向 Streaming 只对 gRPC 支持，后续会考虑支持 Thrift 的双向 Streaming。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>服务治理：支持服务注册/发现、负载均衡、熔断、限流、重试、监控、链路跟踪、日志、诊断等服务治理模块，大部分均已提供默认扩展，使用者可选择集成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 内置代码生成工具，可支持生成 Thrift、Protobuf 以及脚手架代码。原生的 Thrift 代码由本次一起开源的 &lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 生成，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Thrift 的优化由 Kitex Tool 作为插件支持。Protobuf 代码由 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 作为官方 protoc 插件生成 ，目前暂未单独支持 Protobuf IDL 的解析和代码生成。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="netpoll">Netpoll&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 是字节跳动内部的 Golang 高性能、I/O 非阻塞的网络库，专注于 RPC 场景。&lt;/p>
&lt;p>RPC 通常有较重的处理逻辑（业务逻辑、编解码），耗时长，不能像 Redis 一样采用串行处理(必须异步)。而 Go 的标准库 net 设计了 BIO(Blocking I/O) 模式的 API，
为了保证异步处理，RPC 框架设计上需要为每个连接都分配一个 goroutine，这在空闲连接较多时，产生大量的空闲 goroutine，增加调度开销。
此外，&lt;a href="https://github.com/golang/go/blob/master/src/net/net.go">net.Conn&lt;/a> 没有提供检查连接活性的 API，很难设计出高效的连接池，池中的失效连接无法及时清理，复用低效。&lt;/p>
&lt;p>开源社区目前缺少专注于 RPC 方案的 Go 网络库。类似的项目如：&lt;a href="https://github.com/tidwall/evio">evio&lt;/a> , &lt;a href="https://github.com/panjf2000/gnet">gnet&lt;/a> 等，均面向 Redis, Haproxy 这样的场景。&lt;/p>
&lt;p>因此 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 应运而生，它借鉴了 evio 和 Netty 的优秀设计，具有出色的 &lt;a href="https://github.com/cloudwego/netpoll/blob/main/README_CN.md#%e6%80%a7%e8%83%bd">性能&lt;/a>，更适用于微服务架构。
同时，&lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a> 还提供了一些 &lt;a href="https://github.com/cloudwego/netpoll/blob/main/README_CN.md#%e7%89%b9%e6%80%a7">特性&lt;/a>，推荐在 RPC 框架中作为底层网络库。&lt;/p>
&lt;h3 id="thriftgo">Thriftgo&lt;/h3>
&lt;p>&lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 是 Go 语言实现的 Thrift IDL 解析和代码生成器，支持完善的 Thrift IDL 语法和语义检查，相较 Apache Thrift 官方的 Golang 生成代码，&lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 做了一些问题修复且支持插件机制，用户可根据需求自定义生成代码。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的代码生成工具就是 &lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 的插件，CloudWeGo 近期也会开源另一个 &lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 的插件 thrift-gen-validator，支持 IDL Validator，用于字段值校验，解决开发者需要自行实现代码校验逻辑的负担，弥补 Thrift 缺失的能力。&lt;/p>
&lt;p>&lt;a href="https://github.com/cloudwego/thriftgo">Thriftgo&lt;/a> 目前虽然仅支持生成 Golang Thrift 代码，但其定位是可支持各语言的 Thrift 代码生成，未来如果有需求，我们也会考虑生成其他语言的代码，同时我们也将尝试将其回馈至 Apache Thrift 社区。&lt;/p>
&lt;h3 id="netpoll-http2">Netpoll-http2&lt;/h3>
&lt;p>Netpoll-http2 是基于 Golang 标准库 golang.org/x/net/http2 的源码替换 go net 为 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，目前用于 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 gRPC 协议的支持，对 HTTP2 有需求的外部开发者也可以使用此库。&lt;/p>
&lt;h2 id="内外版本维护">内外版本维护&lt;/h2>
&lt;p>完整的微服务体系离不开基础的云生态，无论在公有云、私有云还是基于自己的基础设施开发微服务，都需要搭建额外的服务以很好的支持微服务的治理，比如治理平台、监控、链路跟踪、注册/发现、配置中心、服务网格等，
而且还存在一些定制的规范。字节跳动自然也有完善的内部服务支持微服务体系，但这些服务短期还无法开源，那 CloudWeGo 如何内外维护一套代码，统一迭代呢？&lt;/p>
&lt;p>CloudWeGo 下与内部生态没有耦合的项目，如 &lt;a href="https://github.com/cloudwego/netpoll">Netpoll&lt;/a>，直接迁移到开源库，内部依赖调整为开源库。&lt;/p>
&lt;p>而需要集成治理能力融入微服务体系的 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 则基于其扩展性，将内外部的代码做了拆分，&lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的核心代码迁移到开源库，内部库封装一层壳保证内部用户无感知升级。
集成内部治理特性的模块则作为 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的扩展保留在内部库，同时对于一些新的特性也会优先在内部库支持，稳定后迁移到开源库。&lt;/p>
&lt;p>对于使用 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 的开源用户，同样可以对 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 进行扩展，将 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 融入自己的微服务体系中，也希望开发者能贡献自己的扩展到 &lt;a href="https://github.com/kitex-contrib">kitex-contrib&lt;/a>，为更多用户提供便利。&lt;/p>
&lt;h2 id="未来展望">未来展望&lt;/h2>
&lt;p>&lt;strong>继续开源其他内部项目&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>我们会继续开源其他内部项目，如 HTTP 框架 Hertz、基于共享内存的 IPC 通信库 ShmIPC 等，提供更多场景的微服务需求支持。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>逐步开源经验证的、稳定的特性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>CloudWeGo 的主要项目均为字节内部微服务提供支持，新的特性通常会在内部验证，相对成熟后我们会逐步开源出去，比如对 ShmIPC 的集成、无序列化、无生成代码的支持等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>结合内外部用户需求，持续迭代&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>CloudWeGo 开源后除向内部提供支持外，我们也希望 CloudWeGo 能为外部用户提供良好的支持，帮助大家快速搭建自己的微服务体系，所以我们会面向内外部用户迭代。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>就开源一个月的反馈看，大家对 Protobuf 的诉求较为强烈。坦诚来说 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 虽然支持多协议，但字节内部 RPC 通信协议是 Thrift，对 Protobuf 无论是 Kitex Protobuf 还是兼容 gRPC 更多的是支持少部分内部用户的需求，
所以暂时未开展性能优化，生成代码也是直接使用 Protobuf 官方的二进制（gogo/protobuf 是基于生成代码优化 Protobuf 序列化性能的优秀开源库，
但很遗憾该库目前是停止维护状态，所以 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 并未选择 gogo），但鉴于大家强烈的诉求，我们会计划开展 &lt;a href="https://github.com/cloudwego/kitex">Kitex&lt;/a> 对 Protobuf 支持的性能优化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>欢迎大家向 CloudWeGo 提交 issue 和 PR 共建 CloudWeGo，我们诚心期待更多的开发者加入，也期待 CloudWeGo 助力越来越多的企业快速构建云原生架构。如果企业客户想内部试用，我们可以排期提供专项技术支持和交流，欢迎入群咨询。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.cloudwego.io/img/blog/LarkGroup.png" alt="!image">&lt;/p></description></item><item><title>Blog: Kitex v0.0.4 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/08/26/kitex-v0.0.4-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/08/26/kitex-v0.0.4-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="优化">优化:&lt;/h2>
&lt;ul>
&lt;li>transMetaHandler 在自定义 boundHandlers 之前执行，保证自定义 boundHandlers 可以拿到 RPCInfo 信息。&lt;/li>
&lt;li>TransError 暴露封装 error 的 typeID 用于支持自定义 Error 回传错误码。&lt;/li>
&lt;/ul>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>复用 RPCInfo 不对 stats level 重置， 以修复在使用 netpollmux 时 metric 丢失问题。&lt;/li>
&lt;li>清理不存在节点的连接池。&lt;/li>
&lt;li>Streaming 中增加 Netpoll EOF 错误判断来清除冗余的 warning 日志。&lt;/li>
&lt;li>修改熔断错误统计类型，非 Ignorable 错误类型均做熔断统计，以修复开源版本熔断无法正确生效和内部版本在开启mesh后重试熔断无法生效问题。&lt;/li>
&lt;/ul>
&lt;h2 id="工具">工具:&lt;/h2>
&lt;ul>
&lt;li>调整了 Protobuf unary 方法的生成代码，来同时支持 Kitex Protobuf 和 gRPC。&lt;/li>
&lt;li>升级了 thriftgo 版本来修复 golint。&lt;/li>
&lt;li>修复了生成代码中的错误。&lt;/li>
&lt;li>修复了流生成的代码缺少传输选项的错误。&lt;/li>
&lt;/ul>
&lt;h2 id="文档">文档:&lt;/h2>
&lt;ul>
&lt;li>添加了 Golong 配置部分的文档以及 Golang 版本要求。&lt;/li>
&lt;li>更新了一些现有文档。&lt;/li>
&lt;li>添加了一些英文文档。&lt;/li>
&lt;/ul>
&lt;h2 id="依赖变化">依赖变化:&lt;/h2>
&lt;ol>
&lt;li>Thriftgo: v0.0.2-0.20210726073420-0145861fcd04 -&amp;gt; v0.1.2&lt;/li>
&lt;li>Netpoll: v0.0.2 -&amp;gt; v0.0.3&lt;/li>
&lt;/ol></description></item><item><title>Blog: Kitex v0.0.3 版本发布</title><link>https://www.cloudwego.io/zh/blog/2021/08/01/kitex-v0.0.3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate><guid>https://www.cloudwego.io/zh/blog/2021/08/01/kitex-v0.0.3-%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/</guid><description>
&lt;h2 id="bug-修复">Bug 修复:&lt;/h2>
&lt;ul>
&lt;li>防止连接池被覆盖。&lt;/li>
&lt;/ul></description></item></channel></rss>